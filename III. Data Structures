#Add one to anInteger 
def addOne(anInteger):  
    anInteger = anInteger + 1
    print("anInteger:", anInteger)

#Create myInteger with the value 5
myInteger = 5   
print("myInteger before addOne:", myInteger)
#Call addOne on myInteger
addOne(myInteger)   
print("myInteger after addOne:", myInteger)

### Printing Memory Addresses
print(id())

### STRINGS ###

myString1 = "12345"
myString2 = "ABCDE"
# Prints True if myString1 is digital
print(myString2.isdigit())
# Prints True if myString2 is digital
print(myString2.isdigit())

# Checks if my_string is uppercase
my_string.isupper()

# Checks if my_string strats with character sequence "ABC"
my_string.startswith("ABC")

###

#Write a function called random_marks. random_marks should
#take three parameters, all integers. It should return a
#string.
#
#The first parameter represents how many apostrophes should
#be in the string. The second parameter represents how many
#quotation marks should be in the string. The third
#parameter represents how many apostrophe-quotation mark
#pairs should be in the string.
#
#For example, random_marks(3, 2, 3) would return this
#string: #'''""'"'"'"
#
#Note that there are three apostrophes, then two quotation
#marks, then three '" pairs.


#Add your function here!
def random_marks(num1, num2, num3):
    return (("'" * num1) + ('"' * num2) + (''''"''' * num3))

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: '''""'"'"'"

print(random_marks(3, 2, 3))


### Special characters
# use \n for a line break
myStringWithNewLine = "1234\n5678"
print(myStringWithNewLine) ##

## \t puts a tab
## \" includes character as is (usually " would indicate the end of a string)
## \\ prints just one slash without breaking

###

#Write a function called "steps" that should return a string 
#that, if printed, looks like this:
#
#111
#	222
#		333
#
#Note that the characters at the beginning of the second and
#third lines must be tabs, not spaces. There should be one
#tab on the second line and two on the third line.
#
#You may only declare ONE string in your function.
#
#Hint: Don't overthink this! We're literally just asking you
#to return one single string that just holds the above text.
#You don't have to build the string dynamically or anything.


#Write your function here!
def steps():
    return "111\n	222\n		333"


#The line below will test your function.
print(steps())


### Concatenate

## all return the same thing:
string1 = "12345"
string2 = "67890"
string3 = string1 + string2
print("Assignment concatenation: " + string 3)
print("In-Line concatenation: " + string1 + string2")
string1 += string 2
print("Self-assignment concatenation: " + string1)

###

#-----------------------------------------------------------
#Write a function called align_right. align_right should
#take two parameters: a string (a_string) and an integer
#(string_length), in that order.
#
#The function should return the same string with spaces
#added to the left so that the text is "right aligned" in a
#string. The number of spaces added should make the total
#string length equal string_length.
#
#For example: align_right("CS1301", 10) would return the
#string "    CS1301". Four spaces are added to the left so
#"CS1301" is right-aligned and the total string length is
#10.
#
#HINT: Remember, len(a_string) will give you the number of
#characters currently in a_string.


#Add your function here!
def align_right(a_string, string_length):    
    while len(a_string) < string_length:
        a_string = " " + a_string
    return a_string


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: "    CS1301"
print(align_right("CS1301", 10))

###

#Write a function called "last_n" that accepts two arguments:
#a string search_string and an integer n. The function should
#return the last n characters from search_string. If
#search_string is shorter than n characters, then it should
#return the entire value of search_string.


#Write your function here!
def last_n(string, number):
    start = len(string) - number
    last_n = string[start:]
    return last_n


#The code below will test your function. If your function
#works correctly, this should print 789, saur, and 1.
print(last_n("123456789", 3))
print(last_n("Bulbasaur", 4))
print(last_n("1", 5))

###

#Write a function called "scramble" that accepts a string
#as an argument and returns a new string. The new string 
#should start with the last half of the original string
#and end with the first half. 
#
#If the length of the string is odd, split the string 
#at the floor of the length / 2 (in other words, the second
#half is the longer half).
#
#For example:
#  scramble("abcd") -> "cdab"
#  screamble("abcde") -> "cdeab"
#  scramble("railroad")) -> "roadrail"
#  scramble("fireworks")) -> "worksfire"


#Write your function here!
def scramble(string):
    end = len(string) // 2
    last_half = string[end:]
    first_half = string[:end]
    return last_half + first_half


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print the results you see in the examples above.

string1 = "abcd"
string2 = "abcde"
string3 = "railroad"
string4 = "fireworks"
print(string1 + " -> " + scramble(string1))
print(string2 + " -> " + scramble(string2))
print(string3 + " -> " + scramble(string3))
print(string4 + " -> " + scramble(string4))

###

#Write a function called fancy_find. fancy_find should have
#two parameters: search_within and search_for.
#
#fancy_find should check if search_for is found within the
#string search_within. If it is, it should print the message
#"[search_for] found at index [index]!", with [search_for]
#and [index] replaced by the value of search_for and the
#index at which it is found. If search_for is not found
#within search_within, it should print, "[search_for] was
#not found within [search_within]!", again with the values
#of search_for and search_within.
#
#For example:
#
#  fancy_find("ABCDEF", "DEF") -> "DEF found at index 3!"
#  fancy_find("ABCDEF", "GHI") -> "GHI was not found within ABCDEF!"


#Add your function here!
def fancy_find(search_within, search_for):
    if search_for in search_within:
        return search_for + " found at index " + \
              str(search_within.find(search_for)) + "!"
    else:
        return search_for + " was not found within " + search_within \
               + "!"

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#DEF found at index 3!
#GHI was not found within ABCDEF!

print(fancy_find("ABCDEF", "DEF"))
print(fancy_find("ABCDEF", "GHI"))

###

myString = "ABCDEABCDEABCDE"

#Prints the first index of "CDE" in myString
print(myString.find("CDE")) 
#Prints the first index of "CDE" in myString after 5
print(myString.find("CDE", 5)) 
#Prints the first index of "CDE" in myString after 8
print(myString.find("CDE", 13)) 
#Prints the first index of "CDE" in myString between 4 and 10
print(myString.find("CDE", 4, 10)) 
#Prints the first index of "CDE" in myString between 3 and 6
print(myString.find("CDE", 3, 6)) 

###

#Recall in Unit 3 you wrote a function that would count the
#number of words in a string using loops. Now that you know
#something about string methods, though, let's do that again
#using a different approach.
#
#Write a function called "num_words" that accepts a string 
#as an argument and returns the number of words in the 
#string. You can assume all words are separated by a space,
#and that the string has at least one word. You do not need
#to worry about punctuation.
#
#For example:
#
#  num_words("Veni, Vidi, Vici.") -> 3
#
#This time, you may not use any loops. Hint: split() might
#come in handy.


#Write your function here!
def num_words(string):
    my_list = string.split(" ")
    count = len(my_list)
    return count

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 3, 2, 1, each on their own line.
print(num_words("Vini, Vidi, Vici."))
print(num_words("Hello, world!"))
print(num_words("HeyDavidwhyaren'ttherespacesinthissentence"))


### Useful string methods ###

mystring.capitalize()
mystring.lower()
mystring.upper()
mystring.title()                 ## capitalizes any character found after space
mystring.strip()                 ## strips any empty spaces at end
mystring.replace("MY", "YOUR")   ## replaces first instances of word with second
mystring.find("*")               ## gives index where * is 
mystring.count(".")              ## counts how many periods
string.startswith("G")           ## will check if string starts with G

mylist = mystring.split()        ## splits string into list of items
print("-".join(mylist))          ## adds "-" between each word in list

###

#One common issue with auto-generated text is a mismatch
#between numbers and whether a word is pluralized. For example,
#your code might accidentally say "You bought 1 items" or
#"You have 7 cat".
#
#Write a function called pluralize. pluralize should have three
#parameters: an integer and two strings. The integer is the
#number of some item. The first string is the string to use if
#the item should not be pluralized. The second string is the
#string to use if the item should be pluralized.
#
#pluralize should return the correct string based on the number
#and plural form: it should use the non-plural version if the
#number is 1, and the plural form for all other numbers.
#
#For example:
#
# pluralize(1, "cat", "cats") -> "1 cat"
# pluralize(7, "item", "items") -> "7 items"
# pluralize(127, "octopus", "octopi") -> "127 octopi"


#Add your code here!
def pluralize(integer, string1, string2):
    if integer == 1:
        return str(integer) + " " + string1
    else:
        return str(integer) + " " + string2
        


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#1 cat
#7 items
#127 octopi
print(pluralize(1, "cat", "cats"))
print(pluralize(7, "item", "items"))
print(pluralize(127, "octopus", "octopi"))

###

#Python, like most languages, actually uses numbers in the 
#background to represent individual characters in a string. 
#For example, "a" is assigned the numeric value of 97. 
#We call this the ordinal value. www.asciitable.com shows
#a table of ordinal values: the ordinal value is listed in
#the 'dec' column, and the actual character is listed in
#'chr' column.
#
#You'll notice, though, that many of the characters here
#are weird. The first 31 are cryptic characters that have
#special meaning to the computer. The extended codes haven't
#really been used since Windows came along. Beyond these
#255, the higher numbers are actually used to represent
#emojis.
#
#Now, think about when you're asked to create a password.
#Typically, there are restrictions on what characters you
#can use. How do you check if a password is valid? You
#could have a list of valid characters and check each
#character against that list, but that would be a really
#long list. Instead, let's use ordinal values.
#
#Write a function called "valid_char" that determines
#if a single character (a string of length one) has an
#ordinal value corresponding to a valid character for a
#password. Valid characters are any character on the
#keyboard except spaces. Return True if it's a valid
#character, False if it is not.
#
#Hint: you can find the ordinal value of a character using 
#the built-in Python function ord(): ord("a") -> 97
#
#Hint 2: the range of legal characters will be one
#continuous range (e.g. characters 55 through 65, not
#separate ranges like 55 through 65 and 69 through 79).
#You can use asciitable.com to look up what range you
#should use.


#Write your function here!
def valid_char(password):
    for char in password:
        if not (33 <= ord(char) <= 136):
            return False
    else:
        return True

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: True, False, True, False

print(valid_char("a"))
print(valid_char(" "))
print(valid_char("!"))
print(valid_char("☺"))

###

#Write function called third_character that accepts a
#string as an argument and returns the third character
#of the string. If the user inputs a string with fewer than
#3 characters, return "Too short". 


#Write your function here!
def third_character(string):
    try:
        return string[2]
    except:
        return "Too short"

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 1, o, and "Too short", each on a different line.
print(third_character("CS1301"))
print(third_character("Georgia Tech"))
print(third_character("GT"))

###

#Write a function called "num_changer" that accepts a string 
#of digits (0-9). You should make an integer from the digits 
#of the even indices and another number from the digits in 
#the odd indices. Return the sum of these two numbers. You 
#can assume the given string will have a length of at least 
#2 digits.
#
#For example, if the string was "123456", you would split
#this into two integers, 135 and 246. Adding them would give
#381. Or if the string was "13579", you would split this into
#159 and 37, then add them to get 196.
#
#Hint: You can do this with loops, but it's easier to do
#this with string slicing. Remember how we could pass a third
#argument to range() that would tell range how many numbers
#to skip? You can do something similar with string slices: if
#you include second colon in a string slice, the number
#that follows it lets you skip characters in the string. For
#example:
#
# "Hello, world!"[1:9] -> This gives "ello, wo".
# "Hello, world!"[1:9:2] -> This gives "el,w". Including :2
#    in the string slice skips every other letter. 
# "Hello, world!" [::3] -> This gives "Hl r!". Leaving the
#    first two spots blank tells it to look at the entire
#    string, but putting :3 at the end says to only take
#    every third character (H, l, space, r, and !).
#
#Hint 2: Remember, Python is zero-indexed. That means the
#first number in the string is at position 0, and so it goes
#in the even list.


#Write your function here!
def num_changer(string):
    even = ""
    odd = ""
    for num in string:
        if int(num) % 2 == 0:
            even += num
        if int(num) % 2 == 1:
            odd += num
    ans = int(even) + int(odd)
    return(ans)


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 123456 -> 381
string_int = "123456"
result = num_changer(string_int)
print(string_int + " -> " + str(result))

###

#Write a function called "num_changer" that accepts a string 
#of digits (0-9). You should make an integer from the digits 
#of the even indices and another number from the digits in 
#the odd indices. Return the sum of these two numbers. You 
#can assume the given string will have a length of at least 
#2 digits.
#
#For example, if the string was "123456", you would split
#this into two integers, 135 and 246. Adding them would give
#381. Or if the string was "13579", you would split this into
#159 and 37, then add them to get 196.
#
#Hint: You can do this with loops, but it's easier to do
#this with string slicing. Remember how we could pass a third
#argument to range() that would tell range how many numbers
#to skip? You can do something similar with string slices: if
#you include second colon in a string slice, the number
#that follows it lets you skip characters in the string. For
#example:
#
# "Hello, world!"[1:9] -> This gives "ello, wo".
# "Hello, world!"[1:9:2] -> This gives "el,w". Including :2
#    in the string slice skips every other letter. 
# "Hello, world!" [::3] -> This gives "Hl r!". Leaving the
#    first two spots blank tells it to look at the entire
#    string, but putting :3 at the end says to only take
#    every third character (H, l, space, r, and !).
#
#Hint 2: Remember, Python is zero-indexed. That means the
#first number in the string is at position 0, and so it goes
#in the even list.


#Write your function here!
def num_changer(digits_string):

    even_digits = digits_string[::2]
    odd_digits = digits_string[1::2]

    even_number = int(even_digits)
    odd_number = int(odd_digits)

    return even_number + odd_number



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 123456 -> 381
string_int = "13579"
result = num_changer(string_int)
print(string_int + " -> " + str(result))

###

#Write a function called "in_parentheses" that accepts a 
#single argument, a string representing a sentence that
#contains some words in parentheses. Your function should
#return the contents of the parentheses.
#
#For example:
#
# in_parentheses("This is a sentence (words!)") -> "words!"
#
#If no text appears in parentheses, return an empty string.
#Note that there are several edge cases introduced by this:
#all of the following function calls would return an empty
#string:
#
# in_parentheses("No parentheses")
# in_parentheses("Open ( only")
# in_parentheses("Closed ) only")
# in_parentheses("Closed ) before ( open")
#
#You may assume, however, that there will not be multiple
#open or closed parentheses.


#Write your function here!
def in_parentheses(sentence):
    open_index = sentence.find("(")
    close_index = sentence.find(")")
    if open_index != -1 and close_index != -1:
        return sentence[open_index + 1:close_index]
    else:
        return ""


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (including the blank lines):
#words!
#
#as he is doing right now
#
#
#!

print(in_parentheses("This is a sentence (words!)."))
print(in_parentheses("No parentheses here!"))
print(in_parentheses("David tends to use parentheses a lot (as he is doing right now). It tends to be quite annoying."))
print(in_parentheses("Open ( only"))
print(in_parentheses("Closed ) only"))
print(in_parentheses("Closed ) before ( open"))
print(in_parentheses("That's a lot of test cases(!)"))

###

#Write a function called 'string_type' which accepts one
#string argument and determines what type of string it is. 
#
# - If the string is empty, return "empty".
# - If the string is a single character, return "character".
# - If the string represents a single word, return "word".
#   The string is a single word if it has no spaces.
# - If the string is a whole sentence, return "sentence".
#   The string is a sentence if it contains spaces, but
#   at most one period.
# - If the string is a paragraph, return "paragraph". The
#   string is a paragraph if it contains both spaces and
#   multiple periods (we won't worry about other
#   punctuation marks).
# - If the string is multiple paragraphs, return "page".
#   The string is a paragraph if it contains any newline
#   characters ("\n").
#
#Hint: think carefully about what order you should check
#these conditions in.
#
#Hint 2: remember, there exists a count() method that
#counts the number of times a string appears in another
#string. For example, "blah blah blah".count("blah")
#would return 3.


#Write your function here!
def string_type(string):
    if string == "":
        return "empty"
    if len(string) == 1:
        return "character"
    if " " not in string:
        return "word"
    if " " in string and ("." in string or "!" in string) and (string.count(".") == 1 or string.count("!") == 1):
        return "sentence"
    if " " in string and "." in string and string.count(".") > 1 and "\n" not in string:
        return "paragraph"
    if "\n" in string:
        return "page"

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#empty
#character
#word
#sentence
#paragraph
#page
print(string_type(""))
print(string_type("!"))
print(string_type("CS1301."))
print(string_type("This is too many cases!"))
print(string_type("There's way too many ostriches. Why are there so many ostriches. The brochure said there'd only be a few ostriches."))
print(string_type("Paragraphs need to have multiple sentences. It's true.\nHowever, two is enough. Yes, two sentences can make a paragraph."))

###

#Recall that input from a user is always in the form of a string. 
#Write a function called "input_type" that gets user input and 
#determines what kind of string the user entered. The user input
#will be supplied as an argument to the function like normal.
#
#  - Your function should return "integer" if the string only
#    contains characters 0-9.
#  - Your function should return "float" if the string only
#    contains the numbers 0-9 and at most one period.
#  - You should return "boolean" if the user enters "True" or
#    "False". 
#  - Otherwise, you should return "string".


#Write your function here!
def input_type(string):
    if string.isdigit():
        return "integer"
    elif string.replace(".", "", 1).isdigit():
        return "float"
    elif string == "True" or string == "False":
        return "boolean"
    else:
        return "string"
        

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#string
#boolean
#float
#integer
print(input_type(""))
print(input_type("False"))
print(input_type("7.432621"))
print(input_type("2788"))

###

#Write a function called "quote_this" that accepts two 
#strings as arguments: a string representing a quote and
#a string of a name. The function should return a new
#string with the quote surrounded by quotation marks (")
#followed by a dash and the given name. For example:
#
#a = quote_this("Try and fail, but never fail to try.",
#"Jared Leto")
#print(a) 
#
#Will print:
#"Try and fail, but never fail to try." -Jared Leto
#
#If the code were to continue, this:
#
#b = quote_this(a, "Michael Scott")
#print(b)
#
#Would print:
#""Try and fail, but never fail to try." -Jared Leto"
#- Michael Scott


#Write your function here!
def quote_this(quote, name):
    return '"' + quote + '"' + " -" + name


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print the same output as the examples above.
a = quote_this("Try and fail, but never fail to try.", "Jared Leto")
print(a) 
b = quote_this(a, "Michael Scott")
print(b)

###

#Write a function called string_finder. string_finder should
#take two parameters: a target string and a search string.
#The function will look for the search string within the
#target string.
#
#The function should return a string representing where in
#the target string the search string was found:
#
# - If search string is at the very beginning of target
#   string, then return "Beginning". For example:
#   string_finder("Georgia Tech", "Georgia") -> "Beginning"
#
# - If search string is at the very end of target string,
#   then return "End". For example:
#   string_finder("Georgia Tech", "Tech") -> "End"
#
# - If search string is in target string but not at the
#   very beginning or very end, then return "Middle. For
#   example:
#   string_finder("Georgia Tech", "gia") -> "Middle"
#
# - If search string is not in target string at all, then
#   return "Not found". For example:
#   string_finder("Georgia Tech", "Idaho") -> "Not found"
#
#Assume that we're only interested in the first instance
#of the search string if it appears multiple times in the
#target string, and that search string is definitely
#shorter than target string.
#
#Hint: Don't be surprised if you find that the "End" case
#is the toughest! You'll need to look at the lengths of
#both the target string and the search string.


#Write your function here!
def string_finder(target, search):
    if target.startswith(search):
        return "Beginning"
    elif target.endswith(search):
        return "End"
    elif search in target:
        return "Middle"
    else:
        return "Not found"


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: Beginning, Middle, End, Not found, each on their own
#line.
print(string_finder("Georgia Tech", "Georgia"))
print(string_finder("Georgia Tech", "gia"))
print(string_finder("Georgia Tech", "Tech"))
print(string_finder("Georgia Tech", "Idaho"))

###

#We've talked about ordinal numbers before, but they can
#mean something else: "ordinal" is also the term for numbers
#like 1st, 2nd, 3rd, 4th, etc.

#Write a function called to_ordinal. to_ordinal should
#take as input an integer greater than 0. to_ordinal should
#return a string of the ordinal of the integer (according to
#the above definition of ordinal).
#
#For example:
#
# to_ordinal(1) -> 1st
# to_ordinal(2) -> 2nd
# to_ordinal(3) -> 3rd
# to_ordinal(4) -> 4th
# to_ordinal(5) -> 5th
# to_ordinal(11) -> 11th
# to_ordinal(21) -> 21st
#
#Generally, ordinal numbers are always the original integer
#plus "th" _unless_ the original integer ended with 1 (in
#which case you add "st"), 2 (in which case you add "nd"),
#or 3 (in which case you add "rd")... except for 11, 12, and
#13, which still end in "th".


#Add your function below!
def to_ordinal(integer):
    integer = str(integer)
    if integer == "11" or integer == "12" or integer == "13":
        return integer + "th"
    elif integer.endswith("1"):
        return integer + "st"
    elif integer.endswith("2"):
        return integer + "nd"
    elif integer.endswith("3"):
        return integer + "rd"
    else:
        return integer + "th"
        
        
#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#1st
#2nd
#3rd
#4th
#5th
#11th
#21st
print(to_ordinal(1))
print(to_ordinal(2))
print(to_ordinal(3))
print(to_ordinal(4))
print(to_ordinal(5))
print(to_ordinal(11))
print(to_ordinal(21))

###

#Write a function called to_metric. to_metric should take
#as input one parameter, a string. The string will represent
#a quantity in imperial volume units, such as "7 cups", "2
#tablespoons", or "8 gallons". to_metric should return the
#equivalent number of milliliters as a float. Round the
#result to two decimal places.
#
#The possible imperial units to handle and their conversion to
#milliliters are:
#
# - gallons: 3785.41 milliliters
# - quarts: 946.35 milliliters
# - pints: 473.18 milliliters
# - cups: 240 milliliters
# - ounces: 29.57 milliliters
# - tablespoons: 14.79 milliliters
# - teaspoons: 4.93 milliliters
#
#Return only the float representing the number of milliliters,
#not the label. For example:
#
#to_metric("7.0 cups") -> 1680
#to_metric("2.0 tablespoons") -> 29.58
#to_metric("8.0 gallons") -> 30283.28
#
#You may assume that the string will be formatted like the
#strings above: a decimal number, then a space, then one of
#the following words: cgallons, quarts, pints, cups, ounces,
#tablespoons, teaspoons


#Add your code here!
def to_metric(input_string):

    conversion = {"gallons": 3785.41, "quarts": 946.35, "pints": 473.18, "cups": 240, "ounces": 29.57, "tablespoons": 14.79, "teaspoons": 4.93}

    quantity, unit = input_string.split()
    numeric_value = float(quantity)
    result = numeric_value * conversion[unit]
    return round(result, 2)


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#1680
#29.58
#30283.28
print(to_metric("7.0 cups"))
print(to_metric("2.0 tablespoons"))
print(to_metric("8.0 gallons"))

###

#One common function of online text-parsers is trying to find
#known text in a block of other text. For example, from a web
#site, we might want to find any phone numbers present on the
#web site.
#
#Write a function called find_phone_number. The function
#should have one parameter, a string. The function should
#return the phone number that was present in the string.
#
#For this problem, you may make the following assumptions:
#
# - The phone number will be all digits, such as 4043219876.
# - There will only be one phone number in the string.
# - There will be a phone number in the string.
# - Either the phone number will be at the start or end of
#   the string, or it will have spaces on either side of it.
#
#There may be other numbers in the string, but there will only
#be one 10-digit number. Find and return that number as a
#string.
#
#Hint: There are lots of different ways to do this. Think about
#all the tools at your disposal: split, find, casting strings
#to integers, error handling, etc.!


#Add your code here!
def find_phone_number(string):
    phone_number = ""

    for char in range(len(string) - 9):
        potential_phone = string[char:char+10]
        if potential_phone.isdigit():
            phone_number = potential_phone
            break

    return phone_number


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#4049876543
#7705551234
#6789123456
print(find_phone_number("hello 4049876543 goodbye"))
print(find_phone_number("7705551234 this is alex"))
print(find_phone_number("doh ray me abc 123 its 6789123456"))

###


























### TUPLES ###

#Write a function called unpack_and_reverse that will
#accept one parameter, a tuple with at least three items.
#The function should return a new tuple with only the first
#three items, but listed in reverse order.
#
#For example:
#
# a_tuple = ("a", "b", "c", "d", "e")
# unpack_and_reverse(a_tuple) -> ("c", "b", "a")
#
#However, to do this, you should not access any value in
#the tuple directly (e.g. with a_tuple[1]). Instead, you
#should use tuple unpacking to unpack them into variables.
#You also should not touch any items past the third item
#in the tuple: use tuple slicing instead to only access
#the first three.

#Write your function here!
def unpack_and_reverse(mytuple):
    a, b, c = mytuple[0:3]
    return c, b, a

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#('c', 'b', 'a')
#('h', 'g', 'f')
#('k', 'j', 'i')
print(unpack_and_reverse(("a", "b", "c", "d", "e")))
print(unpack_and_reverse(("f", "g", "h")))
print(unpack_and_reverse(("i", "j", "k", "l", "m", "n", "o", "p", "q", "r")))

###

#Remember asciitable.com from an earlier exercise? We're
#going to use it again. Remember, ordinal values for
#characters are given in the 'Dec' column of asciitable.com.
#
#Write a function called character_info. character_info will
#take as input a string with only one character. It should
#return a 3-tuple with three pieces of information:
#
# - In the first spot, the character itself.
# - In the second spot, the ordinal value of the character,
#   obtained using the ord() function (e.g. ord("a") -> 97).
# - In the third spot, what type of character it is: either
#   "letter", "number", or "punctuation".
#
#You may assume that anything that is not a letter (either
#upper or lower case) or a number is punctuation. You may
#also assume the ordinal will be between 32 (" ") and 126
#("~").


#Write your function here!
def character_info(char):
    if char in "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz":
        char_type = "letter"
    elif char in "1234567890":
        char_type = "number"
    else:
        char_type = "punctuation"
    return (char, ord(char), char_type)
    
        
#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#('q', 113, 'letter')
#('7', 55, 'number')
#('`', 96, 'punctuation')
print(character_info("q"))
print(character_info("7"))
print(character_info("`"))

### List functions ###

mylist.sort()                     ## sorts low to high
mylist.append()                   ## adds to list
mylist.extend()                   ## adds to list
mylist.insert(location, value)    ## inserts value after location
mylist.remove()                   ## removes given value from list
mylist.reverse()                  ## reverses list
mylist.pop()                      ## removes last item from list (and stores it)
del mylist[-5:]                   ## removes all values starting at five from the end
mylist.index(23)                  ## shows where value 23 is indexed
mylist.count(15)                  ## counts how many times 15 occurs in list
print(4 in mylist)                ## prints False since 4 isn't in list

###

#Write a function called modify_list. modify_list will
#take one parameter, a list. It should then modify the
#list in the following ways, in this order:
#
# - Sort the list (using the default sort method).
# - Reverse the order of the list.
# - Delete the last three items of the list.
# - Removes one instance the integer 7 from the list, if
#   it's present.
# - Double the values of the first and third items in
#   the list.
#
#It should then return the resulting list. You may assume
#the list will start with at least six items.
#
#Hint: Remember Python is 0-indexed. The second item
#does not have an index of 2.
#
#Hint 2: Remember, the list.remove() function removes items
#by value, not by index. Note also that if the item you're
#trying to remove is not found in the list, remove() will
#throw an error: so, you'll want to avoid that one way or
#another!


#Write your code here!
def modify_list(mylist):
    mylist.sort()
    mylist.reverse()
    del mylist[-3:]
    if 7 in mylist:
        mylist.remove(7)
    mylist[0] *= 2
    mylist[2] *= 2
    return mylist


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#[178, 81, 75.0, 4, 3.141592653589793, 3]
import math
print(modify_list([7, 4, 3, 2.0, 81, 37.5, 89, math.pi, -2, math.e]))

###

#Write a function called multiply_strings. Multiply
#strings should have one parameter, a list of strings.
#It should return a modified list according to the
#following changes:
#
# - Every string stored at an even index should be
#   doubled.
# - Every string stored at an index that is a multiple
#   of 3 should be tripled.
# - Every other string should remain unchanged.
#
#These changes should "stack": the string stored at index
#6 should be duplicated six times (2 * 3).
#
#Then, return the new list. You may assume that 0 is a
#multiple of 2 and 3.
#
#Hint: To do this, you need to modify the values of the
#list using their indices, e.g. a_list[1]. If you're not
#using their indices, your answer won't work!


#Write your function here!
def multiply_strings(list_of_strings):
    for string in range(0, len(list_of_strings), 2):
        list_of_strings[string] *= 2
    for string in range(0, len(list_of_strings), 3):
        list_of_strings[string] *= 3
    return list_of_strings


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 
#['AAAAAA', 'B', 'CC', 'DDD', 'EE', 'F', 'GGGGGG']
test_list = ["A", "B", "C", "D", "E", "F", "G"]
print(multiply_strings(test_list))

###

#Write a function called sum_lists. sum_lists should take
#one parameter, which will be a list of lists of integers.
#sum_lists should return the sum of adding every number from
#every list.
#
#For example:
#
# list_of_lists = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
# sum_list(list_of_lists) -> 67


#Add your code here!
def sum_lists(list_of_lists):
    sum = 0
    for single_list in list_of_lists:
        for item in single_list:
            sum += item
    return sum


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 78
list_of_lists = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
print(sum_lists(list_of_lists))

###

#We've learned a lot in this chapter. Let's try to use a lot
#of it for one final exercise.
#
#Write a function called sort_artists. sort_artists will
#take as input a list of tuples. Each tuple will have two
#items: the first item will be a string holding an artist's
#name, and the second will be an integer representing their
#total album sales (in millions).
#
#Return a tuple of two lists. The first list in the
#resulting tuple should be all the artists sorted
#alphabetically. The second list should be all the revenues
#sorted in descending numerical order.
#
#For example:
# artists = [("The Beatles", 270.8), ("Elvis Presley", 211.5), ("Michael Jackson", 183.9)]
# sort_artists(artists) -> (["Elvis Presley", "Michael Jackson", "The Beatles"], [270.8, 211.5, 183.9])
#
#Notice that artists is a list of tuples (brackets first,
#then parentheses), but sort_artists outputs a tuple of
#lists (parentheses first, then brackets).


#Write your function here!
def sort_artists(artist_list):
    
    artists = []
    sales = []
    
    for artist_tuple in artist_list:        
        artists.append(artist_tuple[0])        
        sales.append(artist_tuple[1])
      
    artists.sort()
    sales.sort()
    sales.reverse()
    
    return (artists, sales)
    

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#(['Elvis Presley', 'Michael Jackson', 'The Beatles'], [270.8, 211.5, 183.9])  
artists = [("The Beatles", 270.8), ("Elvis Presley", 211.5), ("Michael Jackson", 183.9)]
print(sort_artists(artists))

###

#Averages each list in in2DList
def TwoDAverageWithPop(in2DList):  
    result = []
    #Repeat until in2DList is empty
    while len(in2DList) > 0:    
        #Remove and assign the last item of in2DList to numList
        numList = in2DList.pop()    
        sum = 0
        count = 0
        #Repeat until numList is empty
        while len(numList) > 0: 
            #Remove and save the last item of numList to number
            number = numList.pop()  
            sum += number
            count += 1
        #Insert this average at the beginning of result
        result.insert(0, sum / count)   
    return result

my2DList = [[91, 95, 89, 92, 85],[85, 87, 91, 81, 82],
            [79, 75, 85, 83, 89],[81, 89, 91, 91, 90],
            [99, 91, 95, 89, 90]]

print("Averages:", TwoDAverageWithPop(my2DList))
print("my2DList:", my2DList)


### FILE INPUT AND OUTPUT ###

myInt1 = 12
myInt2 = 23
myInt3 = 34

#Open OutputFile.txt in write mode
outputFile = open("OutputFile.txt", "w")    

#Write myInt1 to outputFile
outputFile.write(str(myInt1))    
#Write myInt2 to outputFile
outputFile.write(str(myInt2))    
#Write myInt3 to outputFile
outputFile.write(str(myInt3))    
#Close outputFile
outputFile.close()  

###

#Write a function called "write_file" that accepts two 
#parameters: a filename and some data that will either 
#be an integer or a string to write. The function 
#should open the file and write the data to the file.
#
#Hints:
#
# - Don't forget to close the file when you're done!
# - If the data isn't a string already, you may need
#   to convert it, depending on the approach you
#   choose.
# - Remember, this code has no print statements, so
#   when you run it, don't expect to see any output
#   on the right! You could add print statements if
#   you want a confirmation the code is done running.
# - You can put the variable for the filename in the
#   same place where we put text like OutputFile.txt
#   in the videos.


#Write your function here!
def write_file(filename, data):
    output_file = open(filename, "w")
    output_file.write(str(data))
    output_file.close()


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print nothing. However, if you open WriteFileOutput.txt
#in the top left after running it, the contents of the
#file should be 1301.
write_file("WriteFileOutput.txt", 1301)

###

#Write a function called "append_to_file" that accepts
#two parameters: a filename and some data that will
#be an integer or a string to write. The function 
#should open the file and add the data to the end of
#the file. Each new call to append_to_file should add
#the new contents on a new line.
#
#Hints:
#
# - Don't forget to close the file when you're done!
# - If the data isn't a string already, you may need
#   to convert it.
# - Remember, this code has no print statements, so
#   when you run it, don't expect to see any output
#   on the right! You could add print statements if
#   you want a confirmation the code is done running.
# - You can put the variable for the filename in the
#   same place where we put text like OutputFile.txt
#   in the videos.


#Write your function here!
def append_to_file(filename, data):
    output_file = open(filename, "a")
    output_file.write(str(data) + "\n")
    output_file.close()

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print nothing. However, if you open AppendToFileOutput.txt
#in the top left after running it, the contents of the
#file should be another instance of 1301 every time you
#run this file.
append_to_file("AppendToFileOutput.txt", 1301)

###

myList = ["David", "Lucy", "Vrushali", "Ping",
          "Natalie", "Dana", "Addison", "Jasmine"]

#Open OutputFile.txt in write mode
outputFile = open("OutputFile.txt", "w")    

#For each name in myList
for name in myList: 
    #Write the name to the file on its own line
    print(name, file = outputFile)   

outputFile.close()

###

myList = ["David", "Lucy", "Vrushali", "Ping", 
          "Natalie", "Dana", "Addison", "Jasmine"]

#Open OutputFile.txt in write mode
outputFile = open("OutputFile.txt", "w")    

#For each name in myList
for name in myList: 
    #Write the name to the file on its own line
    outputFile.write(name + "\n")   

outputFile.close()

###

myList = ["David", "Lucy", "Vrushali", "Ping",
          "Natalie", "Dana", "Addison", "Jasmine"]

#Open OutputFile.txt in write mode
outputFile = open("OutputFile.txt", "w")    

#Writes every string in myList to a file
outputFile.writelines(myList)   

outputFile.close()

###

myList = ["David", "Lucy", "Vrushali", "Ping",
          "Natalie", "Dana", "Addison", "Jasmine"]
 
#Open OutputFile.txt in write mode
outputFile = open("OutputFile.txt", "w")    
 
#Joins myList using \n, then writes it to a file
outputFile.write("\n".join(myList))   
 
outputFile.close()

###

myInt1 = 12
myInt2 = 23
myInt3 = 34
myList = ["David", "Lucy", "Vrushali", "Ping", 
          "Natalie", "Dana", "Addison", "Jasmine"]

#Open OutputFile.txt in write mode
outputFile = open("OutputFile.txt", "w")    

#Write myInt1 to outputFile
outputFile.write(str(myInt1) + "\n")    
#Write myInt2 to outputFile
outputFile.write(str(myInt2) + "\n")    
#Write myInt3 to outputFile
outputFile.write(str(myInt3) + "\n")    
#Joins myList using \n, then writes it to a file
outputFile.write("\n".join(myList))   

outputFile.close()

###

#Write a function called "find_coffee" that expects a 
#filename as a parameter. The function should open the 
#given file and return True if the file contains the word 
#"coffee". Otherwise, the function should return False.
#
#Hint: look up the read() method if you want to do this
#more simply than you might do with readline().


#Write your function here!
def find_coffee(filename):
    input_file = open(filename, "r")
    file_contents = input_file.read()
    input_file.close()
    if "coffee" in file_contents:
        return True
    else:
        return False

#You can test your function with the provided files named 
#"coffeeful.txt" and "coffeeless.txt". With their original
#text, the lines below should print True, then False. You
#may also edit the files by selecting them in the drop
#down in the top left to try your code with different
#input.
print(find_coffee("coffeeful.txt"))
print(find_coffee("coffeeless.txt"))

###

#Write a function called "load_file" that accepts one 
#parameter: a filename. The function should open the
#file and return the contents.#
#
# - If the contents of the file can be interpreted as
#   an integer, return the contents as an integer.
# - Otherwise, if the contents of the file can be
#   interpreted as a float, return the contents as a
#   float.
# - Otherwise, return the contents of the file as a
#   string.
#
#You may assume that the file has only one line.
#
#Hints:
#
# - Don't forget to close the file when you're done!
# - Remember, anything you read from a file is
#   initially interpreted as a string.


#Write your function here!
def load_file(filename):
    input_file = open(filename, "r")
    contents = input_file.readline()
    try:
        return int(contents)
    except ValueError:
        try:
            return float(contents)    
        except:
            return str(contents)
    finally:
        input_file.close()


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print 123, followed by <class 'int'>.
contents = load_file("LoadFromFileInput.txt")
print(contents)
print(type(contents))

###

myList = []

#Open OutputFile.txt in read mode
inputFile = open("OutputFile.txt", "r")    

#For each line in the file
for line in inputFile:  
    #Add the line to myList, stripping out whitespace
    myList.append(line.strip()) 

print(myList)

inputFile.close()

###

myList = []

#Open OutputFile.txt in read mode
inputFile = open("OutputFile.txt", "r")    

myInt1 = int(inputFile.readline())  
myInt2 = int(inputFile.readline())  
myInt3 = int(inputFile.readline())  
#For each line in the file
for line in inputFile:  
    #Add the line to myList, stripping out whitespace
    myList.append(line.strip()) 

print(myInt1)
print(myInt2)
print(myInt3)
print(myList)

inputFile.close()

###

#Saves inList to the file
def save(filename, inList): 
    outputFile = open(filename, "w")

    for item in inList: 
        print(item, file = outputFile)   

    outputFile.close()

#Loads from filename and returns a list of the contents
def load(filename): 
    inputFile = open(filename, "r")
    inList = []

    for line in inputFile:
        inList.append(line.strip())
    inputFile.close()
    return inList

myList = ["David", "Lucy", "Vrushali", "Ping", "Natalie",
          "Dana", "Addison", "Jasmine"]
save("OutputFile.txt", myList)
newList = load("OutputFile.txt")

print(newList)

###

inputFile = open("OutputFile.txt", "r")
print(inputFile)
inputFile.close()

###

inputFile = open("OutputFile.txt", "r")

#Print the next line of inputFile
print(inputFile.readline()) 
#Print the next line of inputFile
print(inputFile.readline()) 
#Print the next line of inputFile
print(inputFile.readline()) 

inputFile.close()

###

inputFile = open("OutputFile.txt", "r")

#Print the next line of inputFile
print(inputFile.readline().strip()) 
#Print the next line of inputFile
print(inputFile.readline().strip()) 
#Print the next line of inputFile
print(inputFile.readline().strip()) 

inputFile.close()

###

inputFile = open("OutputFile.txt", "r")

#Read the next line of inputFile, cast it 
#to int, and assign it to myInt1
myInt1 = int(inputFile.readline())  
#Read the next line of inputFile, cast it 
#to int, and assign it to myInt2
myInt2 = int(inputFile.readline())  
#Read the next line of inputFile, cast it 
#to int, and assign it to myInt3
myInt3 = int(inputFile.readline())  

print("myInt1:", myInt1)
print("myInt2:", myInt2)
print("myInt3:", myInt3)

inputFile.close()


### DICTIONARIES ###

#We've defined a list of tuples below. Each tuple follows
#the format: (name, home state).
#
#Create a dictionary called ta_dict in the space below, where
#the keys are each TA's name, and the values are their home
#state.

ta_info = [("Joshua", "Georgia"),
          ("Jackie", "Vermont"),
          ("Marguerite", "Tennessee")]

#Add your code to create the dictionary as described!
#The first item in each tuple should be a key, and
#the second item in each tuple should be its value.
#Note that you may create this either by reading and
#using the ta_info list of tuples, or you can create
#the dictionary from scratch:


#Create your dictionary here!
ta_dict = {"Joshua":"Georgia", "Jackie":"Vermont", "Marguerite":"Tennessee"}


#Now, create three variables: josh_val, jack_val, and
#marg_val. Set josh_val equal to Josh's dictionary value,
#then jack_val equal to Jackie's, then marg_val equal to
#Marguerite's. Remember how to properly access the value
#corresponding to a dictionary key!
#
#Make sure you use dictionary-access syntax to do this.
#Don't create the variables based on new values.

#Create your variables here!
josh_val = ta_dict["Joshua"]
jack_val = ta_dict["Jackie"]
marg_val = ta_dict["Marguerite"]

#If your code works as intended, the following three lines
#will run and print Georgia, Vermont, and Tennessee:
print(josh_val)
print(jack_val)
print(marg_val)

###

#Creates myDictionary with sprockets=5, widgets=11, cogs=3, and gizmos=15
myDictionary = {"sprockets" : 5, "widgets" : 11, "cogs" : 3, "gizmos": 15}
print(myDictionary)
myDictionary["sprockets"] += 1
print(myDictionary)

###

#Creates myDictionary with sprockets=5, widgets=11, cogs=3, and gizmos=15
myDictionary = {"sprockets" : 5, "widgets" : 11, "cogs" : 3, "gizmos": 15}
print(myDictionary)
myDictionary["sprockets"] += 1
print(myDictionary)

###

#Create a function called tup_to_dict. tup_to_dict should take one
#parameter: a list of tuples. You can assume each tuple in
#the list has exactly two values.
#
#The function should return a dictionary where the first item
#in each tuple is the key, and the second item in each tuple
#is the corresponding value.
#
#For example:
# colors = [("turquoise", "#40E0D0"), ("red", "#990000")]
# tup_to_dict(colors) -> {"turquoise":"#40E0D0", "red":"#990000"}
#
#Hint: the previous exercise is very similar; this just turns
#it into a function! All our tuples will be color name-color
#value pairs.


#Write your function here!
def tup_to_dict(tuple_list):
    dictionary = {}
    for list in tuple_list:
        dictionary[list[0]] = list[1]
    return dictionary


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:  {'Turquoise':'#40E0D0', 'Red':'#990000'}
#
#Don't worry if it prints those in the reverse order; that's
#still correct!
print(tup_to_dict([("Turquoise", "#40E0D0"), ("Red", "#990000")]))

###

#Creates myDictionary with sprockets=5, widgets=11, cogs=3, and gizmos=15
myDictionary = {"sprockets" : 5, "widgets" : 11,
                "cogs" : 3, "gizmos": 15}
print(myDictionary)

#Creates the new key "gadgets" with value 1
myDictionary["gadgets"] = 1   
print(myDictionary)
del myDictionary["gadgets"]
print(myDictionary)

###

#Creates myDictionary with David=4045551234, Lucy=4045555678, 
#Vrushali=4045559101
myDictionary = {"David" : "4045551234", "Lucy" : "4045555678",
                "Vrushali" : "4045559101"}
print(myDictionary)

#Checks if "David" is a key in the dictionary
if "David" in myDictionary: 
    print("David is already in myDictionary!")
    myDictionary["David2"] = "4045551121"
else:  
    myDictionary["David"] = "4045551121"
print(myDictionary)

###

#Creates myDictionary with #David=4045551234, Lucy=4045555678, #Vrushali=4045559101
myDictionary = {"David" : "4045551234", "Lucy" : "4045555678",
                "Vrushali" : "4045559101"}
print(myDictionary["Dana"])

###

#Write a function called students_present. students_present
#should take as input one parameter, a dictionary. The keys
#of the dictionary will be names, and the values will be one
#of three strings: "Here", "Present", or an empty string "".
#
#Return a list of the keys for whom the corresponding value
#is either "Here" or "Present".


#Add your code here!
def students_present(dictionary):
    students_present = []
    for (student, status) in dictionary.items():
        if status == "Here" or status == "Present":
            students_present.append(student)
    return students_present


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#["David", "Marguerite", "Joshua", "Erica"]

student_list = {"David" : "Here", "Marguerite" : "Here",
                "Jackie": "", "Joshua": "Present",
                "Erica": "Here", "Daniel": ""}
print(students_present(student_list))

###

#Creates myDictionary with sprockets=5, widgets=11, cogs=3, gizmos=15, 
#gadgets=1
myDictionary = {"sprockets" : 5, "widgets" : 11, "cogs" : 3, "gizmos" : 15,
                "gadgets" : 1}
for value in myDictionary.values():
    if value < 5:
        print("A value less than 5 was found:", value)

###

#Creates myDictionary with sprockets=5, widgets=11, cogs=3, gizmos=15, 
#gadgets=1
myDictionary = {"sprockets" : 5, "widgets" : 11, "cogs" : 3, "gizmos" : 15, 
                "gadgets" : 1}
for key in myDictionary.keys():
    value = myDictionary[key]
    if value < 5:
        print(key, "is less than 5:", value)

###

#Creates myDictionary with sprockets=5,
#widgets=11, cogs=3, gizmos=15, gadgets=1
myDictionary = {"sprockets" : 5, "widgets" : 11,
                "cogs" : 3, "gizmos" : 15, "gadgets" : 1}
for (key, value) in myDictionary.items():
    if value < 5:
        print(key, "is less than 5:", value)

###

#Write a function called name_counts. name_counts will take
#as input a list of full names. Each name will be two words
#separated by a space, like "David Joyner".
#
#The function should return a dictionary. The keys to the
#dictionary will be the first names from the list, and the
#values should be the number of times that first name
#appeared.
#
#HINT: Use split() to split names into first and last.


#Add your function here!
def name_counts(name_list):
    dictionary = {}
    for name in name_list:
        first_name = name.split()[0]
        if first_name in dictionary:
            dictionary[first_name] += 1
        else:
            dictionary[first_name] = 1
    return dictionary
        
#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#{'Shelba': 5, 'Maren': 1, 'Nicol': 1, 'David': 2, 'Brenton': 2}
name_list = ["David Joyner", "David Zuber", "Brenton Joyner",
             "Brenton Zuber", "Nicol Barthel", "Shelba Barthel",
             "Shelba Crowley", "Shelba Fernald", "Shelba Odle",
             "Shelba Fry", "Maren Fry"]
print(name_counts(name_list))

###

myString = "This is the string whose words we would like to count. This string contains some repeated words, as well as some unique words. It contains punctuation, and it contains words that are capitalized in different ways. If the method we write runs correctly, it will count 4 instances of the word 'it', 3 instances of the word 'this', and 3 instances of the word 'count'."

myString = myString.replace(".","") #Remove periods
myString = myString.replace(",","") #Remove commas
myString = myString.replace("'","") #Remove apostrophes
myString = myString.lower() #Make all lower case
mySplitString = myString.split() #Split by spaces

wordDictionary = {} #Create empty dictionary
for word in mySplitString:  #For each word in the split string
    if word in wordDictionary:  #If it's already been found...
        wordDictionary[word] += 1   #Add one to its count
    else:   #Otherwise...
        wordDictionary[word] = 1 #Create it with value 1

print(wordDictionary)

###

seatingChart = {"David" : 3, "Lucy" : 3, "Dana" : 2,
                "Addison" : 2, "Vrushali" : 1, "Bilbo" : 3,
                "Sara" : 1, "Lugos" : 1, "Mireia" : 1,
                "Partha" : 2, "Venijamin" : 1, "Terra" : 2, 
                "Tryphon" : 3, "Gevorg" : 1, "Raza" : 3,
                "Rein" : 3, "Sofia" : 2, "Perle" : 2}

#For each name, table pair in the seating chart
for (name, table) in seatingChart.items():  
    #Print the table for the name
    print(name, " is seated at table #", table, sep="")  

print()
#For each table number
for i in range(1, 4):   
    print("The guests at table #", i, " are: ", sep="", end="")
    #For each name, table pair
    for (name, table) in seatingChart.items():  
        #If the table numer is this number
        if i == table:  
            #Print the name
            print(name, end=" ")    
    print()

###

#Recall in the previous problem you counted the number of
#instances of a certain first name in a list of full names.
#You returned a dictionary with the name as the key, and the
#number of times it appeared as the value.
#
#Modify that code such that instead of having a count as the
#value, you instead have a list of the full names that had
#that first name. So, each key in the dictionary would still
#be a first name, but the values would be lists of names.
#Make sure to sort the list of names, too.
#
#Name this new function name_lists.


#Add your function here!
def name_lists(names):
    name_dict = {}
    for name in names:
        split_name = name.split()
        first_name = split_name[0]
        if not first_name in name_dict:
            name_dict[first_name] = []
        name_dict[first_name].append(name)
    for first_name, full_names in name_dict.items():
        full_names.sort()
    return name_dict


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#{'Shelba': ['Shelba Barthel', 'Shelba Crowley', 'Shelba Fernald', 'Shelba Fry', 'Shelba Odle'],
#'David': ['David Joyner', 'David Zuber'], 'Brenton': ['Brenton Joyner', 'Brenton Zuber'],
#'Maren': ['Maren Fry'], 'Nicol': ['Nicol Barthel']}

name_list = ["David Joyner", "David Zuber", "Brenton Joyner",
             "Brenton Zuber", "Nicol Barthel", "Shelba Barthel",
             "Shelba Crowley", "Shelba Fernald", "Shelba Odle",
             "Shelba Fry", "Maren Fry"]
print(name_lists(name_list))

###

classes = {"Math" : ["David", "Lucy", "Dana"],
           "Physics" : ["Addison", "Vrushali", "Bilbo"],
           "Chemistry" : ["Sara", "Lugos", "Mireia", "Perle"],
           "Computing" : ["Partha", "Venijamin", "Terra", "Sofia"],
           "History" : ["Tryphon", "Gevorg", "Raza", "Rein"]}

print("Students in Computing:", classes["Computing"])
#Add Francis to History
classes["History"].append("Francis")    
print("Students in History:", classes["History"])

###

addressBook = {"David": ("555 Home St", "4045551234", "david@david.com"),
               "Lucy" : ("555 Home St", "4045555678", "lucy@lucy.com"),
               "Dana" : ("123 There Rd", "4045559101", "dana@dana.net")}

print("David's Information:", addressBook["David"])
print("Dana's Phone Number:", addressBook["Dana"][1])

###

addressBook = {"David": {"address" : "555 Home St", "phone" : "4045551234", 
                          "email" : "david@david.com"},
               "Lucy" : {"address" : "555 Home St", "phone" : "4045555678", 
                         "email" : "lucy@lucy.com"},
               "Dana" : {"address" : "123 Here Rd", "phone" : "4045559101", 
                         "email" : "dana@dana.net"}}

print("David's Information:", addressBook["David"])
print("Dana's Phone Number:", addressBook["Dana"]["phone"])

###

ANSWER_KEY = {"1" : "A", "2" : "B", "3" : "C", "4" : "D", "5" : "A"}

students={}
students["David"] = {"1" : "A", "2" : "B", "3" : "A", "4" : "B", "5" : "C"}
students["Terra"] = {"1" : "A", "2" : "B", "3" : "C", "4" : "D", "5" : "A"}
students["Lugos"] = {"1" : "A", "2" : "C", "3" : "C", "4" : "D", "5" : "A"}

#For each student and their answers
for (student, answers) in students.items(): 
    grade = 0   #Start grade at 0
    #For each question and answer
    for (question, answer) in answers.items():  
        #If the answer matches ANSWER_KEY's answer...
        if answer == ANSWER_KEY[question]:  
            grade +=1   #Increment their grade
    #Create a new key "grade" and assign it their grade
    students[student]["grade"] = grade  
#For each student and their answers
for (student, answers) in students.items(): 
    #Print the name and grade
    print(student, ": ", answers["grade"], sep = "", end = "; ")


### PRACTICE PROBLEMS ###

#Write a function called count_characters. count_characters
#should take as input a single string, and return a
#dictionary. In the dictionary, the keys should be
#characters, and the values should be the number of times
#each character appeared in the string.
#
#For example:
#
#  count_characters("aabbccc") -> {'a': 2, 'b': 2, 'c': 3}
#  count_characters("AaBbbb") -> {'A': 1, 'B': 1, 'a': 1, 'b': 3}
#
#You should not need to make any assumptions about the
#characters in the string: spaces, punctuation, line breaks,
#and any other characters should be handled automatically.
#You may count upper and lower case separately.


#Write your function here!
def count_characters(string):
    dictionary = {}
    for letter in string:
        if letter in dictionary:
            dictionary[letter] += 1
        else:
            dictionary[letter] = 1
    return dictionary


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#
#{'a': 2, 'b': 2, 'c': 3}
print(count_characters("aabbccc"))


### PROBLEM SET 1 ###

## Practice problem 1

#Write a function called count_types. count_types
#should take as input a single string, and return a
#dictionary. In the dictionary, the keys should be
#types of characters, and the values should be the
#number of times each type of character appeared in
#the string.
#
#The types of characters that should be handled (and
#thus, the keys in the dictionary) are:
#
# - upper: the count of upper-case or capital letters
# - lower: the count of lower-case letters
# - punctuation: the count of punctuation characters.
#   You may assume this is limited to these punctuation
#   characters: !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
# - space: the count of spaces
# - numeral: the count of numerals, 0123456789
#
#Note, however, that any type of character that does
#NOT appear in the string should not be in the dictionary
#at all.
#
#For example:
#
#count_characters("aabbccc") -> 
# {"lower": 7}
#count_characters("ABC 123 doe ray me!") -> 
# {"upper": 3, "lower": 8, "punctuation": 1, "space": 4, "numeral": 3}
#
#Because the first string has only lower-case letters,
#"lower" is the only key in the dictionary.
#
#HINT: If you're sing the ord() function, capitals of
#ordinals between 65 and 90; lower-case letters have
#ordinals between 97 and 122; numerals are between 48
#and 57; spaces are 32; all other numbers between 33
#and 126 are punctuations, and no character will have
#an ordinal outside that range.


#Write your function here!
def count_types(string):
    dictionary = {}
    upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    lower = "abcdefghijklmnopqrstuvwxyz"
    punctuation = '''!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~'''
    space = " "
    numeral = "0123456789"
    for char in string:
        if char in upper:
            dictionary["upper"] = dictionary.get("upper", 0) + 1
        elif char in lower:
            dictionary["lower"] = dictionary.get("lower", 0) + 1
        elif char in punctuation:
            dictionary["punctuation"] = dictionary.get("punctuation", 0) + 1
        elif char in space:
            dictionary["space"] = dictionary.get("space", 0) + 1
        elif char in numeral:
            dictionary["numeral"] = dictionary.get("numeral", 0) + 1
    return dictionary    

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#
#{"lower": 7}
#{"upper": 3, "lower": 8, "punctuation": 1, "space": 4, "numeral": 3}
print(count_types("aabbccc"))
print(count_types("ABC 123 doe ray me!"))


## Practice problem 2

#Write a function called write_movie_info. write_movie_info
#will take as input two parameters: a string and a
#dictionary.
#
#The string will represent the filename to which to write.
#
#The keys in the dictionary will be strings representing
#movie titles. The values in the dictionary will be lists
#of strings representing performers in the corresponding
#movie.
#
#write_movie_info should write the list of movies to the file
#given by the filename using the following format:
#
# Title: Actor 1, Actor 2, Actor 3, etc.
#
#The movies and the actor names should be sorted
#alphabetically.
#
#So, for this dictionary:
#
# {"Chocolat": ["Juliette Binoche", "Judi Dench", "Johnny Depp", "Alfred Molina"],
#  "Skyfall": ["Judi Dench", "Daniel Craig", "Javier Bardem", "Naomie Harris"]}
#
#The file printed would look like this:
#
# Chocolat: Alfred Molina, Johnny Depp, Judi Dench, Juliette Binoche
# Skyfall: Daniel Craig, Javier Bardem, Judi Dench, Naomie Harris
#
#HINT: the keys() method of a Dictionary will return a list
#of the dictionary's keys. So, to get a sorted list of a_dict's
#keys, you could call key_list = a_dict.keys(), then call 
#key_list.sort().


#Write your function here!
def write_movie_info(filename, dictionary):
    file = open(filename, "w")
    for movie in sorted (dictionary):
        file.write(movie + ": ")
        dictionary[movie].sort()
        for actor in range(0, len(dictionary[movie]) - 1):
            file.write(dictionary[movie][actor] + ", ")
        file.write(dictionary[movie][len(dictionary[movie]) - 1] + "\n")
    file.close()
    return        
        

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print nothing -- however, it should write the same contents
#as Sample.txt to Test.txt.
movies = {"Chocolat": ["Juliette Binoche", "Judi Dench", "Johnny Depp", "Alfred Molina"], "Skyfall": ["Judi Dench", "Daniel Craig", "Javier Bardem", "Naomie Harris"]}
write_movie_info("Test.txt", movies)


## Practice problem 3

#Imagine you're writing the code for an onboard vehicle
#monitoring system. One thing the system does is measure
#tire pressure. It does this by taking a measurement every
#10 seconds. However, lots of environmental conditions can
#lead to intermittent bad readings: if it takes a reading
#as a car goes over a bump, for example, it will be way
#higher than it would have been otherwise. So, the system
#needs to know to ignore these ratings, as well as only
#process the more recent measurements. Let's tell the system
#that the only valid tire pressures are between 15 and 55.
#
#Write a function called tire_pressure. tire_pressure
#should have one parameter, a list of integers. The list
#represents a series of tire pressure measurements over the
#past several minutes.
#
#tire_pressure should return the average of the last 5
#measurements that are greater than or equal to 15 and less
#than or equal to 55. Round the result to 1 decimal place
#(you can use round(some_float, 1) to round to 1 decimal
#place).
#
#For example, if the list of measurements was this:
#
# [34, 34, 64, 34, 5, 5, 34, 34, 35, 35, 35, 65, 60, 35, 12, 35]
#
#tire_pressure would return 35.0: the last five measurements
#in range are all 35. You may assume there will be at least
#5 measurements in the proper range.


#Add your code here!
def tire_pressure(a_list):
    last_five = []
    count = 0
    a_list.reverse()
    for measurement in a_list:
        if measurement >= 15 and measurement <= 55:
            last_five.append(measurement)
            count += 1
            if count == 5:
                break
    return (sum(last_five) / 5)          


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 35.0
a_list = [45, 44, 8, 43, 43, 43, 41, 41]
print(tire_pressure(a_list))


## Practice problem 4

#Write a function called find_median. find_median
#should take as input a string representing a filename.
#The file corresponding to that filename will be a list
#of integers, one integer per line. find_median should
#return the median of the numbers in the file.
#
#If there is an odd number of values in the file, then
#find_median will return the middle value from the numbers
#in the file after they're sorted.
#
#If there is an even number of values in the file, then
#find_median should return the average of the two middle
#values after they're sorted.
#
#For example, in the dropdown in the top left you'll find a
#file named FindMedianInput.txt. There are 19 numbers in
#this file, so the median is the value at index 10 after
#sorting them: 16.
#
#You may assume that all lines in the file will contain a
#positive integer (greater than 0). There may be duplicates.


#Write your function here!
def find_median(filename):
    file = open(filename, "r")
    numbers = []
    for line in file:
        numbers.append(int(line.strip()))
    numbers.sort()
    if len(numbers) % 2 == 1:
        median_index = len(numbers) // 2
        median = numbers[median_index]
    else:
        median_index_1 = len(numbers) // 2 - 1
        median_index_2 = len(numbers) // 2
        median = (numbers[median_index_1] + numbers[median_index_2]) / 2
    return median


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 16
print(find_median("FindMedianInput.txt"))


## Practice problem 5

#Write a function called next_fib. next_fib should take
#have two parameters: a list of integers and a single integer.
#For this description, we'll call the single integer n.
#
#next_fib should modify the list to add the next n pseudo-
#Fibonacci numbers to the end of the sequence. A pseudo-
#Fibonacci number is the sum of the previous two numbers in
#the sequence, but in our case, the previous two numbers may
#not be the original numbers from the Fibonacci sequence.
#
#For example, if the original list given was:
#
# a_list = [5, 5, 10, 15, 25, 40, 65]
#
# Then next_fib(a_list, 3) would return:
#       [5, 5, 10, 15, 25, 40, 65, 105, 170, 275]
#
#All the original numbers in the list are still there, and
#three new ones have been added.
#
#You may assume the list parameter will always have at least
#two numbers.
#
#HINT: Python gets mad if you try to change a list while
#iterating over it with a for-each loop. You'll have to get
#clever with a for or while loop to do this!


#Add your code here!
def next_fib(a_list, n):
    count = 0
    while count < n:
        a_list.append(sum(a_list[-2:]))
        count += 1
    return a_list


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#[5, 5, 10, 15, 25, 40, 65, 105, 170, 275] 
a_list = [5, 5, 10, 15, 25, 40, 65]
print(next_fib(a_list, 3))


## Practice problem 6

#Write a function called abstract_names. abstract_names
#should have one parameter: a list of lists. Each list will
#be a list of strings, each with a first name and a last
#name, and each with the same first name.
#
#For example, this could be one list of lists your function
#might receive:
#
# [["David Joyner", "David Tennant", "David Beckham"],
#  ["Ananya Birla", "Ananya Agarwal", "Ananya Chatterjee", "Ananya Roy"],
#  ["Inés Sainz", "Inés Suarez", "Inés Melchor"]]
#
#abstract_names should return a dictionary. The keys to the
#dictionary should be the first names, and the values should
#be lists of the associated last names. The last names should
#be sorted alphabetically.
#
#For example, with the list above, the dictionary returned by
#abstract_names would be:
#
# {"David": ["Beckham", "Joyner", "Tennant"],
#  "Ananya": ["Agarwal", "Birla", "Chatterjee", "Roy"],
#  "Inés": ["Melchor", "Sainz", "Suarez"]}


#Write your function here!
def abstract_names(list_of_lists):
    dictionary = {}    
    for list in list_of_lists:
        first_name = list[0].split()[0]
        last_names = [name.split()[1] for name in list]
        dictionary[first_name] = sorted(last_names)
    return dictionary

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#
#{"David": ["Beckham", "Joyner", "Tennant"], "Ananya": ["Agarwal", "Birla", "Chatterjee", "Roy"], "Inés": ["Melchor", "Sainz", "Suarez"]}
names = [["David Joyner", "David Tennant", "David Beckham"], ["Ananya Birla", "Ananya Agarwal", "Ananya Chatterjee", "Ananya Roy"], ["Ines Sainz", "Ines Suarez", "Ines Melchor"]]
print(abstract_names(names))


## Practice problem 7 

#Vancouver citation style cites author names like this:
#
#  Last F, Joyner D, Burdell G
#
#Note the following:
#
# - Each individual name is listed as the last name, then a
#   space, then the first initial. No periods or commas within
#   each name.
# - The names are separated by commas, including the last
#   two.
# - There is no space or comma following the last period.
#
#Write a function called names_to_vancouver. names_to_vancouver
#should take as input a list of strings, and return a single
#string according to the style given above. You can assume
#that each item of the list will be a first and last name:
#no middle initials. For example:
#
#  names_to_vancouver(["First Last", "David Joyner", "George Burdell"])
#
#...would return "Last F, Joyner D, Burdell G".


#Write your function below!
def names_to_vancouver(name_list):
    new_string = ""
    for name in name_list:
        first_name = name.split()[0]
        first_name_initial = first_name[0]
        last_name = name.split()[1]
        new_string += last_name + " " + first_name_initial + ", "
    return new_string[:-2]


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: Last F, Joyner D, Burdell G
print(names_to_vancouver(["First Last", "David Joyner", "George Burdell"]))


## Practice problem 8

#The game Mancala is one of the oldest games in recorded
#history. You can read more about it here:
#https://www.thesprucecrafts.com/how-to-play-mancala-409424
#
#For this problem, though, you don't need to know how to
#play the game. All you need to know is the board layout
#and the conditions for winning.
#
#A Mancala board is made of two rows of 6 cups, with two
#bigger cups at the ends. Each cup holds some number of
#stones or chips. For our purposes, though, we'll include
#the bigger cups at the end of the corresponding rows.
#
#So, for us, a Mancala board is represented as a
#2-dimensional list of integers. Each item in the lists
#represents a cup, and the number represents how many
#stones are currently in that cup. For example, this
#could be one board:
#
# [[5, 3, 0, 2, 6, 8, 1],
#  [1, 6, 8, 0, 4, 1, 4]]
#
#With this board representation, the game is over when
#every cup is empty except the top left and the bottom
#right. When the game is over, whoever has more stones
#in their cup wins: if the top left has more stones, the
#top player wins. If the bottom right has more stones,
#the bottom player wins.
#
#Write a function called check_winner. check_winner takes
#as a 2-dimensional list representing a game board. You
#may assume list will always have two lists, each with
#7 items, corresponding to the board structure shown
#above.
#
#Your function should return one of four strings
#depending on the values of the list:
#
# - If the game is not over (that is, there are stones
#   in any bucket except for the top-left or bottom-
#   right), return "Keep playing!"
# - If the game is over and the top player wins (that is,
#   there are more stones in top-left than bottom-right),
#   return "Player 1 wins!"
# - If the game is over and the bottom player wins (that
#   is, there are more stones in the bottom-right than
#   the top-left), return "Player 2 wins!"
# - If the game is over but the score is tied (that is,
#   there is an equal number of stones in the top-left
#   and bottom-right), return "Draw!"


#Write your function here!
def check_winner(board):
    if board[0][1] > 0 or board[0][2] > 0 or board[0][3] > 0 or board[0][4] > 0 or board[0][5] > 0 or board[0][6] > 0 or board[1][0] > 0 or board[1][1] > 0 or board[1][2] > 0 or board[1][3] > 0 or board[1][4] > 0 or board[1][5] > 0:
        return "Keep playing!"
    if board[0][1] == 0 and board[0][2] == 0 and board[0][3] == 0 and board[0][4] == 0 and board[0][5] == 0 and board[0][6] == 0 and board[1][0] == 0 and board[1][1] == 0 and board[1][2] == 0 and board[1][3] == 0 and board[1][4] == 0 and board[1][5] == 0 and board[0][0] > board[1][6]:
        return "Player 1 wins!"
    if board[0][1] == 0 and board[0][2] == 0 and board[0][3] == 0 and board[0][4] == 0 and board[0][5] == 0 and board[0][6] == 0 and board[1][0] == 0 and board[1][1] == 0 and board[1][2] == 0 and board[1][3] == 0 and board[1][4] == 0 and board[1][5] == 0 and board[0][0] < board[1][6]:
        return "Player 2 wins!"
    if board[0][1] == 0 and board[0][2] == 0 and board[0][3] == 0 and board[0][4] == 0 and board[0][5] == 0 and board[0][6] == 0 and board[1][0] == 0 and board[1][1] == 0 and board[1][2] == 0 and board[1][3] == 0 and board[1][4] == 0 and board[1][5] == 0 and board[0][0] == board[1][6]:
        return "Draw!"


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#Keep playing!
#Player 1 wins!
#Player 2 wins!
#Draw!
keep_playing = [[5, 3, 0, 2, 6, 8, 1], [1, 6, 8, 0, 4, 1, 4]]
player1_wins = [[27, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 21]]
player2_wins = [[16, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 32]]
game_is_tied = [[24, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 24]]
print(check_winner(keep_playing))
print(check_winner(player1_wins))
print(check_winner(player2_wins))
print(check_winner(game_is_tied))


### PROBLEM SET 2 ###

## Practice problem 1

#Write a function called count_types. count_types
#should take as input a single string, and return a
#dictionary. In the dictionary, the keys should be
#types of characters, and the values should be the
#number of times each type of character appeared in
#the string.
#
#The types of characters that should be handled (and
#thus, the keys in the dictionary) are:
#
# - upper: the count of upper-case or capital letters
# - lower: the count of lower-case letters
# - punctuation: the count of punctuation characters.
#   You may assume this is limited to these punctuation
#   characters: !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
# - space: the count of spaces
# - numeral: the count of numerals, 0123456789
#
#All five keys should be in your dictionary no matter
#what; if there are no characters of the corresponding
#type, the value associated with the key would just be 0.
#
#For example:
#
#count_characters("aabbccc") -> 
# {"upper": 0, "lower": 7, "punctuation": 0, "space": 0, "numeral": 0}
#count_characters("ABC 123 doe ray me!") -> 
# {"upper": 3, "lower": 8, "punctuation": 1, "space": 4, "numeral": 3}
#
#HINT: If you're sing the ord() function, capitals of
#ordinals between 65 and 90; lower-case letters have
#ordinals between 97 and 122; numerals are between 48
#and 57; spaces are 32; all other numbers between 33
#and 126 are punctuations, and no character will have
#an ordinal outside that range.


#Write your function here!
def count_types(string):
    dictionary = {"upper": 0, "lower": 0, "punctuation": 0, "space": 0, "numeral": 0}
    upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    lower = "abcdefghijklmnopqrstuvwxyz"
    punctuation = '''!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~'''
    space = " "
    numeral = "0123456789"
    for char in string:
        if char in upper:
            dictionary["upper"] = dictionary.get("upper", 0) + 1
        elif char in lower:
            dictionary["lower"] = dictionary.get("lower", 0) + 1
        elif char in punctuation:
            dictionary["punctuation"] = dictionary.get("punctuation", 0) + 1
        elif char in space:
            dictionary["space"] = dictionary.get("space", 0) + 1
        elif char in numeral:
            dictionary["numeral"] = dictionary.get("numeral", 0) + 1
    return dictionary   

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#
#{"upper": 0, "lower": 7, "punctuation": 0, "spaces": 0, "numerals": 0}
#{"upper": 3, "lower": 8, "punctuation": 1, "spaces": 4, "numerals": 3}
print(count_types("aabbccc"))
print(count_types("ABC 123 doe ray me!"))


## Practice problem 2

#Write a function called write_streaming_info.
#write_streaming_info will take as input two parameters: a
#string and a list.
#
#The string will represent the filename to which to write.
#
#Each item in the list will be a tuple. The first item of
#every tuple will be the name of a movie. All remaining items
#in the tuple will be streaming services on which the movie
#appears, such as Hulu, Netflix, Peacock, HBO Max, Amazon,
#Disney+, Peacock, YouTube, Crunchyroll, CBS All Access, etc.
#
#write_streaming_info should write the list of movies to the
#file given by the filename using the following format:
#
# [movie]: Available on Service_1, Service_2, and Service_3
#
#The movies and the streaming service names should appear in
#the order of the original list/tuples.
#
#So, for this list of tuples:
#
# [("Chocolat", "Hulu", "Netflix", "Amazon"),
#  ("Skyfall", "HBO Max", "Amazon"),
#  ("Soul", "Disney+")]
#
#The file printed would look like this:
#
# Chocolat: Available on Hulu, Netflix, and Amazon
# Skyfall: Available on HBO Max and Amazon
# Soul: Disney+
#
#Note that if only one service is listed, just that service
#appears after the colon. If two services are listed, they
#appear separated by 'and' with no commas. If three or more
#services are listed, then there is a comma after every
#service except the last one, and the last one is preceded
#by 'and'.

#
#HINT: Remember, you can use slicing on tuples just like strings.
#a_tuple[:2], for example, will give you the first two items in a
#tuple. a_tuple[3:] will give you all the items from the one at
#index 3 to the end.


#Write your function here!
def write_streaming_info(filename, movies):
    file = open(filename, "w")
    for movie in movies:
        movie_name = movie[0]
        services = movie[1:]
        if len(services) == 1:
            file.write(movie_name + ": " + services[0] + "\n")
        elif len(services) == 2:
            file.write(movie_name + ": " + services[0] + " and " + services[1] + "\n")
        else:
            service_list = ", ".join(services[:-1])
            file.write(movie_name + ": " + service_list + ", and " + services[-1] + "\n")
    file.close()        


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print nothing -- however, it should write the same contents
#as Sample.txt to Test.txt.
movies = [("Chocolat", "Hulu", "Netflix", "Amazon"), ("Skyfall", "HBO Max", "Amazon"), ("Soul", "Disney+")]
write_streaming_info("Test.txt", movies)


## Practice problem 3

#Imagine you're writing the code for an intelligent 
#temperature device. The device takes a measurement every
#10 seconds. However, some readings may come up invalid.
#We can assume based on operating conditions that all
#valid temperatures will be between 20 and 80.
#
#Write a function called average_temp. average_temp
#should have one parameter, a list of integers. The list
#represents a series of temperature measurements over the
#past several minutes.
#
#average_temp should return the average of all the last
#five _valid_ (greater than or equal to 20, less than or
#equal to 80) measurements.  Round the result to 1
#decimal place (you can use round(some_float, 1) to round
#to 1 decimal place).
#
#For example, if the list of measurements was this:
#
# [5, 62, 72, 102, 68, 75, 73, 3, 7, 79]
#
#average_temp would return 73.4: the last 5 valid
#measurements are (in reverse order) 79, 73, 75, 68, and
#72. (79 + 73 + 75 + 68 + 72) / 5 = 73.4.
#
#If there are fewer than five valid readings, return the
#averages of however many valid readings there are.


#Add your code here!
def average_temp(measurements):
    last_five = []
    count = 0
    measurements.reverse()
    for measurement in measurements:
        if measurement >= 20 and measurement <= 80:
            last_five.append(measurement)
            count += 1
            if count == 5 or count == len(measurements):
                break
    average = (sum(last_five) / len(last_five))
    return round(average, 1)


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 73.4, then 67.0 (on their own lines)
a_list = [5, 62, 72, 102, 68, 75, 73, 3, 7, 79]
print(average_temp(a_list))

a_list_2 = [5, 62, 72, 102]
print(average_temp(a_list_2))


## Practice problem 4

#Write a function called find_range. find_range should take
#as input a string representing a filename. The file
#corresponding to that filename will be a list of integers,
#one integer per line. find_range should return a tuple
#containing the smallest and largest numbers in the file
#(the smallest first, then the largest).
#
#For example, in the dropdown in the top left you'll find a
#file named FindRangeInput.txt. The smallest number in that
#file is 2, and the largest is 37. So, if you called
#find_range("FindRangeInput.txt"), the function would return
#(2, 37), a tuple with two integers.
#
#You may assume that all lines in the file will contain a
#positive integer (greater than 0). There may be duplicates.
#
#Hint: Remember, if you loop through all the lines in a file
#then you have to close and reopen the file to read it again,
#or by use file.seek(0) to start from the top. However, you
#can do this problem without having to read the file twice.


#Write your function here!
def find_range(filename):
    file = open(filename, "r")
    min_value = float("inf")
    max_value = float("-inf")
    
    for line in file:
        number = int(line.strip())
        if number < min_value:
            min_value = number
        if number > max_value:
            max_value = number
    return min_value, max_value

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: (2, 37)
print(find_range("FindRangeInput.txt"))


## Practice problem 5

#Write a function called sphere_data. volume_and_area will
#take in a dictionary. This dictionary is guaranteed to
#have exactly one key: "radius", whose value is an integer
#representing the radius of a sphere.
#
#Modify this dictionary to add two keys: "volume" and "area".
#The values associated with these keys should be the volume
#and surface area of the sphere.
#
#The formula for volume is:
#  (4/3) * pi * radius ^ 3
#
#The formula for surface area is:
#  4 * pi * radius ^ 2
#
#Both volume and surface area should be rounded to two
#decimal places. You can do this with round(val, 2).
#
#The line below will let you use pi as a variable in your
#code, with a value of pi to the 15th decimal place.
from math import pi

#Add your code here!
def sphere_data(sphere):
    radius = sphere["radius"]
    sphere["volume"] = round(((4/3) * pi * radius ** 3), 2)
    sphere["area"] = round((4 * pi * radius ** 2), 2)
    return sphere


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print 4.19 and 12.57, each on a different line.
sphere = {"radius": 1}
sphere = {"radius": 1}
sphere = sphere_data(sphere)
print(sphere["volume"])
print(sphere["area"])


## Practice problem 6

#Write a function called pivot_library. pivot_library takes
#as input one parameter, a list of 3-tuples. Each tuple in
#the list has three items: the first item is a movie title
#(a string), the second item is the movie's release year (an
#integer), and the third item is the movie's total gross (an
#integer).
#
#pivot_library should return a dictionary. In the dictionary
#that it returns, the keys should be the movie names, and the
#values should be 2-item tuples. In each tuple, the first
#item should be the release year, and the second item should
#be the total gross.
#
#Hint: Unpack the tuple to variables first, then create the
#new dictionary item.
#
#For example:
#
# movies = [("Avatar", 2009, 760507625),
#           ("Black Panther", 2018, 699931862)]
# pivot_library(movies)
#   -> {"Avatar": (2009, 760507625),
#       "Black Panther": (2018, 699931862)}


#Write your function here!
def pivot_library(list_of_tuples):
    dictionary = {}
    for tuple in list_of_tuples:
        dictionary[tuple[0]] = (tuple[1], tuple[2])
    return dictionary


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#
#{"Avatar": (2009, 760507625), "Black Panther": (2018, 699931862)}
movies = [("Avatar", 2009, 760507625), ("Black Panther", 2018, 699931862)]
print(pivot_library(movies))


## Practice problem 7]

#APA citation style cites author names like this:
#
#  Last, F., Joyner, D., & Burdell, G.
#
#Note the following:
#
# - Each individual name is listed as the last name, then a
#   comma, then the first initial, then a period.
# - The names are separated by commas, including the last
#   two.
# - There is also an ampersand and additional space before
#   the final name.
# - There is no space or comma following the last period.
#
#Write a function called names_to_apa. names_to_apa should
#take as input one string, and return a reformatted string
#according to the style given above. You can assume that
#the input string will be of the following format:
#
#  First Last, David Joyner, and George Burdell
#
#You may assume the following:
#
# - There will be at least three names, with "and" before
#   the last name.
# - Each name will have exactly two words.
# - There will be commas between each pair of names.
# - The word 'and' will precede the last name.
# - The names will only be letters (no punctuation, special
#   characters, etc.), and first and last name will both be
#   capitalized.


#Write your function below!
def names_to_apa(names_string):
    names_list = names_string.replace("and ","").split(", ")
    last_name_initials = []
    last_name_in_list = []
    
    for name in names_list[:-1]:
        last_name_initials.append(name.split()[1] + ", " + name.split()[0][0] + ".,")
    for name in names_list[-1:]:
        last_name_in_list = ["& " + name.split()[1] + ", " + name.split()[0][0] + "."]
    apa_citation = " ".join(last_name_initials + last_name_in_list)
    
    return apa_citation

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: Last, F., Joyner, D., & Burdell, G.
print(names_to_apa("First Last, David Joyner, and George Burdell"))


## Practice problem 8

#In the game tic-tac-toe, two players take turns drawing
#Xs and Os on a 3x3 grid. If one player can place three of
#their symbols side-by-side in a row, column, or diagonal,
#they win the game.
#
#For example:
#
# X Wins:   X Wins:   X Wins:   No Winner:
# X|O|X     O|X|X     O|O|      X|O|O
# -+-+-     -+-+-     -+-+-     -+-+-
# O|O|X     X|O|      X|X|X     O|X|X
# -+-+-     -+-+-     -+-+-     -----
# O|X|X      | |O      | |      X|X|O
#
#Write a function called check_winner. check_winner will
#take one parameter as input, a 2D tuple (that is, a tuple
#of tuples). The 2D tuple represents the game board: each
#smaller tuple in the larger tuple is a row of the board,
#and each item in the smaller tuple is a spot on the
#board. There will always be three tuples in the larger
#tuple, and three items in each of the smaller tuples.
#
#Each item in the smaller tuple will always be one of three
#values: the string "X", the string "O", or the value None.
#
#check_winner should return one of three values: the string
#"X" if X has won the game; the string "O" if O has won the
#game; or the value None if there is no winner. None should
#NOT be the string "None"; it should be the value None,
#like the boolean values True and False.
#
#You may assume a player has won the game if and only if
#the board has three of their symbols in a row: you do not
#need to worry about whether the input is a valid game
#otherwise (e.g. a board of nine Xs still counts as X
#winning). You may assume that there will only be one
#winner per board.
#
#Hint: There are only eight possible places to win (three
#rows, three columns, two diagonals).


#Write your function here!
def check_winner(board):
    for row in board:
        if row == ("X", "X", "X"):
            return "X"
        elif row == ("O", "O", "O"):
            return "O"
    if (board[0][0] == "X" and board[1][0] == "X" and board[2][0] == "X") or (board[0][1] == "X" and board[1][1] == "X" and board[2][1] == "X") or (board[0][2] == "X" and board[1][2] == "X" and board[2][2] == "X") or (board[0][0] == "X" and board[1][1] == "X" and board[2][2] == "X") or (board[0][2] == "X" and board[1][1] == "X" and board[2][0] == "X"):
            return "X"
    if (board[0][0] == "O" and board[1][0] == "O" and board[2][0] == "O") or (board[0][1] == "O" and board[1][1] == "O" and board[2][1] == "O") or (board[0][2] == "O" and board[1][2] == "O" and board[2][2] == "O") or (board[0][0] == "O" and board[1][1] == "O" and board[2][2] == "O") or (board[0][2] == "O" and board[1][1] == "O" and board[2][0] == "O"):
            return "O"
    
#The code below shows how the tic-tac-toe tuples are
#created and tests your code with three games: one where
#X wins, one where O wins, and one where there is no winner.
#Remember, the line breaks in xwins and owins are optional:
#they're just to make the declarations more readable. They
#could be written the same as nowins.
xwins = (("X", "O", "X"),
         ("O", "O", "X"),
         ("O", "X", "X"))
owins = (("O", "X", "X"),
         ("X", "O", None),
         (None, None, "O"))
nowins = (("X", "O", "O"),("O", "X", "X"),("X", "X", "O"))
print(check_winner(xwins))
print(check_winner(owins))
print(check_winner(nowins))


### PROBLEM SET 3 ###

## Practice problem 1

#Write a function called word_count. word_count should take
#as input a list. You may assume every item in the list will
#be a string.
#
#word_count should return a dictionary, where the keys are the
#words and the values are the number of times each word appeared
#in the list. The keys should all be lower-case, and you should
#ignore case when counting words (for instance, "cat", "CAT",
#and "Cat" would all count towards the key "cat").
#
#For example:
#
#  word_count(["cat", "CAT", "dog", "DOG"]) -> {"cat": 2, "dog": 2}
#  word_count(["Georgian", "Tech", "Georgia", "Tech"]) ->
#             {"Georgian": 1, "Tech": 2, "Georgia": 1}


#Write your function here!
def word_count(list):
    dictionary = {}
    for word in list:
        word_lower = word.lower()
        if word_lower in dictionary:
            dictionary[word_lower] += 1
        else:
            dictionary[word_lower] = 1
    return dictionary


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#
#{"cat": 2, "dog": 2}
#{"Georgian": 1, "Tech": 2, "Georgia": 1}
print(word_count(["cat", "CAT", "dog", "DOG"]))
print(word_count(["Georgian", "Tech", "Georgia", "Tech"]))


## Practice problem 2

#Write a function called write_teams. write_teams will take
#as input two parameters: a string and a list of 4-tuples.
#
#The string will represent the filename to which to write.
#
#Each 4-tuple in the list will contain four strings. The
#strings will represent (in order) a university name, their
#team mascot, their city, and their state.
#
#write_teams should write the list of teams to the file given
#by the filename using the following format:
#
# [university] [mascot], [city], [state]
#
#Note there is no comma between university and mascot, but
#there is a comma between mascot and city, and city and state.
#
#So, for this list:
#
# [("Georgia Tech", "Yellow Jackets", "Atlanta", "Georgia"),
#  ("Georgia State", "Panthers", "Atlanta", "Georgia")]
#
#The file printed would look like this:
#
#Georgia Tech Yellow Jackets, Atlanta, Georgia
#Georgia State Panthers, Atlanta, Georgia
#
#We've included Sample.txt to show you what one of these
#files should look like.


#Write your function here!
def write_teams(filename, universities):
    file = open(filename, "w")
    for university in universities:
        university_name = university[0]
        mascot = university[1]
        city = university[2]
        state = university[3]
        file.write(university_name + " " + mascot + ", " + city + ", " + state + "\n")
    file.close()


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print nothing -- however, it should write the same contents
#as Sample.txt to Test.txt.
teams = [("Georgia Tech", "Yellow Jackets", "Atlanta", "Georgia"), ("Georgia State", "Panthers", "Atlanta", "Georgia"),
        ("Kennesaw State", "Owls", "Kennesaw", "Georgia"), ("Georgia Southern", "Eagles", "Statesboro", "Georgia")]
write_teams("Test.txt", teams)


## Practice problem 3

#Write a function called average_evens_and_odds. The function
#should take as input one parameter, a list of integers. The
#function should return a 2-tuple. The first item in the
#2-tuple should be the average of all even numbers in the list;
#the second item in the 2-tuple should be the average of all
#odd numbers in the list. Round your averages to one decimal
#place.
#
#The list may have some strings interspersed in it. These should
#not affect your calculation.
#
#For example, if this was the input list:
#
# [1, 2, 3, 4, "cat", "tech", 5, 6]
#
#Your function would return the tuple: (4.0, 3.0) because 4.0
#is the average of the three even numbers (2, 4, 6) and 3.0 is
#the average of the three odd numbers (1, 3, 5).
#
#HINT: round(the_num, 1) will return the result of rounding
#the_num to one decimal place.


#Add your code here!
def average_evens_and_odds(a_list):
    odd_integers = []
    even_integers = [] 
    for item in a_list:
        if type(item) == int and item % 2 == 1:
            odd_integers.append(item)
        elif type(item) == int and item % 2 == 0:
            even_integers.append(item)
    odd_average = round((sum(odd_integers) / len(odd_integers)), 1)
    even_average = round((sum(even_integers) / len(even_integers)), 1)
    my_tuple = (even_average, odd_average)
    return my_tuple
    

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: (4.0, 3.0)
a_list = [1, 2, 3, 4, "cat", "tech", 5, 6]
print(average_evens_and_odds(a_list))


## Practice problem 4

#Write a function called pull_records. first_to_last should
#have two parameters: a string representing a filename, and a
#list of integers. Inside the file, there will be some text on
#each line.
#
#pull_records should return as a list the text on each line of
#the file represented in the list of integers. For example, if
#the list of integers was [0, 4, 8], then pull_records should
#return the text from lines 0, 4, and 8 as a list. The order of
#the lines in the list must match the order of the integers.
#
#In the dropdown in the top left, you can see the contents of
#a file called Some_Records.txt. You'll use this file to test
#your code below. Remember though, we consider the first line
#of the file to be line 0, not line 1.
#
#HINT: Don't forget that if you read the file using methods
#like readlines() or read(), the linebreaks are included. If
#you results seem weirdly split between multiple lines, it
#means you're not removing these line breaks with something
#like the strip() method!


#Write your function here!
def pull_records(filename, integers):
    file = open(filename, "r")
    words = []
    my_list = []
    for line in file:
        words.append(line.strip())
    for integer in integers:
        my_list.append(str(words[integer]))
    return my_list


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: ["need", "delicious", "pies"]
print(pull_records("Some_Records.txt", [0, 4, 8]))


## Practice problem 5

#Write a function called all_sum. all_sum should have two
#parameters: a list of integers and a single integer.
#For this description, we'll call the single integer n.
#
#all_sum should modify the list to add the next n all-sum
#numbers to the end of the sequence. An all-sum number is the
#sum of all previous numbers in the sequence.
#
#For example, if the original list given was:
#
# a_list = [1, 2, 3]
#
# Then all_sum(a_list, 3) would return:
#       [1, 2, 3, 6, 12, 24]
#
#All three original numbers in the list are still there, and
#three new ones have been added: the sum of the first three
#numbers (1+2+3 = 6), of the first four (1+2+3+6 = 12), and
#of the first five (1+2+3+6+12 = 24).
#
#You may assume the list parameter will always have at least
#one number.
#
#HINT: Python gets mad if you try to change a list while
#iterating over it with a for-each loop. You'll have to get
#clever with a for or while loop to do this!


#Add your code here!
def all_sum(list_integers, n):
    count = 0
    while count < n:
        list_integers.append(sum(list_integers[:]))
        count += 1
    return list_integers

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#[1, 2, 3, 6, 12, 24] 
print(all_sum([1, 2, 3], 3))


## Practice problem 5

#Write a function called all_sum. all_sum should have two
#parameters: a list of integers and a single integer.
#For this description, we'll call the single integer n.
#
#all_sum should modify the list to add the next n all-sum
#numbers to the end of the sequence. An all-sum number is the
#sum of all previous numbers in the sequence.
#
#For example, if the original list given was:
#
# a_list = [1, 2, 3]
#
# Then all_sum(a_list, 3) would return:
#       [1, 2, 3, 6, 12, 24]
#
#All three original numbers in the list are still there, and
#three new ones have been added: the sum of the first three
#numbers (1+2+3 = 6), of the first four (1+2+3+6 = 12), and
#of the first five (1+2+3+6+12 = 24).
#
#You may assume the list parameter will always have at least
#one number.
#
#HINT: Python gets mad if you try to change a list while
#iterating over it with a for-each loop. You'll have to get
#clever with a for or while loop to do this!


#Add your code here!
def all_sum(list_integers, n):
    count = 0
    while count < n:
        list_integers.append(sum(list_integers[:]))
        count += 1
    return list_integers

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#[1, 2, 3, 6, 12, 24] 
print(all_sum([1, 2, 3], 3))


## Practice problem 6

#Write a function called concrete_names. concrete_names takes
#as input one parameter, a dictionary. Each key in the
#dictionary will be a string corresponding to a first name.
#Each value in the dictionary will be a list of last names.
#
#concrete_names should return a list of lists. Each list
#should be an alphabetically-sorted list of names constructed
#by putting each first name together with each of its last
#names. The lists themselves should also be in alphabetical
#order by what first name is shared by all names in the list.
#
#For example, this could be one of the dictionaries your
#function receives:
#
# {"David": ["Beckham", "Tennant", "Joyner"],
#  "Ananya": ["Agarwal", "Chatterjee", "Birla", "Roy"],
#  "Ines": ["Sainz", "Melchor", "Suarez"]}
#
#Your function would then return:
#
# [["Ananya Agarwal", "Ananya Birla", "Ananya Chatterjee", "Ananya Roy"],
#  ["David Beckham", "David Joyner", "David Tennant"],
#  ["Ines Melchor", "Ines Sainz", "Ines Suarez"]]
#
#HINT: To get a list of the keys of a dictionary in alphabetical
#order, use this code:
#
# the_keys = list(a_dict.keys())
# the_keys.sort()


#Write your function here!
def concrete_names(dictionary):
    sorted_keys = sorted(dictionary.keys())
    list_of_lists = []
    for key in sorted_keys:
        last_names = sorted(dictionary[key])
        full_names = [key + " " + last_name for last_name in last_names]
        list_of_lists.append(full_names)
    return list_of_lists


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#
#[["Ananya Agarwal", "Ananya Birla", "Ananya Chatterjee", "Ananya Roy"], ["David Beckham", "David Joyner", "David Tennant"], ["Inés Melchor", "Inés Sainz", "Inés Suarez"]]
print(concrete_names({"David": ["Beckham", "Tennant", "Joyner"], "Ananya": ["Agarwal", "Chatterjee", "Birla", "Roy"], "Ines": ["Sainz", "Melchor", "Suarez"]}))


## Practice problem 7

#It's a well-known and indisputable fact that if you want
#to make your name sound fancy, you should list it as only
#the initials of your first and middle name followed by your
#last name. For example, my full name is David Andrew Joyner,
#and therefore my fancy name is D. A. Joyner. But what if you
#have more than one middle name? You initialize those too!
#John Ronald Reuel Tolkien becomes J. R. R. Tolkien. Isla
#Lang Fisher becomes I. L. Fisher; Sasha Baron Cohen becomes
#S. B. Cohen; and their son Montgomery Moses Brian Baron Cohen
#becomes M. M. B. B. Cohen.
#
#Write a function called my_fancy_name. my_fancy_name should
#take as input a single string, comprised of multiple names.
#It should return the "fancy" name: the first initials of the
#first several names followed by a period and space, followed
#by the final last name. It should preserve case; if someone
#has a middle name starting with a lower-case letter, then
#it should be lower-case in their fancy name.


#Write your function below!
def my_fancy_name(string):
    first_initials = ""
    last_name = string[-1:]
    names_list = string.split(" ")
    for name in names_list[:-1]:
        first_initials += name[0] + ". "
    for name in names_list[-1:]:
        last_name = name
    return first_initials + last_name


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#D. A. Joyner
#J. R. R. Tolkien
#I. L. Fisher
#S. B. Cohen
#M. M. B. B. Cohen
#P. D. J. F. d. P. J. N. M. d. l. R. C. d. l. S. T. R. y. Picasso
print(my_fancy_name("David Andrew Joyner"))
print(my_fancy_name("John Ronald Reuel Tolkien"))
print(my_fancy_name("Isla Lang Fisher"))
print(my_fancy_name("Sasha Baron Cohen"))
print(my_fancy_name("Montgomery Moses Brian Baron Cohen"))
print(my_fancy_name("Pablo Diego Jose Francisco de Paula Juan Nepomuceno Maria de los Remedios Cipriano de la Santisima Trinidad Ruiz y Picasso"))


## Practice problem 8

#In the classic children's game Swords (also called Odds
#and Evens, Choosies, or Pick), two players simultaneously
#hold out some number of fingers. The winner is determined
#by whether the total number of fingers is odd or even.
#
#For our variant, let us say Player 1 wins if the total
#number of fingers is odd, and Player 2 wins if the total
#number of fingers is even.
#
#Write a function called find_winner. find_winner will take
#as input a list of 2-tuples, each representing a round of
#Swords. Each 2-tuple will contain two integers, each between
#1 and 5. If the sum of the two numbers is odd, then Player
#1 wins the round. If the sum of the two numbers is even,
#then Player 2 wins the round.
#
#find_winner should return the string "Player 1 wins!" if
#Player 1 wins more rounds than Player 2. It should return the
#string "Player 2 wins!" if Player 2 wins more rounds than
#Player 1. It should return the string "It's a tie!" if the
#two players win an equal number of times. 
#
#For example:
#
# find_winner([(1, 1), (2, 1), (1, 2), (2, 4), (5, 2)])
#
#...would return "Player 1 wins!" because Player 1 wins
#three rounds and Player 2 wins two rounds. (If you're
#confused: Player 1 wins rounds 2, 3, and 5 because those
#add to 3, 3, and 7; Player 2 wins rounds 1 and 4 because
#those add to 2 and 6).


#Write your function here!
def find_winner(match):
    player1 = 0
    player2 = 0
    for game in match:
        if (game[0] + game[1]) % 2 == 0:
            player2 += 1
        if (game[0] + game[1]) % 2 == 1:
            player1 += 1
    if player1 > player2:
        return "Player 1 wins!"
    if player2 > player1:
        return "Player 2 wins!"
    if player1 == player2:
        return "It's a tie!"


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#Player 1 wins!
#Player 2 wins!
#It's a tie!
print(find_winner([(1, 1), (2, 1), (1, 2), (2, 4), (5, 2)]))
print(find_winner([(1, 1), (2, 2), (1, 2), (2, 4), (5, 5)]))
print(find_winner([(1, 1), (2, 5), (3, 2), (2, 4), (5, 2), (3, 3)]))
