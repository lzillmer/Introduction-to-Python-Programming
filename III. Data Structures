### STRINGS ###

#Add one to anInteger 
def addOne(anInteger):  
    anInteger = anInteger + 1
    print("anInteger:", anInteger)

#Create myInteger with the value 5
myInteger = 5   
print("myInteger before addOne:", myInteger)
#Call addOne on myInteger
addOne(myInteger)   
print("myInteger after addOne:", myInteger)

### Printing Memory Addresses
print(id())


### PROBLEM SET

myString1 = "12345"
myString2 = "ABCDE"
# Prints True if myString1 is digital
print(myString2.isdigit())
# Prints True if myString2 is digital
print(myString2.isdigit())

# Checks if my_string is uppercase
my_string.isupper()

# Checks if my_string strats with character sequence "ABC"
my_string.startswith("ABC")

###

#Write a function called random_marks. random_marks should
#take three parameters, all integers. It should return a
#string.
#
#The first parameter represents how many apostrophes should
#be in the string. The second parameter represents how many
#quotation marks should be in the string. The third
#parameter represents how many apostrophe-quotation mark
#pairs should be in the string.
#
#For example, random_marks(3, 2, 3) would return this
#string: #'''""'"'"'"
#
#Note that there are three apostrophes, then two quotation
#marks, then three '" pairs.


#Add your function here!
def random_marks(num1, num2, num3):
    return (("'" * num1) + ('"' * num2) + (''''"''' * num3))

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: '''""'"'"'"

print(random_marks(3, 2, 3))


### Special characters
# use \n for a line break
myStringWithNewLine = "1234\n5678"
print(myStringWithNewLine) ##

## \t puts a tab
## \" includes character as is (usually " would indicate the end of a string)
## \\ prints just one slash without breaking

###

#Write a function called "steps" that should return a string 
#that, if printed, looks like this:
#
#111
#	222
#		333
#
#Note that the characters at the beginning of the second and
#third lines must be tabs, not spaces. There should be one
#tab on the second line and two on the third line.
#
#You may only declare ONE string in your function.
#
#Hint: Don't overthink this! We're literally just asking you
#to return one single string that just holds the above text.
#You don't have to build the string dynamically or anything.


#Write your function here!
def steps():
    return "111\n	222\n		333"


#The line below will test your function.
print(steps())


### Concatenate

## all return the same thing:
string1 = "12345"
string2 = "67890"
string3 = string1 + string2
print("Assignment concatenation: " + string 3)
print("In-Line concatenation: " + string1 + string2")
string1 += string 2
print("Self-assignment concatenation: " + string1)

###

#-----------------------------------------------------------
#Write a function called align_right. align_right should
#take two parameters: a string (a_string) and an integer
#(string_length), in that order.
#
#The function should return the same string with spaces
#added to the left so that the text is "right aligned" in a
#string. The number of spaces added should make the total
#string length equal string_length.
#
#For example: align_right("CS1301", 10) would return the
#string "    CS1301". Four spaces are added to the left so
#"CS1301" is right-aligned and the total string length is
#10.
#
#HINT: Remember, len(a_string) will give you the number of
#characters currently in a_string.


#Add your function here!
def align_right(a_string, string_length):    
    while len(a_string) < string_length:
        a_string = " " + a_string
    return a_string


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: "    CS1301"
print(align_right("CS1301", 10))

###

#Write a function called "last_n" that accepts two arguments:
#a string search_string and an integer n. The function should
#return the last n characters from search_string. If
#search_string is shorter than n characters, then it should
#return the entire value of search_string.


#Write your function here!
def last_n(string, number):
    start = len(string) - number
    last_n = string[start:]
    return last_n


#The code below will test your function. If your function
#works correctly, this should print 789, saur, and 1.
print(last_n("123456789", 3))
print(last_n("Bulbasaur", 4))
print(last_n("1", 5))

###

#Write a function called "scramble" that accepts a string
#as an argument and returns a new string. The new string 
#should start with the last half of the original string
#and end with the first half. 
#
#If the length of the string is odd, split the string 
#at the floor of the length / 2 (in other words, the second
#half is the longer half).
#
#For example:
#  scramble("abcd") -> "cdab"
#  screamble("abcde") -> "cdeab"
#  scramble("railroad")) -> "roadrail"
#  scramble("fireworks")) -> "worksfire"


#Write your function here!
def scramble(string):
    end = len(string) // 2
    last_half = string[end:]
    first_half = string[:end]
    return last_half + first_half


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print the results you see in the examples above.

string1 = "abcd"
string2 = "abcde"
string3 = "railroad"
string4 = "fireworks"
print(string1 + " -> " + scramble(string1))
print(string2 + " -> " + scramble(string2))
print(string3 + " -> " + scramble(string3))
print(string4 + " -> " + scramble(string4))

###

#Write a function called fancy_find. fancy_find should have
#two parameters: search_within and search_for.
#
#fancy_find should check if search_for is found within the
#string search_within. If it is, it should print the message
#"[search_for] found at index [index]!", with [search_for]
#and [index] replaced by the value of search_for and the
#index at which it is found. If search_for is not found
#within search_within, it should print, "[search_for] was
#not found within [search_within]!", again with the values
#of search_for and search_within.
#
#For example:
#
#  fancy_find("ABCDEF", "DEF") -> "DEF found at index 3!"
#  fancy_find("ABCDEF", "GHI") -> "GHI was not found within ABCDEF!"


#Add your function here!
def fancy_find(search_within, search_for):
    if search_for in search_within:
        return search_for + " found at index " + \
              str(search_within.find(search_for)) + "!"
    else:
        return search_for + " was not found within " + search_within \
               + "!"

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#DEF found at index 3!
#GHI was not found within ABCDEF!

print(fancy_find("ABCDEF", "DEF"))
print(fancy_find("ABCDEF", "GHI"))

###

myString = "ABCDEABCDEABCDE"

#Prints the first index of "CDE" in myString
print(myString.find("CDE")) 
#Prints the first index of "CDE" in myString after 5
print(myString.find("CDE", 5)) 
#Prints the first index of "CDE" in myString after 8
print(myString.find("CDE", 13)) 
#Prints the first index of "CDE" in myString between 4 and 10
print(myString.find("CDE", 4, 10)) 
#Prints the first index of "CDE" in myString between 3 and 6
print(myString.find("CDE", 3, 6)) 

###

#Recall in Unit 3 you wrote a function that would count the
#number of words in a string using loops. Now that you know
#something about string methods, though, let's do that again
#using a different approach.
#
#Write a function called "num_words" that accepts a string 
#as an argument and returns the number of words in the 
#string. You can assume all words are separated by a space,
#and that the string has at least one word. You do not need
#to worry about punctuation.
#
#For example:
#
#  num_words("Veni, Vidi, Vici.") -> 3
#
#This time, you may not use any loops. Hint: split() might
#come in handy.


#Write your function here!
def num_words(string):
    my_list = string.split(" ")
    count = len(my_list)
    return count

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 3, 2, 1, each on their own line.
print(num_words("Vini, Vidi, Vici."))
print(num_words("Hello, world!"))
print(num_words("HeyDavidwhyaren'ttherespacesinthissentence"))


### Useful string methods ###

mystring.capitalize()
mystring.lower()
mystring.upper()
mystring.title()                 ## capitalizes any character found after space
mystring.strip()                 ## strips any empty spaces at end
mystring.replace("MY", "YOUR")   ## replaces first instances of word with second
mystring.find("*")               ## gives index where * is 
mystring.count(".")              ## counts how many periods
string.startswith("G")           ## will check if string starts with G

mylist = mystring.split()        ## splits string into list of items
print("-".join(mylist))          ## adds "-" between each word in list

###

#One common issue with auto-generated text is a mismatch
#between numbers and whether a word is pluralized. For example,
#your code might accidentally say "You bought 1 items" or
#"You have 7 cat".
#
#Write a function called pluralize. pluralize should have three
#parameters: an integer and two strings. The integer is the
#number of some item. The first string is the string to use if
#the item should not be pluralized. The second string is the
#string to use if the item should be pluralized.
#
#pluralize should return the correct string based on the number
#and plural form: it should use the non-plural version if the
#number is 1, and the plural form for all other numbers.
#
#For example:
#
# pluralize(1, "cat", "cats") -> "1 cat"
# pluralize(7, "item", "items") -> "7 items"
# pluralize(127, "octopus", "octopi") -> "127 octopi"


#Add your code here!
def pluralize(integer, string1, string2):
    if integer == 1:
        return str(integer) + " " + string1
    else:
        return str(integer) + " " + string2
        


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#1 cat
#7 items
#127 octopi
print(pluralize(1, "cat", "cats"))
print(pluralize(7, "item", "items"))
print(pluralize(127, "octopus", "octopi"))

###

#Python, like most languages, actually uses numbers in the 
#background to represent individual characters in a string. 
#For example, "a" is assigned the numeric value of 97. 
#We call this the ordinal value. www.asciitable.com shows
#a table of ordinal values: the ordinal value is listed in
#the 'dec' column, and the actual character is listed in
#'chr' column.
#
#You'll notice, though, that many of the characters here
#are weird. The first 31 are cryptic characters that have
#special meaning to the computer. The extended codes haven't
#really been used since Windows came along. Beyond these
#255, the higher numbers are actually used to represent
#emojis.
#
#Now, think about when you're asked to create a password.
#Typically, there are restrictions on what characters you
#can use. How do you check if a password is valid? You
#could have a list of valid characters and check each
#character against that list, but that would be a really
#long list. Instead, let's use ordinal values.
#
#Write a function called "valid_char" that determines
#if a single character (a string of length one) has an
#ordinal value corresponding to a valid character for a
#password. Valid characters are any character on the
#keyboard except spaces. Return True if it's a valid
#character, False if it is not.
#
#Hint: you can find the ordinal value of a character using 
#the built-in Python function ord(): ord("a") -> 97
#
#Hint 2: the range of legal characters will be one
#continuous range (e.g. characters 55 through 65, not
#separate ranges like 55 through 65 and 69 through 79).
#You can use asciitable.com to look up what range you
#should use.


#Write your function here!
def valid_char(password):
    for char in password:
        if not (33 <= ord(char) <= 136):
            return False
    else:
        return True

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: True, False, True, False

print(valid_char("a"))
print(valid_char(" "))
print(valid_char("!"))
print(valid_char("☺"))

###

#Write function called third_character that accepts a
#string as an argument and returns the third character
#of the string. If the user inputs a string with fewer than
#3 characters, return "Too short". 


#Write your function here!
def third_character(string):
    try:
        return string[2]
    except:
        return "Too short"

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 1, o, and "Too short", each on a different line.
print(third_character("CS1301"))
print(third_character("Georgia Tech"))
print(third_character("GT"))

###

#Write a function called "num_changer" that accepts a string 
#of digits (0-9). You should make an integer from the digits 
#of the even indices and another number from the digits in 
#the odd indices. Return the sum of these two numbers. You 
#can assume the given string will have a length of at least 
#2 digits.
#
#For example, if the string was "123456", you would split
#this into two integers, 135 and 246. Adding them would give
#381. Or if the string was "13579", you would split this into
#159 and 37, then add them to get 196.
#
#Hint: You can do this with loops, but it's easier to do
#this with string slicing. Remember how we could pass a third
#argument to range() that would tell range how many numbers
#to skip? You can do something similar with string slices: if
#you include second colon in a string slice, the number
#that follows it lets you skip characters in the string. For
#example:
#
# "Hello, world!"[1:9] -> This gives "ello, wo".
# "Hello, world!"[1:9:2] -> This gives "el,w". Including :2
#    in the string slice skips every other letter. 
# "Hello, world!" [::3] -> This gives "Hl r!". Leaving the
#    first two spots blank tells it to look at the entire
#    string, but putting :3 at the end says to only take
#    every third character (H, l, space, r, and !).
#
#Hint 2: Remember, Python is zero-indexed. That means the
#first number in the string is at position 0, and so it goes
#in the even list.


#Write your function here!
def num_changer(string):
    even = ""
    odd = ""
    for num in string:
        if int(num) % 2 == 0:
            even += num
        if int(num) % 2 == 1:
            odd += num
    ans = int(even) + int(odd)
    return(ans)


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 123456 -> 381
string_int = "123456"
result = num_changer(string_int)
print(string_int + " -> " + str(result))

###

#Write a function called "num_changer" that accepts a string 
#of digits (0-9). You should make an integer from the digits 
#of the even indices and another number from the digits in 
#the odd indices. Return the sum of these two numbers. You 
#can assume the given string will have a length of at least 
#2 digits.
#
#For example, if the string was "123456", you would split
#this into two integers, 135 and 246. Adding them would give
#381. Or if the string was "13579", you would split this into
#159 and 37, then add them to get 196.
#
#Hint: You can do this with loops, but it's easier to do
#this with string slicing. Remember how we could pass a third
#argument to range() that would tell range how many numbers
#to skip? You can do something similar with string slices: if
#you include second colon in a string slice, the number
#that follows it lets you skip characters in the string. For
#example:
#
# "Hello, world!"[1:9] -> This gives "ello, wo".
# "Hello, world!"[1:9:2] -> This gives "el,w". Including :2
#    in the string slice skips every other letter. 
# "Hello, world!" [::3] -> This gives "Hl r!". Leaving the
#    first two spots blank tells it to look at the entire
#    string, but putting :3 at the end says to only take
#    every third character (H, l, space, r, and !).
#
#Hint 2: Remember, Python is zero-indexed. That means the
#first number in the string is at position 0, and so it goes
#in the even list.


#Write your function here!
def num_changer(digits_string):

    even_digits = digits_string[::2]
    odd_digits = digits_string[1::2]

    even_number = int(even_digits)
    odd_number = int(odd_digits)

    return even_number + odd_number



#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 123456 -> 381
string_int = "13579"
result = num_changer(string_int)
print(string_int + " -> " + str(result))

###

#Write a function called "in_parentheses" that accepts a 
#single argument, a string representing a sentence that
#contains some words in parentheses. Your function should
#return the contents of the parentheses.
#
#For example:
#
# in_parentheses("This is a sentence (words!)") -> "words!"
#
#If no text appears in parentheses, return an empty string.
#Note that there are several edge cases introduced by this:
#all of the following function calls would return an empty
#string:
#
# in_parentheses("No parentheses")
# in_parentheses("Open ( only")
# in_parentheses("Closed ) only")
# in_parentheses("Closed ) before ( open")
#
#You may assume, however, that there will not be multiple
#open or closed parentheses.


#Write your function here!
def in_parentheses(sentence):
    open_index = sentence.find("(")
    close_index = sentence.find(")")
    if open_index != -1 and close_index != -1:
        return sentence[open_index + 1:close_index]
    else:
        return ""


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (including the blank lines):
#words!
#
#as he is doing right now
#
#
#!

print(in_parentheses("This is a sentence (words!)."))
print(in_parentheses("No parentheses here!"))
print(in_parentheses("David tends to use parentheses a lot (as he is doing right now). It tends to be quite annoying."))
print(in_parentheses("Open ( only"))
print(in_parentheses("Closed ) only"))
print(in_parentheses("Closed ) before ( open"))
print(in_parentheses("That's a lot of test cases(!)"))

###

#Write a function called 'string_type' which accepts one
#string argument and determines what type of string it is. 
#
# - If the string is empty, return "empty".
# - If the string is a single character, return "character".
# - If the string represents a single word, return "word".
#   The string is a single word if it has no spaces.
# - If the string is a whole sentence, return "sentence".
#   The string is a sentence if it contains spaces, but
#   at most one period.
# - If the string is a paragraph, return "paragraph". The
#   string is a paragraph if it contains both spaces and
#   multiple periods (we won't worry about other
#   punctuation marks).
# - If the string is multiple paragraphs, return "page".
#   The string is a paragraph if it contains any newline
#   characters ("\n").
#
#Hint: think carefully about what order you should check
#these conditions in.
#
#Hint 2: remember, there exists a count() method that
#counts the number of times a string appears in another
#string. For example, "blah blah blah".count("blah")
#would return 3.


#Write your function here!
def string_type(string):
    if string == "":
        return "empty"
    if len(string) == 1:
        return "character"
    if " " not in string:
        return "word"
    if " " in string and ("." in string or "!" in string) and (string.count(".") == 1 or string.count("!") == 1):
        return "sentence"
    if " " in string and "." in string and string.count(".") > 1 and "\n" not in string:
        return "paragraph"
    if "\n" in string:
        return "page"

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#empty
#character
#word
#sentence
#paragraph
#page
print(string_type(""))
print(string_type("!"))
print(string_type("CS1301."))
print(string_type("This is too many cases!"))
print(string_type("There's way too many ostriches. Why are there so many ostriches. The brochure said there'd only be a few ostriches."))
print(string_type("Paragraphs need to have multiple sentences. It's true.\nHowever, two is enough. Yes, two sentences can make a paragraph."))

###

#Recall that input from a user is always in the form of a string. 
#Write a function called "input_type" that gets user input and 
#determines what kind of string the user entered. The user input
#will be supplied as an argument to the function like normal.
#
#  - Your function should return "integer" if the string only
#    contains characters 0-9.
#  - Your function should return "float" if the string only
#    contains the numbers 0-9 and at most one period.
#  - You should return "boolean" if the user enters "True" or
#    "False". 
#  - Otherwise, you should return "string".


#Write your function here!
def input_type(string):
    if string.isdigit():
        return "integer"
    elif string.replace(".", "", 1).isdigit():
        return "float"
    elif string == "True" or string == "False":
        return "boolean"
    else:
        return "string"
        

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#string
#boolean
#float
#integer
print(input_type(""))
print(input_type("False"))
print(input_type("7.432621"))
print(input_type("2788"))

###

#Write a function called "quote_this" that accepts two 
#strings as arguments: a string representing a quote and
#a string of a name. The function should return a new
#string with the quote surrounded by quotation marks (")
#followed by a dash and the given name. For example:
#
#a = quote_this("Try and fail, but never fail to try.",
#"Jared Leto")
#print(a) 
#
#Will print:
#"Try and fail, but never fail to try." -Jared Leto
#
#If the code were to continue, this:
#
#b = quote_this(a, "Michael Scott")
#print(b)
#
#Would print:
#""Try and fail, but never fail to try." -Jared Leto"
#- Michael Scott


#Write your function here!
def quote_this(quote, name):
    return '"' + quote + '"' + " -" + name


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print the same output as the examples above.
a = quote_this("Try and fail, but never fail to try.", "Jared Leto")
print(a) 
b = quote_this(a, "Michael Scott")
print(b)

###

#Write a function called string_finder. string_finder should
#take two parameters: a target string and a search string.
#The function will look for the search string within the
#target string.
#
#The function should return a string representing where in
#the target string the search string was found:
#
# - If search string is at the very beginning of target
#   string, then return "Beginning". For example:
#   string_finder("Georgia Tech", "Georgia") -> "Beginning"
#
# - If search string is at the very end of target string,
#   then return "End". For example:
#   string_finder("Georgia Tech", "Tech") -> "End"
#
# - If search string is in target string but not at the
#   very beginning or very end, then return "Middle. For
#   example:
#   string_finder("Georgia Tech", "gia") -> "Middle"
#
# - If search string is not in target string at all, then
#   return "Not found". For example:
#   string_finder("Georgia Tech", "Idaho") -> "Not found"
#
#Assume that we're only interested in the first instance
#of the search string if it appears multiple times in the
#target string, and that search string is definitely
#shorter than target string.
#
#Hint: Don't be surprised if you find that the "End" case
#is the toughest! You'll need to look at the lengths of
#both the target string and the search string.


#Write your function here!
def string_finder(target, search):
    if target.startswith(search):
        return "Beginning"
    elif target.endswith(search):
        return "End"
    elif search in target:
        return "Middle"
    else:
        return "Not found"


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: Beginning, Middle, End, Not found, each on their own
#line.
print(string_finder("Georgia Tech", "Georgia"))
print(string_finder("Georgia Tech", "gia"))
print(string_finder("Georgia Tech", "Tech"))
print(string_finder("Georgia Tech", "Idaho"))

###

#We've talked about ordinal numbers before, but they can
#mean something else: "ordinal" is also the term for numbers
#like 1st, 2nd, 3rd, 4th, etc.

#Write a function called to_ordinal. to_ordinal should
#take as input an integer greater than 0. to_ordinal should
#return a string of the ordinal of the integer (according to
#the above definition of ordinal).
#
#For example:
#
# to_ordinal(1) -> 1st
# to_ordinal(2) -> 2nd
# to_ordinal(3) -> 3rd
# to_ordinal(4) -> 4th
# to_ordinal(5) -> 5th
# to_ordinal(11) -> 11th
# to_ordinal(21) -> 21st
#
#Generally, ordinal numbers are always the original integer
#plus "th" _unless_ the original integer ended with 1 (in
#which case you add "st"), 2 (in which case you add "nd"),
#or 3 (in which case you add "rd")... except for 11, 12, and
#13, which still end in "th".


#Add your function below!
def to_ordinal(integer):
    integer = str(integer)
    if integer == "11" or integer == "12" or integer == "13":
        return integer + "th"
    elif integer.endswith("1"):
        return integer + "st"
    elif integer.endswith("2"):
        return integer + "nd"
    elif integer.endswith("3"):
        return integer + "rd"
    else:
        return integer + "th"
        
        
#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#1st
#2nd
#3rd
#4th
#5th
#11th
#21st
print(to_ordinal(1))
print(to_ordinal(2))
print(to_ordinal(3))
print(to_ordinal(4))
print(to_ordinal(5))
print(to_ordinal(11))
print(to_ordinal(21))

###

#Write a function called to_metric. to_metric should take
#as input one parameter, a string. The string will represent
#a quantity in imperial volume units, such as "7 cups", "2
#tablespoons", or "8 gallons". to_metric should return the
#equivalent number of milliliters as a float. Round the
#result to two decimal places.
#
#The possible imperial units to handle and their conversion to
#milliliters are:
#
# - gallons: 3785.41 milliliters
# - quarts: 946.35 milliliters
# - pints: 473.18 milliliters
# - cups: 240 milliliters
# - ounces: 29.57 milliliters
# - tablespoons: 14.79 milliliters
# - teaspoons: 4.93 milliliters
#
#Return only the float representing the number of milliliters,
#not the label. For example:
#
#to_metric("7.0 cups") -> 1680
#to_metric("2.0 tablespoons") -> 29.58
#to_metric("8.0 gallons") -> 30283.28
#
#You may assume that the string will be formatted like the
#strings above: a decimal number, then a space, then one of
#the following words: cgallons, quarts, pints, cups, ounces,
#tablespoons, teaspoons


#Add your code here!
def to_metric(input_string):

    conversion = {"gallons": 3785.41, "quarts": 946.35, "pints": 473.18, "cups": 240, "ounces": 29.57, "tablespoons": 14.79, "teaspoons": 4.93}

    quantity, unit = input_string.split()
    numeric_value = float(quantity)
    result = numeric_value * conversion[unit]
    return round(result, 2)


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#1680
#29.58
#30283.28
print(to_metric("7.0 cups"))
print(to_metric("2.0 tablespoons"))
print(to_metric("8.0 gallons"))

###

#One common function of online text-parsers is trying to find
#known text in a block of other text. For example, from a web
#site, we might want to find any phone numbers present on the
#web site.
#
#Write a function called find_phone_number. The function
#should have one parameter, a string. The function should
#return the phone number that was present in the string.
#
#For this problem, you may make the following assumptions:
#
# - The phone number will be all digits, such as 4043219876.
# - There will only be one phone number in the string.
# - There will be a phone number in the string.
# - Either the phone number will be at the start or end of
#   the string, or it will have spaces on either side of it.
#
#There may be other numbers in the string, but there will only
#be one 10-digit number. Find and return that number as a
#string.
#
#Hint: There are lots of different ways to do this. Think about
#all the tools at your disposal: split, find, casting strings
#to integers, error handling, etc.!


#Add your code here!
def find_phone_number(string):
    phone_number = ""

    for char in range(len(string) - 9):
        potential_phone = string[char:char+10]
        if potential_phone.isdigit():
            phone_number = potential_phone
            break

    return phone_number


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#4049876543
#7705551234
#6789123456
print(find_phone_number("hello 4049876543 goodbye"))
print(find_phone_number("7705551234 this is alex"))
print(find_phone_number("doh ray me abc 123 its 6789123456"))


### LISTS AND TUPLES ###

#Write a function called unpack_and_reverse that will
#accept one parameter, a tuple with at least three items.
#The function should return a new tuple with only the first
#three items, but listed in reverse order.
#
#For example:
#
# a_tuple = ("a", "b", "c", "d", "e")
# unpack_and_reverse(a_tuple) -> ("c", "b", "a")
#
#However, to do this, you should not access any value in
#the tuple directly (e.g. with a_tuple[1]). Instead, you
#should use tuple unpacking to unpack them into variables.
#You also should not touch any items past the third item
#in the tuple: use tuple slicing instead to only access
#the first three.

#Write your function here!
def unpack_and_reverse(mytuple):
    a, b, c = mytuple[0:3]
    return c, b, a

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#('c', 'b', 'a')
#('h', 'g', 'f')
#('k', 'j', 'i')
print(unpack_and_reverse(("a", "b", "c", "d", "e")))
print(unpack_and_reverse(("f", "g", "h")))
print(unpack_and_reverse(("i", "j", "k", "l", "m", "n", "o", "p", "q", "r")))

###

#Remember asciitable.com from an earlier exercise? We're
#going to use it again. Remember, ordinal values for
#characters are given in the 'Dec' column of asciitable.com.
#
#Write a function called character_info. character_info will
#take as input a string with only one character. It should
#return a 3-tuple with three pieces of information:
#
# - In the first spot, the character itself.
# - In the second spot, the ordinal value of the character,
#   obtained using the ord() function (e.g. ord("a") -> 97).
# - In the third spot, what type of character it is: either
#   "letter", "number", or "punctuation".
#
#You may assume that anything that is not a letter (either
#upper or lower case) or a number is punctuation. You may
#also assume the ordinal will be between 32 (" ") and 126
#("~").


#Write your function here!
def character_info(char):
    if char in "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz":
        char_type = "letter"
    elif char in "1234567890":
        char_type = "number"
    else:
        char_type = "punctuation"
    return (char, ord(char), char_type)
    
        
#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#('q', 113, 'letter')
#('7', 55, 'number')
#('`', 96, 'punctuation')
print(character_info("q"))
print(character_info("7"))
print(character_info("`"))

### Useful list functions ###

mylist.sort()                     ## sorts low to high
mylist.append()                   ## adds to list
mylist.extend()                   ## adds to list
mylist.insert(location, value)    ## inserts value after location
mylist.remove()                   ## removes given value from list
mylist.reverse()                  ## reverses list
mylist.pop()                      ## removes last item from list (and stores it)
del mylist[-5:]                   ## removes all values starting at five from the end
mylist.index(23)                  ## shows where value 23 is indexed
mylist.count(15)                  ## counts how many times 15 occurs in list
print(4 in mylist)                ## prints False since 4 isn't in list

###

#Write a function called modify_list. modify_list will
#take one parameter, a list. It should then modify the
#list in the following ways, in this order:
#
# - Sort the list (using the default sort method).
# - Reverse the order of the list.
# - Delete the last three items of the list.
# - Removes one instance the integer 7 from the list, if
#   it's present.
# - Double the values of the first and third items in
#   the list.
#
#It should then return the resulting list. You may assume
#the list will start with at least six items.
#
#Hint: Remember Python is 0-indexed. The second item
#does not have an index of 2.
#
#Hint 2: Remember, the list.remove() function removes items
#by value, not by index. Note also that if the item you're
#trying to remove is not found in the list, remove() will
#throw an error: so, you'll want to avoid that one way or
#another!


#Write your code here!
def modify_list(mylist):
    mylist.sort()
    mylist.reverse()
    del mylist[-3:]
    if 7 in mylist:
        mylist.remove(7)
    mylist[0] *= 2
    mylist[2] *= 2
    return mylist


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#[178, 81, 75.0, 4, 3.141592653589793, 3]
import math
print(modify_list([7, 4, 3, 2.0, 81, 37.5, 89, math.pi, -2, math.e]))

###

#Write a function called multiply_strings. Multiply
#strings should have one parameter, a list of strings.
#It should return a modified list according to the
#following changes:
#
# - Every string stored at an even index should be
#   doubled.
# - Every string stored at an index that is a multiple
#   of 3 should be tripled.
# - Every other string should remain unchanged.
#
#These changes should "stack": the string stored at index
#6 should be duplicated six times (2 * 3).
#
#Then, return the new list. You may assume that 0 is a
#multiple of 2 and 3.
#
#Hint: To do this, you need to modify the values of the
#list using their indices, e.g. a_list[1]. If you're not
#using their indices, your answer won't work!


#Write your function here!
def multiply_strings(list_of_strings):
    for string in range(0, len(list_of_strings), 2):
        list_of_strings[string] *= 2
    for string in range(0, len(list_of_strings), 3):
        list_of_strings[string] *= 3
    return list_of_strings


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 
#['AAAAAA', 'B', 'CC', 'DDD', 'EE', 'F', 'GGGGGG']
test_list = ["A", "B", "C", "D", "E", "F", "G"]
print(multiply_strings(test_list))

###

#Write a function called sum_lists. sum_lists should take
#one parameter, which will be a list of lists of integers.
#sum_lists should return the sum of adding every number from
#every list.
#
#For example:
#
# list_of_lists = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
# sum_list(list_of_lists) -> 67


#Add your code here!
def sum_lists(list_of_lists):
    sum = 0
    for single_list in list_of_lists:
        for item in single_list:
            sum += item
    return sum


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 78
list_of_lists = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
print(sum_lists(list_of_lists))

###

#We've learned a lot in this chapter. Let's try to use a lot
#of it for one final exercise.
#
#Write a function called sort_artists. sort_artists will
#take as input a list of tuples. Each tuple will have two
#items: the first item will be a string holding an artist's
#name, and the second will be an integer representing their
#total album sales (in millions).
#
#Return a tuple of two lists. The first list in the
#resulting tuple should be all the artists sorted
#alphabetically. The second list should be all the revenues
#sorted in descending numerical order.
#
#For example:
# artists = [("The Beatles", 270.8), ("Elvis Presley", 211.5), ("Michael Jackson", 183.9)]
# sort_artists(artists) -> (["Elvis Presley", "Michael Jackson", "The Beatles"], [270.8, 211.5, 183.9])
#
#Notice that artists is a list of tuples (brackets first,
#then parentheses), but sort_artists outputs a tuple of
#lists (parentheses first, then brackets).


#Write your function here!
def sort_artists(artist_list):
    
    artists = []
    sales = []
    
    for artist_tuple in artist_list:        
        artists.append(artist_tuple[0])        
        sales.append(artist_tuple[1])
      
    artists.sort()
    sales.sort()
    sales.reverse()
    
    return (artists, sales)
    

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#(['Elvis Presley', 'Michael Jackson', 'The Beatles'], [270.8, 211.5, 183.9])  
artists = [("The Beatles", 270.8), ("Elvis Presley", 211.5), ("Michael Jackson", 183.9)]
print(sort_artists(artists))

###

#Averages each list in in2DList
def TwoDAverageWithPop(in2DList):  
    result = []
    #Repeat until in2DList is empty
    while len(in2DList) > 0:    
        #Remove and assign the last item of in2DList to numList
        numList = in2DList.pop()    
        sum = 0
        count = 0
        #Repeat until numList is empty
        while len(numList) > 0: 
            #Remove and save the last item of numList to number
            number = numList.pop()  
            sum += number
            count += 1
        #Insert this average at the beginning of result
        result.insert(0, sum / count)   
    return result

my2DList = [[91, 95, 89, 92, 85],[85, 87, 91, 81, 82],
            [79, 75, 85, 83, 89],[81, 89, 91, 91, 90],
            [99, 91, 95, 89, 90]]

print("Averages:", TwoDAverageWithPop(my2DList))
print("my2DList:", my2DList)


### PROBLEM SET

#Write a function called multiply_by_index. multiply_by_index
#should have one parameter, a list; you may assume every item
#in the list will be an integer. multiply_by_index should
#return a list where each number in the original list is
#multipled by the index at which it appeared.
#
#For example:
#
#multiply_by_index([1, 2, 3, 4, 5]) -> [0, 2, 6, 12, 20]
#
#In the example above, the numbers 1, 2, 3, 4, and 5 appear
#at indices 0, 1, 2, 3, and 4. 1*0 = 0, 2 * 1 = 2, 3 * 2 = 6,
#and so on.


#Write your code here!
def multiply_by_index(my_list):
    new_list = []
    index = 0
    for num in my_list:
        num = num * index
        new_list.append(num)
        index += 1
    return new_list


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#[0, 2, 6, 12, 20]
#[0, 7, 14, 21, 28, 35, 42]
#[0, 7, 74, 195, 36, 0, 330]
print(multiply_by_index([1, 2, 3, 4, 5]))
print(multiply_by_index([7, 7, 7, 7, 7, 7, 7]))
print(multiply_by_index([14, 7, 37, 65, 9, 0, 55]))

###

#Write a function, called lucky_sevens, that takes in one
#parameter, a list of integers, and returns True if the list
#has three '7's  in a row and False if the list doesn't.
#
#For example:
#
#  lucky_sevens([4, 7, 8, 2, 7, 7, 7, 3, 4]) -> True
#  lucky_sevens([4, 7, 7, 2, 8, 3, 7, 4, 3]) -> False
#
#Hint: As soon as you find one instance of three sevens, you
#could go ahead and return True -- you only have to find it
#once for it to be True! Then, if you get to the end of the
#function and haven't returned True yet, then you might
#want to return False.


#Write your function here!
def lucky_sevens(my_list):
    for index in range(len(my_list) - 2):
        if my_list[index] == my_list[index + 1] == my_list[index + 2] == 7:
            return True
    else:
        return False


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: True, then False
print(lucky_sevens([4, 7, 8, 2, 7, 7, 7, 3, 4]))
print(lucky_sevens([4, 7, 7, 2, 8, 3, 7, 4, 3]))

###

#Write a function called attendance_check. attendance_check
#should have two parameters: roster and present. Both roster
#and present will be lists of strings. Return a list (sorted
#alphabetically) of all strings in the list roster that are
#not in the list present. In other words, if roster is a
#list of students enrolled in a class and present is a list
#of students in class today, return a list of students that
#are absent.
#
#You may assume that every item in each list will be a
#string. You may also assume that every name in the list
#present will be in the list roster. If no students are
#absent, return an empty list.


#Write your function here!
def attendance_check(roster, present):
    absent = []
    for name in roster:
        if name not in present:
            absent.append(name)
    absent.sort()
    return absent

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 
#['Ferguson', 'Winston']
test_roster = ['Jessica', 'Nick', 'Winston', 'Schmidt', 'Cece', 'Ferguson']
test_present = ['Nick', 'Cece', 'Schmidt', 'Jessica']
print(attendance_check(test_roster, test_present))

###

#Write a function called grade_scantron. grade_scantron should
#take as input two lists: answers and key. Each list contain
#strings. Each string will be only one letter, a character
#from A to E. grade_scantron should return how many questions
#the student got "right", where a student gets a question
#right if their answer for a problem matches the answer key.
#
#In other words, if value of the first item in answers matches
#the value of the first item in key, the student gets a point.
#If it does not, the student does not get a point.
#
#If the lists do not have the same number of items, return
#-1 to indicate that the answer key did not belong to the
#same test as the student's answers.\
#
#Hint: in the past, lots of people have tried to do this using
#the index() method. That won't work! You'll need to track the
#index yourself.


#Write your function here!
def grade_scantron(answers, keys):
    if len(answers) != len(keys):
        return -1
    
    grade = 0
    for i in range(len(answers)):
        if answers[i] == keys[i]:
            grade += 1
    return grade


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 7
test_answers = ["A", "B", "B", "A", "D", "A", "B", "A", "E"]
test_key = ["A", "B", "B", "A", "D", "E", "B", "A", "D"]
print(grade_scantron(test_answers, test_key))

###

#Write a function called solve_right_triangle. The function
#solve_right_triangle should have three parameters: opposite, 
#adjacent, and use_degrees. opposite and adjacent will be
#floats, and use_degrees will be a boolean. use_degrees
#should be a keyword parameter, and it should have a
#default value of False.
#
#The function should return a tuple containing the
#hypotenuse and angle of the right triangle (in that order).
#If use_degrees is False, the angle should be in radians.
#If use_degrees is True, the angle should be in degrees.
#
#Remember, the formula for the hypotenuse of a right
#triangle is the square root of the sum of the squared side
#lengths. You can find arctan using math.atan(), passing in
#the quotient of the opposite and adjacent as the argument.
#By default, math.atan() returns the angle in radians; you
#can pass that angle as an argument into the math.degrees()
#method to convert it to degrees; for example:
#
# angle_in_degrees = math.degrees(angle_in_radians)

import math


#Write your function here!
def solve_right_triangle(opposite, adjacent, use_degrees = False):
    #my_tuple = ()
    hypotenuse = (opposite ** 2 + adjacent ** 2) ** 0.5
    angle = math.atan(opposite / adjacent)
    if use_degrees == True:
       angle = math.degrees(angle) 
    my_tuple = (hypotenuse, angle)    
    return my_tuple


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#(5.0, 0.6435011087932844)
#(5.0, 36.86989764584402)
print(solve_right_triangle(3.0, 4.0))
print(solve_right_triangle(3.0, 4.0, use_degrees = True))

###

#Write a function called find_max_sales. find_max_sales will
#have one parameter: a list of tuples. Each tuple in the
#list will have two items: a string and an integer. The
#string will represent the name of a movie, and the integer
#will represent that movie's total ticket sales (in millions
#of dollars).
#
#The function should return the movie from the list that
#had the most sales. Return only the movie name, not the
#full tuple.


#Write your function here!
def find_max_sales(list_of_tuples):
    biggest_sale = 0
    movie = ""
    
    for tuple in list_of_tuples:
        if tuple[1] > biggest_sale:
            biggest_sale = tuple[1]
            movie = tuple[0]
    return movie


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: Rogue One
movie_list = [("Finding Dory", 486), ("Captain America: Civil War", 408), ("Deadpool", 363), ("Zootopia", 341), ("Rogue One", 529), ("The Secret Life of Pets", 368), ("Batman v Superman", 330), ("Sing", 268), ("Suicide Squad", 325), ("The Jungle Book", 364)]
print(find_max_sales(movie_list))

###

#Write a function called wish_list. wish_list should have
#four parameters, in this order: 
#
# - a list of strings, representing a list of items on a
#   wish list
# - a string, representing a particular item
# - a float, representing the cost of this item
# - a float, representing your budget
#
#If the item is on the list and you can afford it (cost is
#less than or equal to budget), return the string,
#"You should buy a [item name]!", replacing [item name]
#with the string.
#
#If the item is on the list but you can't afford it,
#return the string, "You should save up for a [item name]!",
#replacing [item name] with the string.
#
#If the item is not on the list, you should return the
#string "You probably don't want to buy a [item name].",
#replacing [item name] with the string.
#
#HINT: You do not need a loop to solve this. You can use
#one, but you don't need one.


#Add your function here!
def wish_list(wish_list_items, selected_item, item_cost, budget):
    if selected_item in wish_list_items and item_cost <= budget:
        return "You should buy a " + selected_item + "!"
    if selected_item in wish_list_items and item_cost > budget:
        return "You should save up for a " + selected_item + "!"
    if selected_item not in wish_list_items:
        return "You probably don't want to buy a " + selected_item + "."
   

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: "You should save up for a bugle!"

wish_list_items = ["bugle", "trumpet", "banjo", "tuba"]
selected_item = "bugle"
item_cost = 199.99
budget = 150.00

print(wish_list(wish_list_items, selected_item, item_cost, budget))

###

#Imagine you're writing some code for an exercise tracker.
#The tracker measures heart rate, and should display the
#average heart rate from an exercise session.
#
#However, the tracker doesn't automatically know when the
#exercise session began. It assumes the session starts the
#first time it sees a heart rate of 100 or more, and ends
#the first time it sees one under 100.
#
#Write a function called average_heart_rate.
#average_heart_rate should have one parameter, a list of
#integers. These integers represent heart rate measurements
#taken 30 seconds apart. average_heart_rate should return
#the average of all heart rates between the first 100+
#heart rate and the last one. Return this as an integer
#(use floor division when calculating the average).
#
#You may assume that the list will only cross the 100 beats
#per minute threshold once: once it goes above 100 and below
#again, it will not go back above.


#Add your function here!
def average_heart_rate(my_list):
    count = 0
    sum = 0
    for number in my_list:
        if number >= 100:
            sum += number
            count += 1

    average = sum // count
    return average


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print 114 (because there are 14 measurements from 102 to
#101, their sum is 1609, and 1609 // 14 is 114).
beats = [72, 77, 79, 95, 102, 105, 112, 115, 120, 121, 121,
         125, 125, 123, 119, 115, 105, 101, 96, 92, 90, 85]
print(average_heart_rate(beats))

###

#Write a function called inside_search. inside_search should
#have two parameters: a list of strings and a string to search
#for. inside_search should return a list of all the indices at
#which the string in the list contains the search string. Note
#that the string at that index does not need to BE the search
#string, but rather must just contain it.
#
#For example:
#
#a_list = ["cat", "cats", "dog", "dogs", "catsup"]
#search_term = "cat"
#inside_search(a_list, search_term) -> [0, 1, 4]
#
#Note that the strings "cat", "cats", and "catsup" all contain
#the search string "cat", and thus the result is their indices:
#[0, 1, 4].
#
#Make sure the list you return is sorted from lowest index to
#highest.


#Add your code here!
def inside_search(my_list, search_string):
    indices = []
    for word in my_list:
        if search_string in word:
            index = my_list.index(word)
            indices.append(index)
    return indices
            


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#[0, 1, 4]
#[2, 3]
#[1, 4]
#[4]
#[]
cats_and_dogs_list = ["cat", "cats", "dog", "dogs", "catsup"]
print(inside_search(cats_and_dogs_list, "cat"))
print(inside_search(cats_and_dogs_list, "dog"))
print(inside_search(cats_and_dogs_list, "cats"))
print(inside_search(cats_and_dogs_list, "sup"))
print(inside_search(cats_and_dogs_list, "aardvark"))

###

#You've been sent a list of names. Unfortunately, the names
#come in two different formats:
#
#First Middle Last
#Last, First Middle
#
#You want the entire list to be the same. For this problem,
#we'll say you want the entire list to be Last, First Middle.
#
#Write a function called name_refixer. name_refixer should take
#as input the list of strings. You may assume that every string
#will match one of the two formats above: either First Middle Last
#or Last, First Middle. 
#
#name_fixer should return a list of names all structured as
#Last, First Middle. If the name was already structured as
#Last, First Middle, it should remain unchanged. If it was
#structured as First Middle Last, then Last should be moved
#to the beginning and a comma should be added after it.
#
#The names should appear in the same order as the original list.
#
#For example:
#
#name_list = ["David Andrew Joyner", "Hart, Melissa Joan", "Cyrus, Billy Ray"]
#name_fixer(name_list) -> ["Joyner, David Andrew", "Hart, Melissa Joan", "Cyrus, Billy Ray"]


#Add your code here!
def name_refixer(my_list):
    final_list = []
    for name in my_list:
        if "," in name:
            final_list.append(name)
        elif "," not in name:
            correct_name = name.split()
            correct_name = correct_name[2] + ", " + correct_name[0] + " " + correct_name[1]
            final_list.append(correct_name)
    return final_list


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#["Joyner, David Andrew", "Hart, Melissa Joan", "Cyrus, Billy Ray"]
name_list = ["David Andrew Joyner", "Hart, Melissa Joan", "Cyrus, Billy Ray"]
print(name_refixer(name_list))


### FILE INPUT AND OUTPUT ###

myInt1 = 12
myInt2 = 23
myInt3 = 34

#Open OutputFile.txt in write mode
outputFile = open("OutputFile.txt", "w")    

#Write myInt1 to outputFile
outputFile.write(str(myInt1))    
#Write myInt2 to outputFile
outputFile.write(str(myInt2))    
#Write myInt3 to outputFile
outputFile.write(str(myInt3))    
#Close outputFile
outputFile.close()  

###

#Write a function called "write_file" that accepts two 
#parameters: a filename and some data that will either 
#be an integer or a string to write. The function 
#should open the file and write the data to the file.
#
#Hints:
#
# - Don't forget to close the file when you're done!
# - If the data isn't a string already, you may need
#   to convert it, depending on the approach you
#   choose.
# - Remember, this code has no print statements, so
#   when you run it, don't expect to see any output
#   on the right! You could add print statements if
#   you want a confirmation the code is done running.
# - You can put the variable for the filename in the
#   same place where we put text like OutputFile.txt
#   in the videos.


#Write your function here!
def write_file(filename, data):
    output_file = open(filename, "w")
    output_file.write(str(data))
    output_file.close()


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print nothing. However, if you open WriteFileOutput.txt
#in the top left after running it, the contents of the
#file should be 1301.
write_file("WriteFileOutput.txt", 1301)

###

#Write a function called "append_to_file" that accepts
#two parameters: a filename and some data that will
#be an integer or a string to write. The function 
#should open the file and add the data to the end of
#the file. Each new call to append_to_file should add
#the new contents on a new line.
#
#Hints:
#
# - Don't forget to close the file when you're done!
# - If the data isn't a string already, you may need
#   to convert it.
# - Remember, this code has no print statements, so
#   when you run it, don't expect to see any output
#   on the right! You could add print statements if
#   you want a confirmation the code is done running.
# - You can put the variable for the filename in the
#   same place where we put text like OutputFile.txt
#   in the videos.


#Write your function here!
def append_to_file(filename, data):
    output_file = open(filename, "a")
    output_file.write(str(data) + "\n")
    output_file.close()

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print nothing. However, if you open AppendToFileOutput.txt
#in the top left after running it, the contents of the
#file should be another instance of 1301 every time you
#run this file.
append_to_file("AppendToFileOutput.txt", 1301)

###

myList = ["David", "Lucy", "Vrushali", "Ping",
          "Natalie", "Dana", "Addison", "Jasmine"]

#Open OutputFile.txt in write mode
outputFile = open("OutputFile.txt", "w")    

#For each name in myList
for name in myList: 
    #Write the name to the file on its own line
    print(name, file = outputFile)   

outputFile.close()

###

myList = ["David", "Lucy", "Vrushali", "Ping", 
          "Natalie", "Dana", "Addison", "Jasmine"]

#Open OutputFile.txt in write mode
outputFile = open("OutputFile.txt", "w")    

#For each name in myList
for name in myList: 
    #Write the name to the file on its own line
    outputFile.write(name + "\n")   

outputFile.close()

###

myList = ["David", "Lucy", "Vrushali", "Ping",
          "Natalie", "Dana", "Addison", "Jasmine"]

#Open OutputFile.txt in write mode
outputFile = open("OutputFile.txt", "w")    

#Writes every string in myList to a file
outputFile.writelines(myList)   

outputFile.close()

###

myList = ["David", "Lucy", "Vrushali", "Ping",
          "Natalie", "Dana", "Addison", "Jasmine"]
 
#Open OutputFile.txt in write mode
outputFile = open("OutputFile.txt", "w")    
 
#Joins myList using \n, then writes it to a file
outputFile.write("\n".join(myList))   
 
outputFile.close()

###

myInt1 = 12
myInt2 = 23
myInt3 = 34
myList = ["David", "Lucy", "Vrushali", "Ping", 
          "Natalie", "Dana", "Addison", "Jasmine"]

#Open OutputFile.txt in write mode
outputFile = open("OutputFile.txt", "w")    

#Write myInt1 to outputFile
outputFile.write(str(myInt1) + "\n")    
#Write myInt2 to outputFile
outputFile.write(str(myInt2) + "\n")    
#Write myInt3 to outputFile
outputFile.write(str(myInt3) + "\n")    
#Joins myList using \n, then writes it to a file
outputFile.write("\n".join(myList))   

outputFile.close()

###

#Write a function called "find_coffee" that expects a 
#filename as a parameter. The function should open the 
#given file and return True if the file contains the word 
#"coffee". Otherwise, the function should return False.
#
#Hint: look up the read() method if you want to do this
#more simply than you might do with readline().


#Write your function here!
def find_coffee(filename):
    input_file = open(filename, "r")
    file_contents = input_file.read()
    input_file.close()
    if "coffee" in file_contents:
        return True
    else:
        return False

#You can test your function with the provided files named 
#"coffeeful.txt" and "coffeeless.txt". With their original
#text, the lines below should print True, then False. You
#may also edit the files by selecting them in the drop
#down in the top left to try your code with different
#input.
print(find_coffee("coffeeful.txt"))
print(find_coffee("coffeeless.txt"))

###

#Write a function called "load_file" that accepts one 
#parameter: a filename. The function should open the
#file and return the contents.#
#
# - If the contents of the file can be interpreted as
#   an integer, return the contents as an integer.
# - Otherwise, if the contents of the file can be
#   interpreted as a float, return the contents as a
#   float.
# - Otherwise, return the contents of the file as a
#   string.
#
#You may assume that the file has only one line.
#
#Hints:
#
# - Don't forget to close the file when you're done!
# - Remember, anything you read from a file is
#   initially interpreted as a string.


#Write your function here!
def load_file(filename):
    input_file = open(filename, "r")
    contents = input_file.readline()
    try:
        return int(contents)
    except ValueError:
        try:
            return float(contents)    
        except:
            return str(contents)
    finally:
        input_file.close()


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print 123, followed by <class 'int'>.
contents = load_file("LoadFromFileInput.txt")
print(contents)
print(type(contents))

###

myList = []

#Open OutputFile.txt in read mode
inputFile = open("OutputFile.txt", "r")    

#For each line in the file
for line in inputFile:  
    #Add the line to myList, stripping out whitespace
    myList.append(line.strip()) 

print(myList)

inputFile.close()

###

myList = []

#Open OutputFile.txt in read mode
inputFile = open("OutputFile.txt", "r")    

myInt1 = int(inputFile.readline())  
myInt2 = int(inputFile.readline())  
myInt3 = int(inputFile.readline())  
#For each line in the file
for line in inputFile:  
    #Add the line to myList, stripping out whitespace
    myList.append(line.strip()) 

print(myInt1)
print(myInt2)
print(myInt3)
print(myList)

inputFile.close()

###

#Saves inList to the file
def save(filename, inList): 
    outputFile = open(filename, "w")

    for item in inList: 
        print(item, file = outputFile)   

    outputFile.close()

#Loads from filename and returns a list of the contents
def load(filename): 
    inputFile = open(filename, "r")
    inList = []

    for line in inputFile:
        inList.append(line.strip())
    inputFile.close()
    return inList

myList = ["David", "Lucy", "Vrushali", "Ping", "Natalie",
          "Dana", "Addison", "Jasmine"]
save("OutputFile.txt", myList)
newList = load("OutputFile.txt")

print(newList)

###

inputFile = open("OutputFile.txt", "r")
print(inputFile)
inputFile.close()

###

inputFile = open("OutputFile.txt", "r")

#Print the next line of inputFile
print(inputFile.readline()) 
#Print the next line of inputFile
print(inputFile.readline()) 
#Print the next line of inputFile
print(inputFile.readline()) 

inputFile.close()

###

inputFile = open("OutputFile.txt", "r")

#Print the next line of inputFile
print(inputFile.readline().strip()) 
#Print the next line of inputFile
print(inputFile.readline().strip()) 
#Print the next line of inputFile
print(inputFile.readline().strip()) 

inputFile.close()

###

inputFile = open("OutputFile.txt", "r")

#Read the next line of inputFile, cast it 
#to int, and assign it to myInt1
myInt1 = int(inputFile.readline())  
#Read the next line of inputFile, cast it 
#to int, and assign it to myInt2
myInt2 = int(inputFile.readline())  
#Read the next line of inputFile, cast it 
#to int, and assign it to myInt3
myInt3 = int(inputFile.readline())  

print("myInt1:", myInt1)
print("myInt2:", myInt2)
print("myInt3:", myInt3)

inputFile.close()


### PROBLEM SET

#Write a function called search_in_files. search_in_files
#should have two parameters: a filename and a string to search for.
#search_in_files should return a list of line numbers as integers
#where the string appeared. Note that the string at that index does
#not need to BE the search string, but rather must just contain it.
#You should assume that the first line in a file is line 1, not line
#0.
#
#For example, if the files contents was:
#cat
#cats
#dog
#dogs
#catsup
#
#Then search_in_files("input_file.txt", "cat") would return
#[1, 2, 5], because "cat" appears on lines 1, 2, and 5.
#
#Make sure the list you return is sorted from lowest line number to
#highest.


#Add your code here!
def search_in_files(filename, string):
    my_list = []
    line_number = 1
    input_file = open(filename, "r")
    for line in input_file:
        if string in line:
            my_list.append(line_number)
        line_number += 1
    input_file.close()
    return my_list


#The code below will test your function. You can find the file it
#references in the drop-down in the top left. If your code works,
#this should print:
#[1, 2, 5]
#[3, 4]
#[2, 5]
#[5]
#[]
print(search_in_files("input_file.txt", "cat"))
print(search_in_files("input_file.txt", "dog"))
print(search_in_files("input_file.txt", "cats"))
print(search_in_files("input_file.txt", "sup"))
print(search_in_files("input_file.txt", "aardvark"))

###

#Write a function called "angry_file_finder" that accepts a
#filename as a parameter. The function should open the file,
#read it, and return True if the file contains "!" on every
#line. Otherwise the function should return False. 
#
#Hint: there are lots of ways to do this. We'd suggest using
#either the readline() or readlines() methods. readline()
#returns the next line in the file; readlines() returns a
#list of all the lines in the file.


#Write your function here!
def angry_file_finder(filename):
    file = open(filename, "r")
    contents = file.readlines()
    file.close() 

    for line in contents:
        if "!" not in line:
            return False
    return True
            

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: True
print(angry_file_finder("AngryFileFinderInput.txt"))

###

#Write a function called average_file. average_file should
#have one parameter: a filename.
#
#The file should have an integer on each line. average_file
#should return the average of these integers. However, if
#any of the lines of the file are _not_ integers,
#average_file should return the string "Error reading file!"
#
#Remember, by default, every time you read a line from a
#file, it's interpreted as a string.


#Add your function here!
def average_file(filename):
    file = open(filename, "r")
    contents = file.readlines()
    file.close()
    

    sum = 0
    count = 0
    for line in contents:
        try:
            num = int(line)
            sum += num
            count += 1
        except:
            return "Error reading file!"
    return sum / count
 

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 5.0, then Error reading file!
#
#You can select valid_file.txt and invalid_file.txt from
#the dropdown in the top left to preview their contents.
print(average_file("valid_file.txt"))
print(average_file("invalid_file.txt"))

###

#Write a function called st_dev. st_dev should have one
#parameter, a filename. The file will contain one integer on
#each line. The function should return the population standard
#deviation of those numbers.
#
#The formula for population standard deviation can be found here:
#edge.edx.org/asset-v1:GTx+gt-mooc-staging1+2018_T1+type@asset+block@stdev.PNG
#
#The formula is a bit complex, though, and since this is a
#CS class and not a math class, here are the steps you would
#take to calculate it manually:
#
# 1. Find the mean of the list.
# 2. For each data point, find the difference between that
#    point and the mean. Square that difference, and add it
#    to a running sum of differences.
# 4. Divide the sum of differences by the length of the
#    list.
# 5. Take the square root of the result.
#
#You may assume for this problem that the file will contain
#only integers -- you don't need to worry about invalid
#files or lines. The easiest way to take the square root is
#to raise it to the 0.5 power (e.g. 2 ** 0.5 will give the
#square root of 2).
#
#HINT: You might find this easier if you load all of the
#numbers into a list before trying to calculate the average.
#Either way, you're going to need to loop over the numbers
#at least twice: once to calculate the mean, once to
#calculate the sum of the differences.


#Add your function here!
def st_dev(filename):
    file = open(filename, "r")
    contents = file.readlines()
    file.close()
    
    sum = 0
    count = 0
    for line in contents:
        sum += int(line)
        count += 1
    mean = sum / count
    
    differences = []
    for line in contents:
        difference = mean - int(line)
        difference **= 2
        differences.append(difference)

    total = 0
    for num in differences:
        total += num
    sum_divided = total / count
    
    ans = sum_divided ** 0.5
    return ans
        

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print 27.796382658340438 (or something around there).
print(st_dev("some_numbers.txt"))

###

#Recall Coding Problem 4.3.9 (Advanced), the free body
#diagram problem. If you were unable to solve that, we've
#included the sample answer in the dropdown in the top left
#-- feel free to use that to write your answer to this
#problem.
#
#Revise your code from that problem to use a file instead of
#a list as its parameter. Name this new function
#find_net_force_from_file. The function should take one
#parameter, the name of a file. The function should return
#the net magnitude and direction, just as it did in the other
#problem.
#
#Each line of the file will have two numbers, both integers:
#the first number will be the magnitude, and the second
#number will be the angle (in degrees, from -180 to 180).
#There will be a space between them.
#
#HINT: You may have multiple functions in your code if you
#want!
#
#HINT 2: Try to write this such that you can reuse as much
#of your earlier code as possible. Remember, when loading
#from a file, any text you load is initially a string. You'll
#almost certainly need to use the split() method.

from math import sin, cos, tan, asin, acos, atan2, radians, degrees, sqrt

#Add your function here!
#First, we define the function:
 
    
def find_net_force(forces):    
    
    total_horizontal = 0
    total_vertical = 0
    
    for force in forces:
        
        magnitude, angle = force
        angle = radians(angle)
        horizontal = magnitude * cos(angle)
        vertical = magnitude * sin(angle)

        total_horizontal += horizontal
        total_vertical += vertical
    
    net_magnitude = sqrt(total_horizontal**2 + total_vertical**2)
    net_magnitude = round(net_magnitude, 1)
    
    net_angle = atan2(total_vertical, total_horizontal)
    net_angle = degrees(net_angle)
    net_angle = round(net_angle, 1)
    return (net_magnitude, net_angle)


def find_net_force_from_file(filename):
    file = open(filename, "r")
    forces = []
    for line in file:
        magnitude, angle = map(float, line.strip().split())
        forces.append((magnitude, angle))
    file.close()
                         
    result = find_net_force(forces)
    return result

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: (87.0, 54.4)
print(find_net_force_from_file("a_few_angles.txt"))

###

#Write a function called write_weird_file. write_weird_file
#should take two positional parameters. The first should be
#a filename, and the second should be a list. The function
#should also have three keyword parameters: mode, sort_first
#and reverse_first. The default value for mode should be "w",
#and the default values for both sort_first and reverse_first
#should be False.
#
#write_weird_file should write the contents of the list to
#the given filename. Each item from the list should be on a
#separate line. The list items could be strings, floats, 
#characters, or integers. If the mode is "w", it should
#overwrite the current contents; if the mode is "a", it
#should append to the current contents. You may assume there
#will be no other value for mode.
#
#If sort_first is True, it should sort the list before
#writing. If reverse_first is True, then it should reverse
#the list before writing. If both are True, it should sort,
#then reverse.


#Add your function here!
def write_weird_file(filename, my_list, mode = "w", sort_first = False, reverse_first = False):

    output_file = open(filename, mode)
    if sort_first == True:
        my_list.sort()
    if reverse_first == True:
        my_list.reverse()

    for item in my_list:
        print(item, file = output_file)

    return output_file
    output_file.close()

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print nothing. However, if you open the file called
#output.txt in the top left after running it, the contents
#of the file should be:
#Wait, where'd the other text go?
#It's gone!
#3
#2
#1
write_weird_file("output.txt", ["Hmm, I bet this text will disappear.", "I wonder where it will go?"])
write_weird_file("output.txt", ["Wait, where'd the other text go?", "It's gone!"])
write_weird_file("output.txt", [2, 1, 3], mode="a", sort_first=True, reverse_first=True)

###

#Write a function called multiply_file_by_index. This function
#should take two parameters, both strings. The first string is
#the filename of a file to which to write (output_file), and
#the second string is the filename of a file from which to read
#(input_file).
#
#In the input file, there will be an integer on every line.
#To the output file, you should write the integer from the
#original file multiplied by the line number on which it
#appeared. You should assume that the first line of the file
#is line 1 (which is different from a list, where the first item
#is at index 0).
#
#For example, if the input file contained this text:
#1
#4
#3
#7
#6
#
#Then the output file would contain this text:
#1
#8
#9
#28
#30


#Add your code here!
def multiply_file_by_index(output_file, input_file):
    input_file = open(input_file, "r")
    output_file = open(output_file, "w")
    contents = input_file.readlines()
    multiplier = 1
    for line in contents:
        num = int(line) * multiplier
        multiplier += 1
        print(num, file = output_file)
    input_file.close()
    output_file.close()
        
#The code below will test your function. You can find the two
#files it references in the drop-down in the top left. If your
#code works, output_file.txt should have the text:
#1
#8
#9
#28
#30
multiply_file_by_index("output_file.txt", "input_file.txt")
print("Done running! Check output_file.txt for the result.")

#If you accidentally erase input_file.txt, here's its original
#text to copy back in (remove the pound signs):
#1
#4
#3
#7
#6

###

#You've been sent a list of names. Unfortunately, the names
#come in two different formats:
#
#First Middle Last
#Last, First Middle
#
#You want the entire list to be the same. For this problem,
#we'll say you want the entire list to be First Middle Last.
#
#Write a function called name_fixer. name_fixer should have two
#parameters: an output filename (the first parameter) and the
#input filename (the second parameter). You may assume that every
#line will match one of the two formats above: either First Middle
#Last or Last, First Middle. 
#
#name_fixer should write to the output file the names all
#structured as First Middle Last. If the name was already structured
#as First Middle Last, it should remain unchanged. If it was
#structured as Last, First Middle, then Last should be moved
#to the end after a space and the comma removed.
#
#The names should appear in the same order as the original file.
#
#For example, if the input file contained the following lines:
#David Andrew Joyner
#Hart, Melissa Joan
#Cyrus, Billy Ray
#
#...then the output file should contain these lines:
#David Andrew Joyner
#Melissa Joan Hart
#Billy Ray Cyrus


#Add your code here!
def name_fixer(output_file, input_file):
    my_input = open(input_file, "r")
    my_output = open(output_file, "w")

    contents = my_input.readlines()
    for name in contents:
        name = name.strip()
        if "," not in name:
            print(name, file = my_output)
        elif "," in name:
            name_parts = name.split(", ")
            correct_name = name_parts[1] + " " + name_parts[0]
            print(correct_name, file = my_output)
    my_input.close()
    my_output.close()


#The code below will test your function. You can find the two
#files it references in the drop-down in the top left. If your
#code works, output_file.txt should have the text:
#David Andrew Joyner
#Melissa Joan Hart
#Billy Ray Cyrus
name_fixer("output_file.txt", "input_file.txt")
print("Done running! Check output_file.txt for the result.")

#If you accidentally erase input_file.txt, here's its original
#text to copy back in (remove the pound signs):
#David Andrew Joyner
#Hart, Melissa Joan
#Cyrus, Billy Ray

###






















### DICTIONARIES ###

#We've defined a list of tuples below. Each tuple follows
#the format: (name, home state).
#
#Create a dictionary called ta_dict in the space below, where
#the keys are each TA's name, and the values are their home
#state.

ta_info = [("Joshua", "Georgia"),
          ("Jackie", "Vermont"),
          ("Marguerite", "Tennessee")]

#Add your code to create the dictionary as described!
#The first item in each tuple should be a key, and
#the second item in each tuple should be its value.
#Note that you may create this either by reading and
#using the ta_info list of tuples, or you can create
#the dictionary from scratch:


#Create your dictionary here!
ta_dict = {"Joshua":"Georgia", "Jackie":"Vermont", "Marguerite":"Tennessee"}


#Now, create three variables: josh_val, jack_val, and
#marg_val. Set josh_val equal to Josh's dictionary value,
#then jack_val equal to Jackie's, then marg_val equal to
#Marguerite's. Remember how to properly access the value
#corresponding to a dictionary key!
#
#Make sure you use dictionary-access syntax to do this.
#Don't create the variables based on new values.

#Create your variables here!
josh_val = ta_dict["Joshua"]
jack_val = ta_dict["Jackie"]
marg_val = ta_dict["Marguerite"]

#If your code works as intended, the following three lines
#will run and print Georgia, Vermont, and Tennessee:
print(josh_val)
print(jack_val)
print(marg_val)

###

#Creates myDictionary with sprockets=5, widgets=11, cogs=3, and gizmos=15
myDictionary = {"sprockets" : 5, "widgets" : 11, "cogs" : 3, "gizmos": 15}
print(myDictionary)
myDictionary["sprockets"] += 1
print(myDictionary)

###

#Creates myDictionary with sprockets=5, widgets=11, cogs=3, and gizmos=15
myDictionary = {"sprockets" : 5, "widgets" : 11, "cogs" : 3, "gizmos": 15}
print(myDictionary)
myDictionary["sprockets"] += 1
print(myDictionary)

###

#Create a function called tup_to_dict. tup_to_dict should take one
#parameter: a list of tuples. You can assume each tuple in
#the list has exactly two values.
#
#The function should return a dictionary where the first item
#in each tuple is the key, and the second item in each tuple
#is the corresponding value.
#
#For example:
# colors = [("turquoise", "#40E0D0"), ("red", "#990000")]
# tup_to_dict(colors) -> {"turquoise":"#40E0D0", "red":"#990000"}
#
#Hint: the previous exercise is very similar; this just turns
#it into a function! All our tuples will be color name-color
#value pairs.


#Write your function here!
def tup_to_dict(tuple_list):
    dictionary = {}
    for list in tuple_list:
        dictionary[list[0]] = list[1]
    return dictionary


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:  {'Turquoise':'#40E0D0', 'Red':'#990000'}
#
#Don't worry if it prints those in the reverse order; that's
#still correct!
print(tup_to_dict([("Turquoise", "#40E0D0"), ("Red", "#990000")]))

###

#Creates myDictionary with sprockets=5, widgets=11, cogs=3, and gizmos=15
myDictionary = {"sprockets" : 5, "widgets" : 11,
                "cogs" : 3, "gizmos": 15}
print(myDictionary)

#Creates the new key "gadgets" with value 1
myDictionary["gadgets"] = 1   
print(myDictionary)
del myDictionary["gadgets"]
print(myDictionary)

###

#Creates myDictionary with David=4045551234, Lucy=4045555678, 
#Vrushali=4045559101
myDictionary = {"David" : "4045551234", "Lucy" : "4045555678",
                "Vrushali" : "4045559101"}
print(myDictionary)

#Checks if "David" is a key in the dictionary
if "David" in myDictionary: 
    print("David is already in myDictionary!")
    myDictionary["David2"] = "4045551121"
else:  
    myDictionary["David"] = "4045551121"
print(myDictionary)

###

#Creates myDictionary with #David=4045551234, Lucy=4045555678, #Vrushali=4045559101
myDictionary = {"David" : "4045551234", "Lucy" : "4045555678",
                "Vrushali" : "4045559101"}
print(myDictionary["Dana"])

###

#Write a function called students_present. students_present
#should take as input one parameter, a dictionary. The keys
#of the dictionary will be names, and the values will be one
#of three strings: "Here", "Present", or an empty string "".
#
#Return a list of the keys for whom the corresponding value
#is either "Here" or "Present".


#Add your code here!
def students_present(dictionary):
    students_present = []
    for (student, status) in dictionary.items():
        if status == "Here" or status == "Present":
            students_present.append(student)
    return students_present


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#["David", "Marguerite", "Joshua", "Erica"]

student_list = {"David" : "Here", "Marguerite" : "Here",
                "Jackie": "", "Joshua": "Present",
                "Erica": "Here", "Daniel": ""}
print(students_present(student_list))

###

#Creates myDictionary with sprockets=5, widgets=11, cogs=3, gizmos=15, 
#gadgets=1
myDictionary = {"sprockets" : 5, "widgets" : 11, "cogs" : 3, "gizmos" : 15,
                "gadgets" : 1}
for value in myDictionary.values():
    if value < 5:
        print("A value less than 5 was found:", value)

###

#Creates myDictionary with sprockets=5, widgets=11, cogs=3, gizmos=15, 
#gadgets=1
myDictionary = {"sprockets" : 5, "widgets" : 11, "cogs" : 3, "gizmos" : 15, 
                "gadgets" : 1}
for key in myDictionary.keys():
    value = myDictionary[key]
    if value < 5:
        print(key, "is less than 5:", value)

###

#Creates myDictionary with sprockets=5,
#widgets=11, cogs=3, gizmos=15, gadgets=1
myDictionary = {"sprockets" : 5, "widgets" : 11,
                "cogs" : 3, "gizmos" : 15, "gadgets" : 1}
for (key, value) in myDictionary.items():
    if value < 5:
        print(key, "is less than 5:", value)

###

#Write a function called name_counts. name_counts will take
#as input a list of full names. Each name will be two words
#separated by a space, like "David Joyner".
#
#The function should return a dictionary. The keys to the
#dictionary will be the first names from the list, and the
#values should be the number of times that first name
#appeared.
#
#HINT: Use split() to split names into first and last.


#Add your function here!
def name_counts(name_list):
    dictionary = {}
    for name in name_list:
        first_name = name.split()[0]
        if first_name in dictionary:
            dictionary[first_name] += 1
        else:
            dictionary[first_name] = 1
    return dictionary
        
#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#{'Shelba': 5, 'Maren': 1, 'Nicol': 1, 'David': 2, 'Brenton': 2}
name_list = ["David Joyner", "David Zuber", "Brenton Joyner",
             "Brenton Zuber", "Nicol Barthel", "Shelba Barthel",
             "Shelba Crowley", "Shelba Fernald", "Shelba Odle",
             "Shelba Fry", "Maren Fry"]
print(name_counts(name_list))

###

myString = "This is the string whose words we would like to count. This string contains some repeated words, as well as some unique words. It contains punctuation, and it contains words that are capitalized in different ways. If the method we write runs correctly, it will count 4 instances of the word 'it', 3 instances of the word 'this', and 3 instances of the word 'count'."

myString = myString.replace(".","") #Remove periods
myString = myString.replace(",","") #Remove commas
myString = myString.replace("'","") #Remove apostrophes
myString = myString.lower() #Make all lower case
mySplitString = myString.split() #Split by spaces

wordDictionary = {} #Create empty dictionary
for word in mySplitString:  #For each word in the split string
    if word in wordDictionary:  #If it's already been found...
        wordDictionary[word] += 1   #Add one to its count
    else:   #Otherwise...
        wordDictionary[word] = 1 #Create it with value 1

print(wordDictionary)

###

seatingChart = {"David" : 3, "Lucy" : 3, "Dana" : 2,
                "Addison" : 2, "Vrushali" : 1, "Bilbo" : 3,
                "Sara" : 1, "Lugos" : 1, "Mireia" : 1,
                "Partha" : 2, "Venijamin" : 1, "Terra" : 2, 
                "Tryphon" : 3, "Gevorg" : 1, "Raza" : 3,
                "Rein" : 3, "Sofia" : 2, "Perle" : 2}

#For each name, table pair in the seating chart
for (name, table) in seatingChart.items():  
    #Print the table for the name
    print(name, " is seated at table #", table, sep="")  

print()
#For each table number
for i in range(1, 4):   
    print("The guests at table #", i, " are: ", sep="", end="")
    #For each name, table pair
    for (name, table) in seatingChart.items():  
        #If the table numer is this number
        if i == table:  
            #Print the name
            print(name, end=" ")    
    print()

###

#Recall in the previous problem you counted the number of
#instances of a certain first name in a list of full names.
#You returned a dictionary with the name as the key, and the
#number of times it appeared as the value.
#
#Modify that code such that instead of having a count as the
#value, you instead have a list of the full names that had
#that first name. So, each key in the dictionary would still
#be a first name, but the values would be lists of names.
#Make sure to sort the list of names, too.
#
#Name this new function name_lists.


#Add your function here!
def name_lists(names):
    name_dict = {}
    for name in names:
        split_name = name.split()
        first_name = split_name[0]
        if not first_name in name_dict:
            name_dict[first_name] = []
        name_dict[first_name].append(name)
    for first_name, full_names in name_dict.items():
        full_names.sort()
    return name_dict


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#{'Shelba': ['Shelba Barthel', 'Shelba Crowley', 'Shelba Fernald', 'Shelba Fry', 'Shelba Odle'],
#'David': ['David Joyner', 'David Zuber'], 'Brenton': ['Brenton Joyner', 'Brenton Zuber'],
#'Maren': ['Maren Fry'], 'Nicol': ['Nicol Barthel']}

name_list = ["David Joyner", "David Zuber", "Brenton Joyner",
             "Brenton Zuber", "Nicol Barthel", "Shelba Barthel",
             "Shelba Crowley", "Shelba Fernald", "Shelba Odle",
             "Shelba Fry", "Maren Fry"]
print(name_lists(name_list))

###

classes = {"Math" : ["David", "Lucy", "Dana"],
           "Physics" : ["Addison", "Vrushali", "Bilbo"],
           "Chemistry" : ["Sara", "Lugos", "Mireia", "Perle"],
           "Computing" : ["Partha", "Venijamin", "Terra", "Sofia"],
           "History" : ["Tryphon", "Gevorg", "Raza", "Rein"]}

print("Students in Computing:", classes["Computing"])
#Add Francis to History
classes["History"].append("Francis")    
print("Students in History:", classes["History"])

###

addressBook = {"David": ("555 Home St", "4045551234", "david@david.com"),
               "Lucy" : ("555 Home St", "4045555678", "lucy@lucy.com"),
               "Dana" : ("123 There Rd", "4045559101", "dana@dana.net")}

print("David's Information:", addressBook["David"])
print("Dana's Phone Number:", addressBook["Dana"][1])

###

addressBook = {"David": {"address" : "555 Home St", "phone" : "4045551234", 
                          "email" : "david@david.com"},
               "Lucy" : {"address" : "555 Home St", "phone" : "4045555678", 
                         "email" : "lucy@lucy.com"},
               "Dana" : {"address" : "123 Here Rd", "phone" : "4045559101", 
                         "email" : "dana@dana.net"}}

print("David's Information:", addressBook["David"])
print("Dana's Phone Number:", addressBook["Dana"]["phone"])

###

ANSWER_KEY = {"1" : "A", "2" : "B", "3" : "C", "4" : "D", "5" : "A"}

students={}
students["David"] = {"1" : "A", "2" : "B", "3" : "A", "4" : "B", "5" : "C"}
students["Terra"] = {"1" : "A", "2" : "B", "3" : "C", "4" : "D", "5" : "A"}
students["Lugos"] = {"1" : "A", "2" : "C", "3" : "C", "4" : "D", "5" : "A"}

#For each student and their answers
for (student, answers) in students.items(): 
    grade = 0   #Start grade at 0
    #For each question and answer
    for (question, answer) in answers.items():  
        #If the answer matches ANSWER_KEY's answer...
        if answer == ANSWER_KEY[question]:  
            grade +=1   #Increment their grade
    #Create a new key "grade" and assign it their grade
    students[student]["grade"] = grade  
#For each student and their answers
for (student, answers) in students.items(): 
    #Print the name and grade
    print(student, ": ", answers["grade"], sep = "", end = "; ")


### PROBLEM SET

#-----------------------------------------------------------
#Let's get back to basics for a moment. We're going to write
#a function that very simply reads a dictionary and returns
#a result.
#
#Write a function called safe_lookup. safe_lookup should have
#two parameters: a dictionary and a key. safe_lookup should
#see if the key is in the dictionary. If it is, it should
#return its value. If it not, it should return None (not the
#string, but the value None: return None).
#
#safe_lookup might be used to avoid having to add error
#handling every time a dictionary is used. A programmer could
#call safe_lookup(dict, key) and know that it will not cause
#an error even if key is not found.


#Add your code here!
def safe_lookup(dictionary, key):
    if key in dictionary:
        return dictionary[key]
    return None


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#1
#2
#3
#None
test_dictionary = {"A": 1, "B": 2, "C": 3}
print(safe_lookup(test_dictionary, "A"))
print(safe_lookup(test_dictionary, "B"))
print(safe_lookup(test_dictionary, "C"))
print(safe_lookup(test_dictionary, "D"))

###

#One of the confusing things about dictionaries is that they
#are unordered: the keys have no internal ordering to them.
#Sometimes though, you want to look through the keys in a
#particular order, such as printing them alphabetically if
#they represent something like artist names.
#
#For example, imagine if a forum tool used for a course
#exported its data as a dictionary. The keys of the dictionary
#are students' names, and the values are days of activity.
#Your goal is to return a list of students in the class
#in alphabetical order, followed by their days of activity,
#like this:
#Chopra, Deepak: 22
#Joyner, David: 14
#Winfrey, Oprah: 17
#
#Write a function named alphabetical_keys. alphabetical_keys
#should take as input a dictionary, and return a single string.
#The keys of the dictionary will be names and the values will
#be integers. The output should be a single string made of multiple
#lines, following the format above: the name (the key), a colon and
#space, then the number of days of activity (the value), sorted
#alphabetically by key.
#
#Remember, you are _returning_ this as a single string: you're
#going to need to put the \n character after each line.
#
#To convert a dictionary's keys into a list, use this line
#of code:
#keys_as_list = list(the_dict.keys)
#
#From there, you could sort keys_as_list like any normal list.


#Add your code heredef alphabetical_keys(dictionary):
def alphabetical_keys(dictionary):
    my_list = []
    my_string = ""
    for (key, value) in dictionary.items():
        my_list.append(key + ": " + str(value))
    my_list.sort()
    for item in my_list:
        my_string += item + "\n"
    return my_string


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#Chopra, Deepak: 22
#Joyner, David: 14
#Winfrey, Oprah: 17
the_dictionary = {"Joyner, David": 14, "Chopra, Deepak": 22, "Winfrey, Oprah": 17}
print(alphabetical_keys(the_dictionary))

###

#Write a function called most_active. most_active should take
#one parameter, a dictionary. The dictionary's keys will all
#be strings representing people's names. The dictionary's
#values will be integers representing days of activity on a
#course forum.
#
#most_active should return the name of the most active student
#in the class. That is, most_active should return the key
#whose value is the highest in the dictionary.
#
#For example:
#
#some_dictionary = {"Joyner, David": 14, "Chopra, Deepak": 22, "Winfrey, Oprah": 17}
#most_active(some_dictionary) -> "Chopra, Deepak"
#
#The key "Chopra, Deepak" has the highest value (22), so
#the function returns "Chopra, Deepak". You may assume
#there will not be a tie for most active.


#Add your code here!
def most_active(dictionary):
    max_days = 0
    student = ""
    for name, days in dictionary.items():
        if days > max_days:
            max_days = days
            student = name
    return student


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#Chopra, Deepak
some_dictionary = {"Joyner, David": 14, "Chopra, Deepak": 22, "Winfrey, Oprah": 17}
print(most_active(some_dictionary))

###

#In the previous problem, you were given a dictionary where
#the keys were names and the values were days of activity
#on a class forum. You returned the name of the most active
#student; or, more simply, the key corresponding to the
#highest value.
#
#In this problem, you'll do the same thing, but with a more
#complex data structure. Your function should be called
#most_active, and it should have one parameter.
#
#Instead of a dictionary, your parameter is a list of
#dictionaries. Every dictionary in the list will have exactly
#two keys: 'name' and 'days_active'. Your goal, as before,
#is to return the name of the most active student.
#
#Some of the code you wrote on the previous problem will be
#reusable, but you'll need to modify it.
#
#Hint: you do NOT need to iterate over the keys in the
#dictionaries inside the lists. You can always just access
#the_dict["name"] and the_dict["days_active"] directly.
#Your only loop should be the loop over the list.


#Add your code here!
def most_active(list_of_dictionaries):
    max_days = 0
    student = ""
    for dictionary in list_of_dictionaries:
        days_active = dictionary["days_active"]
        if days_active > max_days:
            max_days = days_active
            student = dictionary["name"]
    return student


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#Chopra, Deepak
the_list = [{"name": "Joyner, David", "days_active": 14},
            {"name": "Chopra, Deepak", "days_active": 22},
            {"name": "Winfrey, Oprah", "days_active": 17}]
print(most_active(the_list))

###

#Write a function called phonebook that takes two lists as
#input:
#
# - names, a list of names as strings
# - numbers, a list of phone numbers as strings
#
#phonebook() should take these two lists and create a
#dictionary that maps each name to its phone number. For
#example, the first name in names should become a key in
#the dictionary, and the first number in numbers should
#become the value corresponding to the first name. Then, it
#should return the dictionary that results.
#
#Hint: Because you're mapping the first name with the first
#number, the second name with the second number, etc., you do
#not need two loops. For a similar exercise, check back on
#Coding Problem 4.3.3, the Scantron grading problem.
#
#You may assume that the two lists have the same number of
#items: there will be no names without numbers or numbers
#without names.


#Write your function here!
def phonebook(name_list, number_list):
    dictionary = {}
    for i in range(len(name_list)):
        dictionary[name_list[i]] = number_list[i]
    return dictionary


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#{'Jackie': '404-555-1234', 'Joshua': '678-555-5678', 'Marguerite': '770-555-9012'

name_list = ['Jackie', 'Joshua', 'Marguerite']
number_list = ['404-555-1234', '678-555-5678', '770-555-9012']
print(phonebook(name_list, number_list))

###

#Do not change the line of code below. It's at the top of
#the file to ensure that it runs before any of your code.
#You will be able to access french_dict from inside your
#function.
french_dict = {"me": "moi", "hello": "bonjour", 
               "goodbye": "au revoir", "cat": "chat", 
               "dog": "chien", "and": "et"}

#Write a function called french2eng that takes in one string
#parameter called sentence. french2eng should look at each
#word in the sentence and translate it into French if it is
#found in the dictionary, french_dict. If a word is not found
#in the dictionary, do not translate it: use the original
#word. Then, the function should return a string of the
#translated sentence.
#
#You may assume that the sentence you're translating has no
#punctuation. However, you should convert it to lower case
#before translating.
#
#For example:
#
#  french2eng("Hello it's me") -> "bonjour it's moi"
#
#Hint: Use .split() to get a list of strings representing
#each word in the string, then use ' '.join to merge the
#translated list back into one string.
#
#Hint 2: Remember, lists are mutable, so we can change
#individual items in the list. However, to change an item
#in a list, we must change it using its index. We can
#write lines like my_words[1] = new_word.
#
#Hint 3: If you're stuck, try breaking it down into small
#parts. How do you access an item from a list? How do you
#look up a key in a dictionary? How do you change the
#value of an item in a list? How do you check if a key is
#in the dictionary?


#Write your function here!
def french2eng(sentence):
    my_list = sentence.lower().split()
    translated_words = []
    for word in my_list:
        if word in french_dict:
            translated_words.append(french_dict[word])
        if word not in french_dict:
            translated_words.append(word)
    return ' '.join(translated_words)
        

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: bonjour it's moi
print(french2eng("Hello it's me"))

###

#Write a function called course_info that takes as input a
#list of tuples. Each tuple contains two items: the first
#item in each tuple is a student's name as a string, and the
#second item in each tuple is that student's age as an
#integer.
#
#The function should return a dictionary with two keys.
#The key "students" should have as its value a list of all
#the students (in other words, a list made from the first
#value of each tuple), in the original order in which they
#appeared in the list. The key "avg_age" should have as its
#value a float representing the average age of all the
#students in the list (in other words, the average of all
#the second items in the tuples).
#
#For example:
#
#  course_info([("Jackie", 20), ("Marguerite", 21)])
#  -> {"students": ['Jackie', 'Marguerite'], "avg_age": 20.5}
#
#Hint: Concentrate first on building the list of students
#and calculating the average age. Save creating the
#dictionary for last.


#Write your function here!
def course_info(list_of_tuples):
    my_dictionary = {}
    students = []
    sum = 0
    count = 0
    for my_tuple in list_of_tuples:
        sum += my_tuple[1]
        count += 1
        students.append(my_tuple[0])
    avg_age = sum / count
    
    my_dictionary["students"] = students
    my_dictionary["avg_age"] = avg_age
    
    return my_dictionary
    

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#{'avg_age': 20.5, 'students': ['Jackie', 'Marguerite']}
print(course_info([("Jackie", 20), ("Marguerite", 21)]))

###

#Write a function called modify_dict. modify_dict takes one
#parameter, a dictionary. The dictionary's keys are people's
#last names, and the dictionary's values are people's first
#names. For example, the key "Joyner" would have the value
#"David".
#
#modify_dict should delete any key-value pair for which the
#key's first letter is not capitalized. For example, the
#key-value pair "joyner":"David" would be deleted, but the
#key-value pair "Joyner":"david" would not be deleted. Then,
#return the modified dictionary.
#
#Remember, the keyword del deletes items from lists and
#dictionaries. For example, to remove the key "key!" from
#the dictionary my_dict, you would write: del my_dict["key!"]
#Or, if the key was the variable my_key, you would write:
#del my_dict[my_key]
#
#Hint: If you try to delete items from the dictionary while
#looping through the dictionary, you'll run into problems!
#We should never change the number if items in a list or
#dictionary while looping through those items. Think about
#what you could do to keep track of which keys should be
#deleted so you can delete them after the loop is done.
#
#Hint 2: To check if the first letter of a string is a
#capital letter, use string[0].isupper().


#Write your function here!
def modify_dict(my_dict):
    new_dictionary = {}
    for first_name, last_name in my_dict.items():
        if first_name != first_name.lower():
            new_dictionary[first_name] = last_name
    return new_dictionary
    #del my_dict[""]


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#  {'Diaddigo':'Joshua', 'Elliott':'jackie'}
my_dict = {'Joshua':'Diaddigo', 'joyner':'David', 'Elliott':'jackie', 'murrell':'marguerite'}
print(modify_dict(my_dict))

###

#Write a function called clean_data. clean_data takes one
#parameter, a dictionary. The dictionary represents the
#observed rainfall in inches on a particular calendar day
#at a particular location. However, the data has some
#errors.
#
#clean_data should delete any key-value pair where the value
#has any of the following issues:
#
# - the type is not an integer or a float. Even if the value
#   is a string that could be converted to an integer (e.g.
#   "5") it should be deleted.
# - the value is less than 0: it's impossible to have a
#   negative rainfall number, so this must be bad data.
# - the value is greater than 100: the world record for
#   rainfall in a day was 71.8 inches
#
#Return the dictionary when you're done making your changes.
#
#Remember, the keyword del deletes items from lists
#and dictionaries. For example, to remove the key "key!" from
#the dictionary my_dict, you would write: del my_dict["key!"]
#Or, if the key was the variable my_key, you would write:
#del my_dict[my_key]
#
#Hint: If you try to delete items from the dictionary while
#looping through the dictionary, you'll run into problems!
#We should never change the number if items in a list or
#dictionary while looping through those items. Think about
#what you could do to keep track of which keys should be
#deleted so you can delete them after the loop is done.
#
#Hint 2: To check if a variable is an integer, use
#type(the_variable) == int. To check if a variable is a float,
#use type(the_variable) == float.


#Write your function here!
def clean_data(my_dict):
    new_dictionary = {}
    final_dictionary = {}
    for key, value in my_dict.items():
        if type(value) == float or type(value) == int:
            new_dictionary[key] = value
    for key, value in new_dictionary.items():
        if 0 <= value < 100:
            final_dictionary[key] = value
    return final_dictionary
    

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#{"20190101": 5, "20190103": 7.5, "20190104": 0, "20190107": 1}
rainfall = {"20190101": 5, "20190102": "6", "20190103": 7.5, 
           "20190104": 0, "20190105": -7, "20190106": 102,
           "20190107": 1}
print(clean_data(rainfall))

###

#In the Pokemon video game series, every Pokemon has six
#stats: HP, Attack, Defense, Special Attack, Special Defense,
#and Speed.
#
#Write a function called total_stats that will take as input
#a list of dictionaries. Each dictionary will have seven
#key-value pairs:
#
# - name: a Pokemon's name
# - hp, attack, defense, special attack, special defense,
#   and speed: an integer representing that Pokemon's stat
#   in that category
#
#Your function should return a single dictionary. The keys
#of the dictionary should be the Pokemon names from the
#original list, and the values should be the _total_ stats
#for each Pokemon (add HP, Attack, Defense, Special Attack,
#Special Defense, and Speed).
#
#For example, if this was one of the dictionaries in the
#original list:
#
#{"name": "Bulbasaur", "hp": 45, "attack": 49, "defense": 49,
#"special attack": 65, "special defense": 65, "speed": 45}
#
#Then one of the key-value pairs in the dictionary you
#return would be: "Bulbasaur": 318 (45 + 49 + 49 + 65 + 65 +
#45 = 318).


#Add your function here!
def total_stats(list_of_dictionaries):
    new_dict = {}
        
    for dictionary in list_of_dictionaries:
        pokemon = dictionary["name"]
        sum = 0
        for key, value in dictionary.items():
            if type(value) == int:
                sum += value
            new_dict[pokemon] = sum     
    return new_dict


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#{'Bulbasaur': 318, 'Charmander': 309, 'Squirtle': 314}
starters = [{"name": "Bulbasaur", "hp": 45, "attack": 49, "defense": 49, "special attack": 65, "special defense": 65, "speed": 45},
            {"name": "Charmander", "hp": 39, "attack": 52, "defense": 43, "special attack": 60, "special defense": 50, "speed": 65},
            {"name": "Squirtle", "hp": 44, "attack": 48, "defense": 65, "special attack": 50, "special defense": 64, "speed": 43}]
print(total_stats(starters))

###

#Write a function called population_density. The function
#should take one parameter, which will be a list of
#dictionaries. Each dictionary in the list will have three
#key-value pairs:
#
# - name: the name of the country
# - population: the population of that country
# - area: the area of that country (in km^2)
#
#Your function should return the population density of all
#the countries put together. You can calculate this by
#summing all the populations, summing all the areas, and
#dividing the total population by the total area.
#
#Note that the input to this function will look quite long;
#don't let that scare you. That's just because dictionaries
#take a lot of text to define.


#Add your function here!
def population_density(list_of_dictionaries):
    pop_sum = 0
    area_sum = 0
    
    for dictionary in list_of_dictionaries:
        name_value = dictionary["name"]
        population_value = dictionary["population"]
        area_value = dictionary["area"]
        
        pop_sum += population_value
        area_sum += area_value
        
    density = pop_sum / area_sum
    return density


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 133.886 (or something around there)
countries = [{"name": "China", "population": 1390700000, "area": 9640821},
             {"name": "India", "population": 1348003000, "area": 3287240},
             {"name": "United States", "population": 325300000, "area": 9826675},
             {"name": "Indonesia", "population": 237556363, "area": 1904569}]
print(population_density(countries))
             
###


























### PRACTICE PROBLEMS ###

#Write a function called count_characters. count_characters
#should take as input a single string, and return a
#dictionary. In the dictionary, the keys should be
#characters, and the values should be the number of times
#each character appeared in the string.
#
#For example:
#
#  count_characters("aabbccc") -> {'a': 2, 'b': 2, 'c': 3}
#  count_characters("AaBbbb") -> {'A': 1, 'B': 1, 'a': 1, 'b': 3}
#
#You should not need to make any assumptions about the
#characters in the string: spaces, punctuation, line breaks,
#and any other characters should be handled automatically.
#You may count upper and lower case separately.


#Write your function here!
def count_characters(string):
    dictionary = {}
    for letter in string:
        if letter in dictionary:
            dictionary[letter] += 1
        else:
            dictionary[letter] = 1
    return dictionary


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#
#{'a': 2, 'b': 2, 'c': 3}
print(count_characters("aabbccc"))


### PROBLEM SET 1 ###

## Practice problem 1

#Write a function called count_types. count_types
#should take as input a single string, and return a
#dictionary. In the dictionary, the keys should be
#types of characters, and the values should be the
#number of times each type of character appeared in
#the string.
#
#The types of characters that should be handled (and
#thus, the keys in the dictionary) are:
#
# - upper: the count of upper-case or capital letters
# - lower: the count of lower-case letters
# - punctuation: the count of punctuation characters.
#   You may assume this is limited to these punctuation
#   characters: !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
# - space: the count of spaces
# - numeral: the count of numerals, 0123456789
#
#Note, however, that any type of character that does
#NOT appear in the string should not be in the dictionary
#at all.
#
#For example:
#
#count_characters("aabbccc") -> 
# {"lower": 7}
#count_characters("ABC 123 doe ray me!") -> 
# {"upper": 3, "lower": 8, "punctuation": 1, "space": 4, "numeral": 3}
#
#Because the first string has only lower-case letters,
#"lower" is the only key in the dictionary.
#
#HINT: If you're sing the ord() function, capitals of
#ordinals between 65 and 90; lower-case letters have
#ordinals between 97 and 122; numerals are between 48
#and 57; spaces are 32; all other numbers between 33
#and 126 are punctuations, and no character will have
#an ordinal outside that range.


#Write your function here!
def count_types(string):
    dictionary = {}
    upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    lower = "abcdefghijklmnopqrstuvwxyz"
    punctuation = '''!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~'''
    space = " "
    numeral = "0123456789"
    for char in string:
        if char in upper:
            dictionary["upper"] = dictionary.get("upper", 0) + 1
        elif char in lower:
            dictionary["lower"] = dictionary.get("lower", 0) + 1
        elif char in punctuation:
            dictionary["punctuation"] = dictionary.get("punctuation", 0) + 1
        elif char in space:
            dictionary["space"] = dictionary.get("space", 0) + 1
        elif char in numeral:
            dictionary["numeral"] = dictionary.get("numeral", 0) + 1
    return dictionary    

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#
#{"lower": 7}
#{"upper": 3, "lower": 8, "punctuation": 1, "space": 4, "numeral": 3}
print(count_types("aabbccc"))
print(count_types("ABC 123 doe ray me!"))


## Practice problem 2

#Write a function called write_movie_info. write_movie_info
#will take as input two parameters: a string and a
#dictionary.
#
#The string will represent the filename to which to write.
#
#The keys in the dictionary will be strings representing
#movie titles. The values in the dictionary will be lists
#of strings representing performers in the corresponding
#movie.
#
#write_movie_info should write the list of movies to the file
#given by the filename using the following format:
#
# Title: Actor 1, Actor 2, Actor 3, etc.
#
#The movies and the actor names should be sorted
#alphabetically.
#
#So, for this dictionary:
#
# {"Chocolat": ["Juliette Binoche", "Judi Dench", "Johnny Depp", "Alfred Molina"],
#  "Skyfall": ["Judi Dench", "Daniel Craig", "Javier Bardem", "Naomie Harris"]}
#
#The file printed would look like this:
#
# Chocolat: Alfred Molina, Johnny Depp, Judi Dench, Juliette Binoche
# Skyfall: Daniel Craig, Javier Bardem, Judi Dench, Naomie Harris
#
#HINT: the keys() method of a Dictionary will return a list
#of the dictionary's keys. So, to get a sorted list of a_dict's
#keys, you could call key_list = a_dict.keys(), then call 
#key_list.sort().


#Write your function here!
def write_movie_info(filename, dictionary):
    file = open(filename, "w")
    for movie in sorted (dictionary):
        file.write(movie + ": ")
        dictionary[movie].sort()
        for actor in range(0, len(dictionary[movie]) - 1):
            file.write(dictionary[movie][actor] + ", ")
        file.write(dictionary[movie][len(dictionary[movie]) - 1] + "\n")
    file.close()
    return        
        

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print nothing -- however, it should write the same contents
#as Sample.txt to Test.txt.
movies = {"Chocolat": ["Juliette Binoche", "Judi Dench", "Johnny Depp", "Alfred Molina"], "Skyfall": ["Judi Dench", "Daniel Craig", "Javier Bardem", "Naomie Harris"]}
write_movie_info("Test.txt", movies)


## Practice problem 3

#Imagine you're writing the code for an onboard vehicle
#monitoring system. One thing the system does is measure
#tire pressure. It does this by taking a measurement every
#10 seconds. However, lots of environmental conditions can
#lead to intermittent bad readings: if it takes a reading
#as a car goes over a bump, for example, it will be way
#higher than it would have been otherwise. So, the system
#needs to know to ignore these ratings, as well as only
#process the more recent measurements. Let's tell the system
#that the only valid tire pressures are between 15 and 55.
#
#Write a function called tire_pressure. tire_pressure
#should have one parameter, a list of integers. The list
#represents a series of tire pressure measurements over the
#past several minutes.
#
#tire_pressure should return the average of the last 5
#measurements that are greater than or equal to 15 and less
#than or equal to 55. Round the result to 1 decimal place
#(you can use round(some_float, 1) to round to 1 decimal
#place).
#
#For example, if the list of measurements was this:
#
# [34, 34, 64, 34, 5, 5, 34, 34, 35, 35, 35, 65, 60, 35, 12, 35]
#
#tire_pressure would return 35.0: the last five measurements
#in range are all 35. You may assume there will be at least
#5 measurements in the proper range.


#Add your code here!
def tire_pressure(a_list):
    last_five = []
    count = 0
    a_list.reverse()
    for measurement in a_list:
        if measurement >= 15 and measurement <= 55:
            last_five.append(measurement)
            count += 1
            if count == 5:
                break
    return (sum(last_five) / 5)          


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 35.0
a_list = [45, 44, 8, 43, 43, 43, 41, 41]
print(tire_pressure(a_list))


## Practice problem 4

#Write a function called find_median. find_median
#should take as input a string representing a filename.
#The file corresponding to that filename will be a list
#of integers, one integer per line. find_median should
#return the median of the numbers in the file.
#
#If there is an odd number of values in the file, then
#find_median will return the middle value from the numbers
#in the file after they're sorted.
#
#If there is an even number of values in the file, then
#find_median should return the average of the two middle
#values after they're sorted.
#
#For example, in the dropdown in the top left you'll find a
#file named FindMedianInput.txt. There are 19 numbers in
#this file, so the median is the value at index 10 after
#sorting them: 16.
#
#You may assume that all lines in the file will contain a
#positive integer (greater than 0). There may be duplicates.


#Write your function here!
def find_median(filename):
    file = open(filename, "r")
    numbers = []
    for line in file:
        numbers.append(int(line.strip()))
    numbers.sort()
    if len(numbers) % 2 == 1:
        median_index = len(numbers) // 2
        median = numbers[median_index]
    else:
        median_index_1 = len(numbers) // 2 - 1
        median_index_2 = len(numbers) // 2
        median = (numbers[median_index_1] + numbers[median_index_2]) / 2
    return median


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 16
print(find_median("FindMedianInput.txt"))


## Practice problem 5

#Write a function called next_fib. next_fib should take
#have two parameters: a list of integers and a single integer.
#For this description, we'll call the single integer n.
#
#next_fib should modify the list to add the next n pseudo-
#Fibonacci numbers to the end of the sequence. A pseudo-
#Fibonacci number is the sum of the previous two numbers in
#the sequence, but in our case, the previous two numbers may
#not be the original numbers from the Fibonacci sequence.
#
#For example, if the original list given was:
#
# a_list = [5, 5, 10, 15, 25, 40, 65]
#
# Then next_fib(a_list, 3) would return:
#       [5, 5, 10, 15, 25, 40, 65, 105, 170, 275]
#
#All the original numbers in the list are still there, and
#three new ones have been added.
#
#You may assume the list parameter will always have at least
#two numbers.
#
#HINT: Python gets mad if you try to change a list while
#iterating over it with a for-each loop. You'll have to get
#clever with a for or while loop to do this!


#Add your code here!
def next_fib(a_list, n):
    count = 0
    while count < n:
        a_list.append(sum(a_list[-2:]))
        count += 1
    return a_list


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#[5, 5, 10, 15, 25, 40, 65, 105, 170, 275] 
a_list = [5, 5, 10, 15, 25, 40, 65]
print(next_fib(a_list, 3))


## Practice problem 6

#Write a function called abstract_names. abstract_names
#should have one parameter: a list of lists. Each list will
#be a list of strings, each with a first name and a last
#name, and each with the same first name.
#
#For example, this could be one list of lists your function
#might receive:
#
# [["David Joyner", "David Tennant", "David Beckham"],
#  ["Ananya Birla", "Ananya Agarwal", "Ananya Chatterjee", "Ananya Roy"],
#  ["Inés Sainz", "Inés Suarez", "Inés Melchor"]]
#
#abstract_names should return a dictionary. The keys to the
#dictionary should be the first names, and the values should
#be lists of the associated last names. The last names should
#be sorted alphabetically.
#
#For example, with the list above, the dictionary returned by
#abstract_names would be:
#
# {"David": ["Beckham", "Joyner", "Tennant"],
#  "Ananya": ["Agarwal", "Birla", "Chatterjee", "Roy"],
#  "Inés": ["Melchor", "Sainz", "Suarez"]}


#Write your function here!
def abstract_names(list_of_lists):
    dictionary = {}    
    for list in list_of_lists:
        first_name = list[0].split()[0]
        last_names = [name.split()[1] for name in list]
        dictionary[first_name] = sorted(last_names)
    return dictionary

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#
#{"David": ["Beckham", "Joyner", "Tennant"], "Ananya": ["Agarwal", "Birla", "Chatterjee", "Roy"], "Inés": ["Melchor", "Sainz", "Suarez"]}
names = [["David Joyner", "David Tennant", "David Beckham"], ["Ananya Birla", "Ananya Agarwal", "Ananya Chatterjee", "Ananya Roy"], ["Ines Sainz", "Ines Suarez", "Ines Melchor"]]
print(abstract_names(names))


## Practice problem 7 

#Vancouver citation style cites author names like this:
#
#  Last F, Joyner D, Burdell G
#
#Note the following:
#
# - Each individual name is listed as the last name, then a
#   space, then the first initial. No periods or commas within
#   each name.
# - The names are separated by commas, including the last
#   two.
# - There is no space or comma following the last period.
#
#Write a function called names_to_vancouver. names_to_vancouver
#should take as input a list of strings, and return a single
#string according to the style given above. You can assume
#that each item of the list will be a first and last name:
#no middle initials. For example:
#
#  names_to_vancouver(["First Last", "David Joyner", "George Burdell"])
#
#...would return "Last F, Joyner D, Burdell G".


#Write your function below!
def names_to_vancouver(name_list):
    new_string = ""
    for name in name_list:
        first_name = name.split()[0]
        first_name_initial = first_name[0]
        last_name = name.split()[1]
        new_string += last_name + " " + first_name_initial + ", "
    return new_string[:-2]


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: Last F, Joyner D, Burdell G
print(names_to_vancouver(["First Last", "David Joyner", "George Burdell"]))


## Practice problem 8

#The game Mancala is one of the oldest games in recorded
#history. You can read more about it here:
#https://www.thesprucecrafts.com/how-to-play-mancala-409424
#
#For this problem, though, you don't need to know how to
#play the game. All you need to know is the board layout
#and the conditions for winning.
#
#A Mancala board is made of two rows of 6 cups, with two
#bigger cups at the ends. Each cup holds some number of
#stones or chips. For our purposes, though, we'll include
#the bigger cups at the end of the corresponding rows.
#
#So, for us, a Mancala board is represented as a
#2-dimensional list of integers. Each item in the lists
#represents a cup, and the number represents how many
#stones are currently in that cup. For example, this
#could be one board:
#
# [[5, 3, 0, 2, 6, 8, 1],
#  [1, 6, 8, 0, 4, 1, 4]]
#
#With this board representation, the game is over when
#every cup is empty except the top left and the bottom
#right. When the game is over, whoever has more stones
#in their cup wins: if the top left has more stones, the
#top player wins. If the bottom right has more stones,
#the bottom player wins.
#
#Write a function called check_winner. check_winner takes
#as a 2-dimensional list representing a game board. You
#may assume list will always have two lists, each with
#7 items, corresponding to the board structure shown
#above.
#
#Your function should return one of four strings
#depending on the values of the list:
#
# - If the game is not over (that is, there are stones
#   in any bucket except for the top-left or bottom-
#   right), return "Keep playing!"
# - If the game is over and the top player wins (that is,
#   there are more stones in top-left than bottom-right),
#   return "Player 1 wins!"
# - If the game is over and the bottom player wins (that
#   is, there are more stones in the bottom-right than
#   the top-left), return "Player 2 wins!"
# - If the game is over but the score is tied (that is,
#   there is an equal number of stones in the top-left
#   and bottom-right), return "Draw!"


#Write your function here!
def check_winner(board):
    if board[0][1] > 0 or board[0][2] > 0 or board[0][3] > 0 or board[0][4] > 0 or board[0][5] > 0 or board[0][6] > 0 or board[1][0] > 0 or board[1][1] > 0 or board[1][2] > 0 or board[1][3] > 0 or board[1][4] > 0 or board[1][5] > 0:
        return "Keep playing!"
    if board[0][1] == 0 and board[0][2] == 0 and board[0][3] == 0 and board[0][4] == 0 and board[0][5] == 0 and board[0][6] == 0 and board[1][0] == 0 and board[1][1] == 0 and board[1][2] == 0 and board[1][3] == 0 and board[1][4] == 0 and board[1][5] == 0 and board[0][0] > board[1][6]:
        return "Player 1 wins!"
    if board[0][1] == 0 and board[0][2] == 0 and board[0][3] == 0 and board[0][4] == 0 and board[0][5] == 0 and board[0][6] == 0 and board[1][0] == 0 and board[1][1] == 0 and board[1][2] == 0 and board[1][3] == 0 and board[1][4] == 0 and board[1][5] == 0 and board[0][0] < board[1][6]:
        return "Player 2 wins!"
    if board[0][1] == 0 and board[0][2] == 0 and board[0][3] == 0 and board[0][4] == 0 and board[0][5] == 0 and board[0][6] == 0 and board[1][0] == 0 and board[1][1] == 0 and board[1][2] == 0 and board[1][3] == 0 and board[1][4] == 0 and board[1][5] == 0 and board[0][0] == board[1][6]:
        return "Draw!"


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#Keep playing!
#Player 1 wins!
#Player 2 wins!
#Draw!
keep_playing = [[5, 3, 0, 2, 6, 8, 1], [1, 6, 8, 0, 4, 1, 4]]
player1_wins = [[27, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 21]]
player2_wins = [[16, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 32]]
game_is_tied = [[24, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 24]]
print(check_winner(keep_playing))
print(check_winner(player1_wins))
print(check_winner(player2_wins))
print(check_winner(game_is_tied))


### PROBLEM SET 2 ###

## Practice problem 1

#Write a function called count_types. count_types
#should take as input a single string, and return a
#dictionary. In the dictionary, the keys should be
#types of characters, and the values should be the
#number of times each type of character appeared in
#the string.
#
#The types of characters that should be handled (and
#thus, the keys in the dictionary) are:
#
# - upper: the count of upper-case or capital letters
# - lower: the count of lower-case letters
# - punctuation: the count of punctuation characters.
#   You may assume this is limited to these punctuation
#   characters: !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
# - space: the count of spaces
# - numeral: the count of numerals, 0123456789
#
#All five keys should be in your dictionary no matter
#what; if there are no characters of the corresponding
#type, the value associated with the key would just be 0.
#
#For example:
#
#count_characters("aabbccc") -> 
# {"upper": 0, "lower": 7, "punctuation": 0, "space": 0, "numeral": 0}
#count_characters("ABC 123 doe ray me!") -> 
# {"upper": 3, "lower": 8, "punctuation": 1, "space": 4, "numeral": 3}
#
#HINT: If you're sing the ord() function, capitals of
#ordinals between 65 and 90; lower-case letters have
#ordinals between 97 and 122; numerals are between 48
#and 57; spaces are 32; all other numbers between 33
#and 126 are punctuations, and no character will have
#an ordinal outside that range.


#Write your function here!
def count_types(string):
    dictionary = {"upper": 0, "lower": 0, "punctuation": 0, "space": 0, "numeral": 0}
    upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    lower = "abcdefghijklmnopqrstuvwxyz"
    punctuation = '''!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~'''
    space = " "
    numeral = "0123456789"
    for char in string:
        if char in upper:
            dictionary["upper"] = dictionary.get("upper", 0) + 1
        elif char in lower:
            dictionary["lower"] = dictionary.get("lower", 0) + 1
        elif char in punctuation:
            dictionary["punctuation"] = dictionary.get("punctuation", 0) + 1
        elif char in space:
            dictionary["space"] = dictionary.get("space", 0) + 1
        elif char in numeral:
            dictionary["numeral"] = dictionary.get("numeral", 0) + 1
    return dictionary   

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#
#{"upper": 0, "lower": 7, "punctuation": 0, "spaces": 0, "numerals": 0}
#{"upper": 3, "lower": 8, "punctuation": 1, "spaces": 4, "numerals": 3}
print(count_types("aabbccc"))
print(count_types("ABC 123 doe ray me!"))


## Practice problem 2

#Write a function called write_streaming_info.
#write_streaming_info will take as input two parameters: a
#string and a list.
#
#The string will represent the filename to which to write.
#
#Each item in the list will be a tuple. The first item of
#every tuple will be the name of a movie. All remaining items
#in the tuple will be streaming services on which the movie
#appears, such as Hulu, Netflix, Peacock, HBO Max, Amazon,
#Disney+, Peacock, YouTube, Crunchyroll, CBS All Access, etc.
#
#write_streaming_info should write the list of movies to the
#file given by the filename using the following format:
#
# [movie]: Available on Service_1, Service_2, and Service_3
#
#The movies and the streaming service names should appear in
#the order of the original list/tuples.
#
#So, for this list of tuples:
#
# [("Chocolat", "Hulu", "Netflix", "Amazon"),
#  ("Skyfall", "HBO Max", "Amazon"),
#  ("Soul", "Disney+")]
#
#The file printed would look like this:
#
# Chocolat: Available on Hulu, Netflix, and Amazon
# Skyfall: Available on HBO Max and Amazon
# Soul: Disney+
#
#Note that if only one service is listed, just that service
#appears after the colon. If two services are listed, they
#appear separated by 'and' with no commas. If three or more
#services are listed, then there is a comma after every
#service except the last one, and the last one is preceded
#by 'and'.

#
#HINT: Remember, you can use slicing on tuples just like strings.
#a_tuple[:2], for example, will give you the first two items in a
#tuple. a_tuple[3:] will give you all the items from the one at
#index 3 to the end.


#Write your function here!
def write_streaming_info(filename, movies):
    file = open(filename, "w")
    for movie in movies:
        movie_name = movie[0]
        services = movie[1:]
        if len(services) == 1:
            file.write(movie_name + ": " + services[0] + "\n")
        elif len(services) == 2:
            file.write(movie_name + ": " + services[0] + " and " + services[1] + "\n")
        else:
            service_list = ", ".join(services[:-1])
            file.write(movie_name + ": " + service_list + ", and " + services[-1] + "\n")
    file.close()        


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print nothing -- however, it should write the same contents
#as Sample.txt to Test.txt.
movies = [("Chocolat", "Hulu", "Netflix", "Amazon"), ("Skyfall", "HBO Max", "Amazon"), ("Soul", "Disney+")]
write_streaming_info("Test.txt", movies)


## Practice problem 3

#Imagine you're writing the code for an intelligent 
#temperature device. The device takes a measurement every
#10 seconds. However, some readings may come up invalid.
#We can assume based on operating conditions that all
#valid temperatures will be between 20 and 80.
#
#Write a function called average_temp. average_temp
#should have one parameter, a list of integers. The list
#represents a series of temperature measurements over the
#past several minutes.
#
#average_temp should return the average of all the last
#five _valid_ (greater than or equal to 20, less than or
#equal to 80) measurements.  Round the result to 1
#decimal place (you can use round(some_float, 1) to round
#to 1 decimal place).
#
#For example, if the list of measurements was this:
#
# [5, 62, 72, 102, 68, 75, 73, 3, 7, 79]
#
#average_temp would return 73.4: the last 5 valid
#measurements are (in reverse order) 79, 73, 75, 68, and
#72. (79 + 73 + 75 + 68 + 72) / 5 = 73.4.
#
#If there are fewer than five valid readings, return the
#averages of however many valid readings there are.


#Add your code here!
def average_temp(measurements):
    last_five = []
    count = 0
    measurements.reverse()
    for measurement in measurements:
        if measurement >= 20 and measurement <= 80:
            last_five.append(measurement)
            count += 1
            if count == 5 or count == len(measurements):
                break
    average = (sum(last_five) / len(last_five))
    return round(average, 1)


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 73.4, then 67.0 (on their own lines)
a_list = [5, 62, 72, 102, 68, 75, 73, 3, 7, 79]
print(average_temp(a_list))

a_list_2 = [5, 62, 72, 102]
print(average_temp(a_list_2))


## Practice problem 4

#Write a function called find_range. find_range should take
#as input a string representing a filename. The file
#corresponding to that filename will be a list of integers,
#one integer per line. find_range should return a tuple
#containing the smallest and largest numbers in the file
#(the smallest first, then the largest).
#
#For example, in the dropdown in the top left you'll find a
#file named FindRangeInput.txt. The smallest number in that
#file is 2, and the largest is 37. So, if you called
#find_range("FindRangeInput.txt"), the function would return
#(2, 37), a tuple with two integers.
#
#You may assume that all lines in the file will contain a
#positive integer (greater than 0). There may be duplicates.
#
#Hint: Remember, if you loop through all the lines in a file
#then you have to close and reopen the file to read it again,
#or by use file.seek(0) to start from the top. However, you
#can do this problem without having to read the file twice.


#Write your function here!
def find_range(filename):
    file = open(filename, "r")
    min_value = float("inf")
    max_value = float("-inf")
    
    for line in file:
        number = int(line.strip())
        if number < min_value:
            min_value = number
        if number > max_value:
            max_value = number
    return min_value, max_value

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: (2, 37)
print(find_range("FindRangeInput.txt"))


## Practice problem 5

#Write a function called sphere_data. volume_and_area will
#take in a dictionary. This dictionary is guaranteed to
#have exactly one key: "radius", whose value is an integer
#representing the radius of a sphere.
#
#Modify this dictionary to add two keys: "volume" and "area".
#The values associated with these keys should be the volume
#and surface area of the sphere.
#
#The formula for volume is:
#  (4/3) * pi * radius ^ 3
#
#The formula for surface area is:
#  4 * pi * radius ^ 2
#
#Both volume and surface area should be rounded to two
#decimal places. You can do this with round(val, 2).
#
#The line below will let you use pi as a variable in your
#code, with a value of pi to the 15th decimal place.
from math import pi

#Add your code here!
def sphere_data(sphere):
    radius = sphere["radius"]
    sphere["volume"] = round(((4/3) * pi * radius ** 3), 2)
    sphere["area"] = round((4 * pi * radius ** 2), 2)
    return sphere


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print 4.19 and 12.57, each on a different line.
sphere = {"radius": 1}
sphere = {"radius": 1}
sphere = sphere_data(sphere)
print(sphere["volume"])
print(sphere["area"])


## Practice problem 6

#Write a function called pivot_library. pivot_library takes
#as input one parameter, a list of 3-tuples. Each tuple in
#the list has three items: the first item is a movie title
#(a string), the second item is the movie's release year (an
#integer), and the third item is the movie's total gross (an
#integer).
#
#pivot_library should return a dictionary. In the dictionary
#that it returns, the keys should be the movie names, and the
#values should be 2-item tuples. In each tuple, the first
#item should be the release year, and the second item should
#be the total gross.
#
#Hint: Unpack the tuple to variables first, then create the
#new dictionary item.
#
#For example:
#
# movies = [("Avatar", 2009, 760507625),
#           ("Black Panther", 2018, 699931862)]
# pivot_library(movies)
#   -> {"Avatar": (2009, 760507625),
#       "Black Panther": (2018, 699931862)}


#Write your function here!
def pivot_library(list_of_tuples):
    dictionary = {}
    for tuple in list_of_tuples:
        dictionary[tuple[0]] = (tuple[1], tuple[2])
    return dictionary


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#
#{"Avatar": (2009, 760507625), "Black Panther": (2018, 699931862)}
movies = [("Avatar", 2009, 760507625), ("Black Panther", 2018, 699931862)]
print(pivot_library(movies))


## Practice problem 7]

#APA citation style cites author names like this:
#
#  Last, F., Joyner, D., & Burdell, G.
#
#Note the following:
#
# - Each individual name is listed as the last name, then a
#   comma, then the first initial, then a period.
# - The names are separated by commas, including the last
#   two.
# - There is also an ampersand and additional space before
#   the final name.
# - There is no space or comma following the last period.
#
#Write a function called names_to_apa. names_to_apa should
#take as input one string, and return a reformatted string
#according to the style given above. You can assume that
#the input string will be of the following format:
#
#  First Last, David Joyner, and George Burdell
#
#You may assume the following:
#
# - There will be at least three names, with "and" before
#   the last name.
# - Each name will have exactly two words.
# - There will be commas between each pair of names.
# - The word 'and' will precede the last name.
# - The names will only be letters (no punctuation, special
#   characters, etc.), and first and last name will both be
#   capitalized.


#Write your function below!
def names_to_apa(names_string):
    names_list = names_string.replace("and ","").split(", ")
    last_name_initials = []
    last_name_in_list = []
    
    for name in names_list[:-1]:
        last_name_initials.append(name.split()[1] + ", " + name.split()[0][0] + ".,")
    for name in names_list[-1:]:
        last_name_in_list = ["& " + name.split()[1] + ", " + name.split()[0][0] + "."]
    apa_citation = " ".join(last_name_initials + last_name_in_list)
    
    return apa_citation

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: Last, F., Joyner, D., & Burdell, G.
print(names_to_apa("First Last, David Joyner, and George Burdell"))


## Practice problem 8

#In the game tic-tac-toe, two players take turns drawing
#Xs and Os on a 3x3 grid. If one player can place three of
#their symbols side-by-side in a row, column, or diagonal,
#they win the game.
#
#For example:
#
# X Wins:   X Wins:   X Wins:   No Winner:
# X|O|X     O|X|X     O|O|      X|O|O
# -+-+-     -+-+-     -+-+-     -+-+-
# O|O|X     X|O|      X|X|X     O|X|X
# -+-+-     -+-+-     -+-+-     -----
# O|X|X      | |O      | |      X|X|O
#
#Write a function called check_winner. check_winner will
#take one parameter as input, a 2D tuple (that is, a tuple
#of tuples). The 2D tuple represents the game board: each
#smaller tuple in the larger tuple is a row of the board,
#and each item in the smaller tuple is a spot on the
#board. There will always be three tuples in the larger
#tuple, and three items in each of the smaller tuples.
#
#Each item in the smaller tuple will always be one of three
#values: the string "X", the string "O", or the value None.
#
#check_winner should return one of three values: the string
#"X" if X has won the game; the string "O" if O has won the
#game; or the value None if there is no winner. None should
#NOT be the string "None"; it should be the value None,
#like the boolean values True and False.
#
#You may assume a player has won the game if and only if
#the board has three of their symbols in a row: you do not
#need to worry about whether the input is a valid game
#otherwise (e.g. a board of nine Xs still counts as X
#winning). You may assume that there will only be one
#winner per board.
#
#Hint: There are only eight possible places to win (three
#rows, three columns, two diagonals).


#Write your function here!
def check_winner(board):
    for row in board:
        if row == ("X", "X", "X"):
            return "X"
        elif row == ("O", "O", "O"):
            return "O"
    if (board[0][0] == "X" and board[1][0] == "X" and board[2][0] == "X") or (board[0][1] == "X" and board[1][1] == "X" and board[2][1] == "X") or (board[0][2] == "X" and board[1][2] == "X" and board[2][2] == "X") or (board[0][0] == "X" and board[1][1] == "X" and board[2][2] == "X") or (board[0][2] == "X" and board[1][1] == "X" and board[2][0] == "X"):
            return "X"
    if (board[0][0] == "O" and board[1][0] == "O" and board[2][0] == "O") or (board[0][1] == "O" and board[1][1] == "O" and board[2][1] == "O") or (board[0][2] == "O" and board[1][2] == "O" and board[2][2] == "O") or (board[0][0] == "O" and board[1][1] == "O" and board[2][2] == "O") or (board[0][2] == "O" and board[1][1] == "O" and board[2][0] == "O"):
            return "O"
    
#The code below shows how the tic-tac-toe tuples are
#created and tests your code with three games: one where
#X wins, one where O wins, and one where there is no winner.
#Remember, the line breaks in xwins and owins are optional:
#they're just to make the declarations more readable. They
#could be written the same as nowins.
xwins = (("X", "O", "X"),
         ("O", "O", "X"),
         ("O", "X", "X"))
owins = (("O", "X", "X"),
         ("X", "O", None),
         (None, None, "O"))
nowins = (("X", "O", "O"),("O", "X", "X"),("X", "X", "O"))
print(check_winner(xwins))
print(check_winner(owins))
print(check_winner(nowins))


### PROBLEM SET 3 ###

## Practice problem 1

#Write a function called word_count. word_count should take
#as input a list. You may assume every item in the list will
#be a string.
#
#word_count should return a dictionary, where the keys are the
#words and the values are the number of times each word appeared
#in the list. The keys should all be lower-case, and you should
#ignore case when counting words (for instance, "cat", "CAT",
#and "Cat" would all count towards the key "cat").
#
#For example:
#
#  word_count(["cat", "CAT", "dog", "DOG"]) -> {"cat": 2, "dog": 2}
#  word_count(["Georgian", "Tech", "Georgia", "Tech"]) ->
#             {"Georgian": 1, "Tech": 2, "Georgia": 1}


#Write your function here!
def word_count(list):
    dictionary = {}
    for word in list:
        word_lower = word.lower()
        if word_lower in dictionary:
            dictionary[word_lower] += 1
        else:
            dictionary[word_lower] = 1
    return dictionary


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#
#{"cat": 2, "dog": 2}
#{"Georgian": 1, "Tech": 2, "Georgia": 1}
print(word_count(["cat", "CAT", "dog", "DOG"]))
print(word_count(["Georgian", "Tech", "Georgia", "Tech"]))


## Practice problem 2

#Write a function called write_teams. write_teams will take
#as input two parameters: a string and a list of 4-tuples.
#
#The string will represent the filename to which to write.
#
#Each 4-tuple in the list will contain four strings. The
#strings will represent (in order) a university name, their
#team mascot, their city, and their state.
#
#write_teams should write the list of teams to the file given
#by the filename using the following format:
#
# [university] [mascot], [city], [state]
#
#Note there is no comma between university and mascot, but
#there is a comma between mascot and city, and city and state.
#
#So, for this list:
#
# [("Georgia Tech", "Yellow Jackets", "Atlanta", "Georgia"),
#  ("Georgia State", "Panthers", "Atlanta", "Georgia")]
#
#The file printed would look like this:
#
#Georgia Tech Yellow Jackets, Atlanta, Georgia
#Georgia State Panthers, Atlanta, Georgia
#
#We've included Sample.txt to show you what one of these
#files should look like.


#Write your function here!
def write_teams(filename, universities):
    file = open(filename, "w")
    for university in universities:
        university_name = university[0]
        mascot = university[1]
        city = university[2]
        state = university[3]
        file.write(university_name + " " + mascot + ", " + city + ", " + state + "\n")
    file.close()


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print nothing -- however, it should write the same contents
#as Sample.txt to Test.txt.
teams = [("Georgia Tech", "Yellow Jackets", "Atlanta", "Georgia"), ("Georgia State", "Panthers", "Atlanta", "Georgia"),
        ("Kennesaw State", "Owls", "Kennesaw", "Georgia"), ("Georgia Southern", "Eagles", "Statesboro", "Georgia")]
write_teams("Test.txt", teams)


## Practice problem 3

#Write a function called average_evens_and_odds. The function
#should take as input one parameter, a list of integers. The
#function should return a 2-tuple. The first item in the
#2-tuple should be the average of all even numbers in the list;
#the second item in the 2-tuple should be the average of all
#odd numbers in the list. Round your averages to one decimal
#place.
#
#The list may have some strings interspersed in it. These should
#not affect your calculation.
#
#For example, if this was the input list:
#
# [1, 2, 3, 4, "cat", "tech", 5, 6]
#
#Your function would return the tuple: (4.0, 3.0) because 4.0
#is the average of the three even numbers (2, 4, 6) and 3.0 is
#the average of the three odd numbers (1, 3, 5).
#
#HINT: round(the_num, 1) will return the result of rounding
#the_num to one decimal place.


#Add your code here!
def average_evens_and_odds(a_list):
    odd_integers = []
    even_integers = [] 
    for item in a_list:
        if type(item) == int and item % 2 == 1:
            odd_integers.append(item)
        elif type(item) == int and item % 2 == 0:
            even_integers.append(item)
    odd_average = round((sum(odd_integers) / len(odd_integers)), 1)
    even_average = round((sum(even_integers) / len(even_integers)), 1)
    my_tuple = (even_average, odd_average)
    return my_tuple
    

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: (4.0, 3.0)
a_list = [1, 2, 3, 4, "cat", "tech", 5, 6]
print(average_evens_and_odds(a_list))


## Practice problem 4

#Write a function called pull_records. first_to_last should
#have two parameters: a string representing a filename, and a
#list of integers. Inside the file, there will be some text on
#each line.
#
#pull_records should return as a list the text on each line of
#the file represented in the list of integers. For example, if
#the list of integers was [0, 4, 8], then pull_records should
#return the text from lines 0, 4, and 8 as a list. The order of
#the lines in the list must match the order of the integers.
#
#In the dropdown in the top left, you can see the contents of
#a file called Some_Records.txt. You'll use this file to test
#your code below. Remember though, we consider the first line
#of the file to be line 0, not line 1.
#
#HINT: Don't forget that if you read the file using methods
#like readlines() or read(), the linebreaks are included. If
#you results seem weirdly split between multiple lines, it
#means you're not removing these line breaks with something
#like the strip() method!


#Write your function here!
def pull_records(filename, integers):
    file = open(filename, "r")
    words = []
    my_list = []
    for line in file:
        words.append(line.strip())
    for integer in integers:
        my_list.append(str(words[integer]))
    return my_list


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: ["need", "delicious", "pies"]
print(pull_records("Some_Records.txt", [0, 4, 8]))


## Practice problem 5

#Write a function called all_sum. all_sum should have two
#parameters: a list of integers and a single integer.
#For this description, we'll call the single integer n.
#
#all_sum should modify the list to add the next n all-sum
#numbers to the end of the sequence. An all-sum number is the
#sum of all previous numbers in the sequence.
#
#For example, if the original list given was:
#
# a_list = [1, 2, 3]
#
# Then all_sum(a_list, 3) would return:
#       [1, 2, 3, 6, 12, 24]
#
#All three original numbers in the list are still there, and
#three new ones have been added: the sum of the first three
#numbers (1+2+3 = 6), of the first four (1+2+3+6 = 12), and
#of the first five (1+2+3+6+12 = 24).
#
#You may assume the list parameter will always have at least
#one number.
#
#HINT: Python gets mad if you try to change a list while
#iterating over it with a for-each loop. You'll have to get
#clever with a for or while loop to do this!


#Add your code here!
def all_sum(list_integers, n):
    count = 0
    while count < n:
        list_integers.append(sum(list_integers[:]))
        count += 1
    return list_integers

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#[1, 2, 3, 6, 12, 24] 
print(all_sum([1, 2, 3], 3))


## Practice problem 5

#Write a function called all_sum. all_sum should have two
#parameters: a list of integers and a single integer.
#For this description, we'll call the single integer n.
#
#all_sum should modify the list to add the next n all-sum
#numbers to the end of the sequence. An all-sum number is the
#sum of all previous numbers in the sequence.
#
#For example, if the original list given was:
#
# a_list = [1, 2, 3]
#
# Then all_sum(a_list, 3) would return:
#       [1, 2, 3, 6, 12, 24]
#
#All three original numbers in the list are still there, and
#three new ones have been added: the sum of the first three
#numbers (1+2+3 = 6), of the first four (1+2+3+6 = 12), and
#of the first five (1+2+3+6+12 = 24).
#
#You may assume the list parameter will always have at least
#one number.
#
#HINT: Python gets mad if you try to change a list while
#iterating over it with a for-each loop. You'll have to get
#clever with a for or while loop to do this!


#Add your code here!
def all_sum(list_integers, n):
    count = 0
    while count < n:
        list_integers.append(sum(list_integers[:]))
        count += 1
    return list_integers

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#[1, 2, 3, 6, 12, 24] 
print(all_sum([1, 2, 3], 3))


## Practice problem 6

#Write a function called concrete_names. concrete_names takes
#as input one parameter, a dictionary. Each key in the
#dictionary will be a string corresponding to a first name.
#Each value in the dictionary will be a list of last names.
#
#concrete_names should return a list of lists. Each list
#should be an alphabetically-sorted list of names constructed
#by putting each first name together with each of its last
#names. The lists themselves should also be in alphabetical
#order by what first name is shared by all names in the list.
#
#For example, this could be one of the dictionaries your
#function receives:
#
# {"David": ["Beckham", "Tennant", "Joyner"],
#  "Ananya": ["Agarwal", "Chatterjee", "Birla", "Roy"],
#  "Ines": ["Sainz", "Melchor", "Suarez"]}
#
#Your function would then return:
#
# [["Ananya Agarwal", "Ananya Birla", "Ananya Chatterjee", "Ananya Roy"],
#  ["David Beckham", "David Joyner", "David Tennant"],
#  ["Ines Melchor", "Ines Sainz", "Ines Suarez"]]
#
#HINT: To get a list of the keys of a dictionary in alphabetical
#order, use this code:
#
# the_keys = list(a_dict.keys())
# the_keys.sort()


#Write your function here!
def concrete_names(dictionary):
    sorted_keys = sorted(dictionary.keys())
    list_of_lists = []
    for key in sorted_keys:
        last_names = sorted(dictionary[key])
        full_names = [key + " " + last_name for last_name in last_names]
        list_of_lists.append(full_names)
    return list_of_lists


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#
#[["Ananya Agarwal", "Ananya Birla", "Ananya Chatterjee", "Ananya Roy"], ["David Beckham", "David Joyner", "David Tennant"], ["Inés Melchor", "Inés Sainz", "Inés Suarez"]]
print(concrete_names({"David": ["Beckham", "Tennant", "Joyner"], "Ananya": ["Agarwal", "Chatterjee", "Birla", "Roy"], "Ines": ["Sainz", "Melchor", "Suarez"]}))


## Practice problem 7

#It's a well-known and indisputable fact that if you want
#to make your name sound fancy, you should list it as only
#the initials of your first and middle name followed by your
#last name. For example, my full name is David Andrew Joyner,
#and therefore my fancy name is D. A. Joyner. But what if you
#have more than one middle name? You initialize those too!
#John Ronald Reuel Tolkien becomes J. R. R. Tolkien. Isla
#Lang Fisher becomes I. L. Fisher; Sasha Baron Cohen becomes
#S. B. Cohen; and their son Montgomery Moses Brian Baron Cohen
#becomes M. M. B. B. Cohen.
#
#Write a function called my_fancy_name. my_fancy_name should
#take as input a single string, comprised of multiple names.
#It should return the "fancy" name: the first initials of the
#first several names followed by a period and space, followed
#by the final last name. It should preserve case; if someone
#has a middle name starting with a lower-case letter, then
#it should be lower-case in their fancy name.


#Write your function below!
def my_fancy_name(string):
    first_initials = ""
    last_name = string[-1:]
    names_list = string.split(" ")
    for name in names_list[:-1]:
        first_initials += name[0] + ". "
    for name in names_list[-1:]:
        last_name = name
    return first_initials + last_name


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#D. A. Joyner
#J. R. R. Tolkien
#I. L. Fisher
#S. B. Cohen
#M. M. B. B. Cohen
#P. D. J. F. d. P. J. N. M. d. l. R. C. d. l. S. T. R. y. Picasso
print(my_fancy_name("David Andrew Joyner"))
print(my_fancy_name("John Ronald Reuel Tolkien"))
print(my_fancy_name("Isla Lang Fisher"))
print(my_fancy_name("Sasha Baron Cohen"))
print(my_fancy_name("Montgomery Moses Brian Baron Cohen"))
print(my_fancy_name("Pablo Diego Jose Francisco de Paula Juan Nepomuceno Maria de los Remedios Cipriano de la Santisima Trinidad Ruiz y Picasso"))


## Practice problem 8

#In the classic children's game Swords (also called Odds
#and Evens, Choosies, or Pick), two players simultaneously
#hold out some number of fingers. The winner is determined
#by whether the total number of fingers is odd or even.
#
#For our variant, let us say Player 1 wins if the total
#number of fingers is odd, and Player 2 wins if the total
#number of fingers is even.
#
#Write a function called find_winner. find_winner will take
#as input a list of 2-tuples, each representing a round of
#Swords. Each 2-tuple will contain two integers, each between
#1 and 5. If the sum of the two numbers is odd, then Player
#1 wins the round. If the sum of the two numbers is even,
#then Player 2 wins the round.
#
#find_winner should return the string "Player 1 wins!" if
#Player 1 wins more rounds than Player 2. It should return the
#string "Player 2 wins!" if Player 2 wins more rounds than
#Player 1. It should return the string "It's a tie!" if the
#two players win an equal number of times. 
#
#For example:
#
# find_winner([(1, 1), (2, 1), (1, 2), (2, 4), (5, 2)])
#
#...would return "Player 1 wins!" because Player 1 wins
#three rounds and Player 2 wins two rounds. (If you're
#confused: Player 1 wins rounds 2, 3, and 5 because those
#add to 3, 3, and 7; Player 2 wins rounds 1 and 4 because
#those add to 2 and 6).


#Write your function here!
def find_winner(match):
    player1 = 0
    player2 = 0
    for game in match:
        if (game[0] + game[1]) % 2 == 0:
            player2 += 1
        if (game[0] + game[1]) % 2 == 1:
            player1 += 1
    if player1 > player2:
        return "Player 1 wins!"
    if player2 > player1:
        return "Player 2 wins!"
    if player1 == player2:
        return "It's a tie!"


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#Player 1 wins!
#Player 2 wins!
#It's a tie!
print(find_winner([(1, 1), (2, 1), (1, 2), (2, 4), (5, 2)]))
print(find_winner([(1, 1), (2, 2), (1, 2), (2, 4), (5, 5)]))
print(find_winner([(1, 1), (2, 5), (3, 2), (2, 4), (5, 2), (3, 3)]))
