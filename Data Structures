#Add one to anInteger 
def addOne(anInteger):  
    anInteger = anInteger + 1
    print("anInteger:", anInteger)

#Create myInteger with the value 5
myInteger = 5   
print("myInteger before addOne:", myInteger)
#Call addOne on myInteger
addOne(myInteger)   
print("myInteger after addOne:", myInteger)

### Printing Memory Addresses
print(id())

### Methods

myString1 = "12345"
myString2 = "ABCDE"
# Prints True if myString1 is digital
print(myString2.isdigit())
# Prints True if myString2 is digital
print(myString2.isdigit())

# Checks if my_string is uppercase
my_string.isupper()

# Checks if my_string strats with character sequence "ABC"
my_string.startswith("ABC")

###

#Write a function called random_marks. random_marks should
#take three parameters, all integers. It should return a
#string.
#
#The first parameter represents how many apostrophes should
#be in the string. The second parameter represents how many
#quotation marks should be in the string. The third
#parameter represents how many apostrophe-quotation mark
#pairs should be in the string.
#
#For example, random_marks(3, 2, 3) would return this
#string: #'''""'"'"'"
#
#Note that there are three apostrophes, then two quotation
#marks, then three '" pairs.


#Add your function here!
def random_marks(num1, num2, num3):
    return (("'" * num1) + ('"' * num2) + (''''"''' * num3))

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: '''""'"'"'"

print(random_marks(3, 2, 3))


### Special characters
# use \n for a line break
myStringWithNewLine = "1234\n5678"
print(myStringWithNewLine) ##

## \t puts a tab
## \" includes character as is (usually " would indicate the end of a string)
## \\ prints just one slash without breaking

###

#Write a function called "steps" that should return a string 
#that, if printed, looks like this:
#
#111
#	222
#		333
#
#Note that the characters at the beginning of the second and
#third lines must be tabs, not spaces. There should be one
#tab on the second line and two on the third line.
#
#You may only declare ONE string in your function.
#
#Hint: Don't overthink this! We're literally just asking you
#to return one single string that just holds the above text.
#You don't have to build the string dynamically or anything.


#Write your function here!
def steps():
    return "111\n	222\n		333"


#The line below will test your function.
print(steps())


### Concatenate

## all return the same thing:
string1 = "12345"
string2 = "67890"
string3 = string1 + string2
print("Assignment concatenation: " + string 3)
print("In-Line concatenation: " + string1 + string2")
string1 += string 2
print("Self-assignment concatenation: " + string1)

###

#-----------------------------------------------------------
#Write a function called align_right. align_right should
#take two parameters: a string (a_string) and an integer
#(string_length), in that order.
#
#The function should return the same string with spaces
#added to the left so that the text is "right aligned" in a
#string. The number of spaces added should make the total
#string length equal string_length.
#
#For example: align_right("CS1301", 10) would return the
#string "    CS1301". Four spaces are added to the left so
#"CS1301" is right-aligned and the total string length is
#10.
#
#HINT: Remember, len(a_string) will give you the number of
#characters currently in a_string.


#Add your function here!
def align_right(a_string, string_length):    
    while len(a_string) < string_length:
        a_string = " " + a_string
    return a_string


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: "    CS1301"
print(align_right("CS1301", 10))

###

#Write a function called "last_n" that accepts two arguments:
#a string search_string and an integer n. The function should
#return the last n characters from search_string. If
#search_string is shorter than n characters, then it should
#return the entire value of search_string.


#Write your function here!
def last_n(string, number):
    start = len(string) - number
    last_n = string[start:]
    return last_n


#The code below will test your function. If your function
#works correctly, this should print 789, saur, and 1.
print(last_n("123456789", 3))
print(last_n("Bulbasaur", 4))
print(last_n("1", 5))

###

#Write a function called "scramble" that accepts a string
#as an argument and returns a new string. The new string 
#should start with the last half of the original string
#and end with the first half. 
#
#If the length of the string is odd, split the string 
#at the floor of the length / 2 (in other words, the second
#half is the longer half).
#
#For example:
#  scramble("abcd") -> "cdab"
#  screamble("abcde") -> "cdeab"
#  scramble("railroad")) -> "roadrail"
#  scramble("fireworks")) -> "worksfire"


#Write your function here!
def scramble(string):
    end = len(string) // 2
    last_half = string[end:]
    first_half = string[:end]
    return last_half + first_half


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print the results you see in the examples above.

string1 = "abcd"
string2 = "abcde"
string3 = "railroad"
string4 = "fireworks"
print(string1 + " -> " + scramble(string1))
print(string2 + " -> " + scramble(string2))
print(string3 + " -> " + scramble(string3))
print(string4 + " -> " + scramble(string4))

###

#Write a function called fancy_find. fancy_find should have
#two parameters: search_within and search_for.
#
#fancy_find should check if search_for is found within the
#string search_within. If it is, it should print the message
#"[search_for] found at index [index]!", with [search_for]
#and [index] replaced by the value of search_for and the
#index at which it is found. If search_for is not found
#within search_within, it should print, "[search_for] was
#not found within [search_within]!", again with the values
#of search_for and search_within.
#
#For example:
#
#  fancy_find("ABCDEF", "DEF") -> "DEF found at index 3!"
#  fancy_find("ABCDEF", "GHI") -> "GHI was not found within ABCDEF!"


#Add your function here!
def fancy_find(search_within, search_for):
    if search_for in search_within:
        return search_for + " found at index " + \
              str(search_within.find(search_for)) + "!"
    else:
        return search_for + " was not found within " + search_within \
               + "!"

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#DEF found at index 3!
#GHI was not found within ABCDEF!

print(fancy_find("ABCDEF", "DEF"))
print(fancy_find("ABCDEF", "GHI"))

###

myString = "ABCDEABCDEABCDE"

#Prints the first index of "CDE" in myString
print(myString.find("CDE")) 
#Prints the first index of "CDE" in myString after 5
print(myString.find("CDE", 5)) 
#Prints the first index of "CDE" in myString after 8
print(myString.find("CDE", 13)) 
#Prints the first index of "CDE" in myString between 4 and 10
print(myString.find("CDE", 4, 10)) 
#Prints the first index of "CDE" in myString between 3 and 6
print(myString.find("CDE", 3, 6)) 

###






