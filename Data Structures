#Add one to anInteger 
def addOne(anInteger):  
    anInteger = anInteger + 1
    print("anInteger:", anInteger)

#Create myInteger with the value 5
myInteger = 5   
print("myInteger before addOne:", myInteger)
#Call addOne on myInteger
addOne(myInteger)   
print("myInteger after addOne:", myInteger)

### Printing Memory Addresses
print(id())

### Methods

myString1 = "12345"
myString2 = "ABCDE"
# Prints True if myString1 is digital
print(myString2.isdigit())
# Prints True if myString2 is digital
print(myString2.isdigit())

# Checks if my_string is uppercase
my_string.isupper()

# Checks if my_string strats with character sequence "ABC"
my_string.startswith("ABC")

###

#Write a function called random_marks. random_marks should
#take three parameters, all integers. It should return a
#string.
#
#The first parameter represents how many apostrophes should
#be in the string. The second parameter represents how many
#quotation marks should be in the string. The third
#parameter represents how many apostrophe-quotation mark
#pairs should be in the string.
#
#For example, random_marks(3, 2, 3) would return this
#string: #'''""'"'"'"
#
#Note that there are three apostrophes, then two quotation
#marks, then three '" pairs.


#Add your function here!
def random_marks(num1, num2, num3):
    return (("'" * num1) + ('"' * num2) + (''''"''' * num3))

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: '''""'"'"'"

print(random_marks(3, 2, 3))


### Special characters
# use \n for a line break
myStringWithNewLine = "1234\n5678"
print(myStringWithNewLine) ##

## \t puts a tab
## \" includes character as is (usually " would indicate the end of a string)
## \\ prints just one slash without breaking

###

#Write a function called "steps" that should return a string 
#that, if printed, looks like this:
#
#111
#	222
#		333
#
#Note that the characters at the beginning of the second and
#third lines must be tabs, not spaces. There should be one
#tab on the second line and two on the third line.
#
#You may only declare ONE string in your function.
#
#Hint: Don't overthink this! We're literally just asking you
#to return one single string that just holds the above text.
#You don't have to build the string dynamically or anything.


#Write your function here!
def steps():
    return "111\n	222\n		333"


#The line below will test your function.
print(steps())


### Concatenate

## all return the same thing:
string1 = "12345"
string2 = "67890"
string3 = string1 + string2
print("Assignment concatenation: " + string 3)
print("In-Line concatenation: " + string1 + string2")
string1 += string 2
print("Self-assignment concatenation: " + string1)

###

#-----------------------------------------------------------
#Write a function called align_right. align_right should
#take two parameters: a string (a_string) and an integer
#(string_length), in that order.
#
#The function should return the same string with spaces
#added to the left so that the text is "right aligned" in a
#string. The number of spaces added should make the total
#string length equal string_length.
#
#For example: align_right("CS1301", 10) would return the
#string "    CS1301". Four spaces are added to the left so
#"CS1301" is right-aligned and the total string length is
#10.
#
#HINT: Remember, len(a_string) will give you the number of
#characters currently in a_string.


#Add your function here!
def align_right(a_string, string_length):    
    while len(a_string) < string_length:
        a_string = " " + a_string
    return a_string


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: "    CS1301"
print(align_right("CS1301", 10))

###

#Write a function called "last_n" that accepts two arguments:
#a string search_string and an integer n. The function should
#return the last n characters from search_string. If
#search_string is shorter than n characters, then it should
#return the entire value of search_string.


#Write your function here!
def last_n(string, number):
    start = len(string) - number
    last_n = string[start:]
    return last_n


#The code below will test your function. If your function
#works correctly, this should print 789, saur, and 1.
print(last_n("123456789", 3))
print(last_n("Bulbasaur", 4))
print(last_n("1", 5))

###

#Write a function called "scramble" that accepts a string
#as an argument and returns a new string. The new string 
#should start with the last half of the original string
#and end with the first half. 
#
#If the length of the string is odd, split the string 
#at the floor of the length / 2 (in other words, the second
#half is the longer half).
#
#For example:
#  scramble("abcd") -> "cdab"
#  screamble("abcde") -> "cdeab"
#  scramble("railroad")) -> "roadrail"
#  scramble("fireworks")) -> "worksfire"


#Write your function here!
def scramble(string):
    end = len(string) // 2
    last_half = string[end:]
    first_half = string[:end]
    return last_half + first_half


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print the results you see in the examples above.

string1 = "abcd"
string2 = "abcde"
string3 = "railroad"
string4 = "fireworks"
print(string1 + " -> " + scramble(string1))
print(string2 + " -> " + scramble(string2))
print(string3 + " -> " + scramble(string3))
print(string4 + " -> " + scramble(string4))

###

#Write a function called fancy_find. fancy_find should have
#two parameters: search_within and search_for.
#
#fancy_find should check if search_for is found within the
#string search_within. If it is, it should print the message
#"[search_for] found at index [index]!", with [search_for]
#and [index] replaced by the value of search_for and the
#index at which it is found. If search_for is not found
#within search_within, it should print, "[search_for] was
#not found within [search_within]!", again with the values
#of search_for and search_within.
#
#For example:
#
#  fancy_find("ABCDEF", "DEF") -> "DEF found at index 3!"
#  fancy_find("ABCDEF", "GHI") -> "GHI was not found within ABCDEF!"


#Add your function here!
def fancy_find(search_within, search_for):
    if search_for in search_within:
        return search_for + " found at index " + \
              str(search_within.find(search_for)) + "!"
    else:
        return search_for + " was not found within " + search_within \
               + "!"

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#DEF found at index 3!
#GHI was not found within ABCDEF!

print(fancy_find("ABCDEF", "DEF"))
print(fancy_find("ABCDEF", "GHI"))

###

myString = "ABCDEABCDEABCDE"

#Prints the first index of "CDE" in myString
print(myString.find("CDE")) 
#Prints the first index of "CDE" in myString after 5
print(myString.find("CDE", 5)) 
#Prints the first index of "CDE" in myString after 8
print(myString.find("CDE", 13)) 
#Prints the first index of "CDE" in myString between 4 and 10
print(myString.find("CDE", 4, 10)) 
#Prints the first index of "CDE" in myString between 3 and 6
print(myString.find("CDE", 3, 6)) 

###

#Recall in Unit 3 you wrote a function that would count the
#number of words in a string using loops. Now that you know
#something about string methods, though, let's do that again
#using a different approach.
#
#Write a function called "num_words" that accepts a string 
#as an argument and returns the number of words in the 
#string. You can assume all words are separated by a space,
#and that the string has at least one word. You do not need
#to worry about punctuation.
#
#For example:
#
#  num_words("Veni, Vidi, Vici.") -> 3
#
#This time, you may not use any loops. Hint: split() might
#come in handy.


#Write your function here!
def num_words(string):
    my_list = string.split(" ")
    count = len(my_list)
    return count

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 3, 2, 1, each on their own line.
print(num_words("Vini, Vidi, Vici."))
print(num_words("Hello, world!"))
print(num_words("HeyDavidwhyaren'ttherespacesinthissentence"))


### Useful string methods ###

mystring.capitalize()
mystring.lower()
mystring.upper()
mystring.title()                 ## capitalizes any character found after space
mystring.strip()                 ## strips any empty spaces at end
mystring.replace("MY", "YOUR")   ## replaces first instances of word with second

mylist = mystring.split()        ## splits string into list of items
print("-".join(mylist))          ## adds "-" between each word in list


### TUPLES ###

#Write a function called unpack_and_reverse that will
#accept one parameter, a tuple with at least three items.
#The function should return a new tuple with only the first
#three items, but listed in reverse order.
#
#For example:
#
# a_tuple = ("a", "b", "c", "d", "e")
# unpack_and_reverse(a_tuple) -> ("c", "b", "a")
#
#However, to do this, you should not access any value in
#the tuple directly (e.g. with a_tuple[1]). Instead, you
#should use tuple unpacking to unpack them into variables.
#You also should not touch any items past the third item
#in the tuple: use tuple slicing instead to only access
#the first three.

#Write your function here!
def unpack_and_reverse(mytuple):
    a, b, c = mytuple[0:3]
    return c, b, a

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#('c', 'b', 'a')
#('h', 'g', 'f')
#('k', 'j', 'i')
print(unpack_and_reverse(("a", "b", "c", "d", "e")))
print(unpack_and_reverse(("f", "g", "h")))
print(unpack_and_reverse(("i", "j", "k", "l", "m", "n", "o", "p", "q", "r")))

###

#Remember asciitable.com from an earlier exercise? We're
#going to use it again. Remember, ordinal values for
#characters are given in the 'Dec' column of asciitable.com.
#
#Write a function called character_info. character_info will
#take as input a string with only one character. It should
#return a 3-tuple with three pieces of information:
#
# - In the first spot, the character itself.
# - In the second spot, the ordinal value of the character,
#   obtained using the ord() function (e.g. ord("a") -> 97).
# - In the third spot, what type of character it is: either
#   "letter", "number", or "punctuation".
#
#You may assume that anything that is not a letter (either
#upper or lower case) or a number is punctuation. You may
#also assume the ordinal will be between 32 (" ") and 126
#("~").


#Write your function here!
def character_info(char):
    if char in "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz":
        char_type = "letter"
    elif char in "1234567890":
        char_type = "number"
    else:
        char_type = "punctuation"
    return (char, ord(char), char_type)
    
        
#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#('q', 113, 'letter')
#('7', 55, 'number')
#('`', 96, 'punctuation')
print(character_info("q"))
print(character_info("7"))
print(character_info("`"))

### List functions ###

mylist.sort()                     ## sorts low to high
mylist.append()                   ## adds to list
mylist.extend()                   ## adds to list
mylist.insert(location, value)    ## inserts value after location
mylist.remove()                   ## removes given value from list
mylist.reverse()                  ## reverses list
mylist.pop()                      ## removes last item from list (and stores it)
del mylist[-5:]                   ## removes all values starting at five from the end
mylist.index(23)                  ## shows where value 23 is indexed
mylist.count(15)                  ## counts how many times 15 occurs in list
print(4 in mylist)                ## prints False since 4 isn't in list

###

#Write a function called modify_list. modify_list will
#take one parameter, a list. It should then modify the
#list in the following ways, in this order:
#
# - Sort the list (using the default sort method).
# - Reverse the order of the list.
# - Delete the last three items of the list.
# - Removes one instance the integer 7 from the list, if
#   it's present.
# - Double the values of the first and third items in
#   the list.
#
#It should then return the resulting list. You may assume
#the list will start with at least six items.
#
#Hint: Remember Python is 0-indexed. The second item
#does not have an index of 2.
#
#Hint 2: Remember, the list.remove() function removes items
#by value, not by index. Note also that if the item you're
#trying to remove is not found in the list, remove() will
#throw an error: so, you'll want to avoid that one way or
#another!


#Write your code here!
def modify_list(mylist):
    mylist.sort()
    mylist.reverse()
    del mylist[-3:]
    if 7 in mylist:
        mylist.remove(7)
    mylist[0] *= 2
    mylist[2] *= 2
    return mylist


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#[178, 81, 75.0, 4, 3.141592653589793, 3]
import math
print(modify_list([7, 4, 3, 2.0, 81, 37.5, 89, math.pi, -2, math.e]))

###

#Write a function called multiply_strings. Multiply
#strings should have one parameter, a list of strings.
#It should return a modified list according to the
#following changes:
#
# - Every string stored at an even index should be
#   doubled.
# - Every string stored at an index that is a multiple
#   of 3 should be tripled.
# - Every other string should remain unchanged.
#
#These changes should "stack": the string stored at index
#6 should be duplicated six times (2 * 3).
#
#Then, return the new list. You may assume that 0 is a
#multiple of 2 and 3.
#
#Hint: To do this, you need to modify the values of the
#list using their indices, e.g. a_list[1]. If you're not
#using their indices, your answer won't work!


#Write your function here!
def multiply_strings(list_of_strings):
    for string in range(0, len(list_of_strings), 2):
        list_of_strings[string] *= 2
    for string in range(0, len(list_of_strings), 3):
        list_of_strings[string] *= 3
    return list_of_strings


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 
#['AAAAAA', 'B', 'CC', 'DDD', 'EE', 'F', 'GGGGGG']
test_list = ["A", "B", "C", "D", "E", "F", "G"]
print(multiply_strings(test_list))

###

#Write a function called sum_lists. sum_lists should take
#one parameter, which will be a list of lists of integers.
#sum_lists should return the sum of adding every number from
#every list.
#
#For example:
#
# list_of_lists = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
# sum_list(list_of_lists) -> 67


#Add your code here!
def sum_lists(list_of_lists):
    sum = 0
    for single_list in list_of_lists:
        for item in single_list:
            sum += item
    return sum


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 78
list_of_lists = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
print(sum_lists(list_of_lists))

###

#We've learned a lot in this chapter. Let's try to use a lot
#of it for one final exercise.
#
#Write a function called sort_artists. sort_artists will
#take as input a list of tuples. Each tuple will have two
#items: the first item will be a string holding an artist's
#name, and the second will be an integer representing their
#total album sales (in millions).
#
#Return a tuple of two lists. The first list in the
#resulting tuple should be all the artists sorted
#alphabetically. The second list should be all the revenues
#sorted in descending numerical order.
#
#For example:
# artists = [("The Beatles", 270.8), ("Elvis Presley", 211.5), ("Michael Jackson", 183.9)]
# sort_artists(artists) -> (["Elvis Presley", "Michael Jackson", "The Beatles"], [270.8, 211.5, 183.9])
#
#Notice that artists is a list of tuples (brackets first,
#then parentheses), but sort_artists outputs a tuple of
#lists (parentheses first, then brackets).


#Write your function here!
def sort_artists(artist_list):
    
    artists = []
    sales = []
    
    for artist_tuple in artist_list:        
        artists.append(artist_tuple[0])        
        sales.append(artist_tuple[1])
      
    artists.sort()
    sales.sort()
    sales.reverse()
    
    return (artists, sales)
    

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#(['Elvis Presley', 'Michael Jackson', 'The Beatles'], [270.8, 211.5, 183.9])  
artists = [("The Beatles", 270.8), ("Elvis Presley", 211.5), ("Michael Jackson", 183.9)]
print(sort_artists(artists))

###

#Averages each list in in2DList
def TwoDAverageWithPop(in2DList):  
    result = []
    #Repeat until in2DList is empty
    while len(in2DList) > 0:    
        #Remove and assign the last item of in2DList to numList
        numList = in2DList.pop()    
        sum = 0
        count = 0
        #Repeat until numList is empty
        while len(numList) > 0: 
            #Remove and save the last item of numList to number
            number = numList.pop()  
            sum += number
            count += 1
        #Insert this average at the beginning of result
        result.insert(0, sum / count)   
    return result

my2DList = [[91, 95, 89, 92, 85],[85, 87, 91, 81, 82],
            [79, 75, 85, 83, 89],[81, 89, 91, 91, 90],
            [99, 91, 95, 89, 90]]

print("Averages:", TwoDAverageWithPop(my2DList))
print("my2DList:", my2DList)


### FILE INPUT AND OUTPUT ###

myInt1 = 12
myInt2 = 23
myInt3 = 34

#Open OutputFile.txt in write mode
outputFile = open("OutputFile.txt", "w")    

#Write myInt1 to outputFile
outputFile.write(str(myInt1))    
#Write myInt2 to outputFile
outputFile.write(str(myInt2))    
#Write myInt3 to outputFile
outputFile.write(str(myInt3))    
#Close outputFile
outputFile.close()  

###

#Write a function called "write_file" that accepts two 
#parameters: a filename and some data that will either 
#be an integer or a string to write. The function 
#should open the file and write the data to the file.
#
#Hints:
#
# - Don't forget to close the file when you're done!
# - If the data isn't a string already, you may need
#   to convert it, depending on the approach you
#   choose.
# - Remember, this code has no print statements, so
#   when you run it, don't expect to see any output
#   on the right! You could add print statements if
#   you want a confirmation the code is done running.
# - You can put the variable for the filename in the
#   same place where we put text like OutputFile.txt
#   in the videos.


#Write your function here!
def write_file(filename, data):
    output_file = open(filename, "w")
    output_file.write(str(data))
    output_file.close()


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print nothing. However, if you open WriteFileOutput.txt
#in the top left after running it, the contents of the
#file should be 1301.
write_file("WriteFileOutput.txt", 1301)

###

#Write a function called "append_to_file" that accepts
#two parameters: a filename and some data that will
#be an integer or a string to write. The function 
#should open the file and add the data to the end of
#the file. Each new call to append_to_file should add
#the new contents on a new line.
#
#Hints:
#
# - Don't forget to close the file when you're done!
# - If the data isn't a string already, you may need
#   to convert it.
# - Remember, this code has no print statements, so
#   when you run it, don't expect to see any output
#   on the right! You could add print statements if
#   you want a confirmation the code is done running.
# - You can put the variable for the filename in the
#   same place where we put text like OutputFile.txt
#   in the videos.


#Write your function here!
def append_to_file(filename, data):
    output_file = open(filename, "a")
    output_file.write(str(data) + "\n")
    output_file.close()

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print nothing. However, if you open AppendToFileOutput.txt
#in the top left after running it, the contents of the
#file should be another instance of 1301 every time you
#run this file.
append_to_file("AppendToFileOutput.txt", 1301)

###

myList = ["David", "Lucy", "Vrushali", "Ping",
          "Natalie", "Dana", "Addison", "Jasmine"]

#Open OutputFile.txt in write mode
outputFile = open("OutputFile.txt", "w")    

#For each name in myList
for name in myList: 
    #Write the name to the file on its own line
    print(name, file = outputFile)   

outputFile.close()

###

myList = ["David", "Lucy", "Vrushali", "Ping", 
          "Natalie", "Dana", "Addison", "Jasmine"]

#Open OutputFile.txt in write mode
outputFile = open("OutputFile.txt", "w")    

#For each name in myList
for name in myList: 
    #Write the name to the file on its own line
    outputFile.write(name + "\n")   

outputFile.close()

###

myList = ["David", "Lucy", "Vrushali", "Ping",
          "Natalie", "Dana", "Addison", "Jasmine"]

#Open OutputFile.txt in write mode
outputFile = open("OutputFile.txt", "w")    

#Writes every string in myList to a file
outputFile.writelines(myList)   

outputFile.close()

###

myList = ["David", "Lucy", "Vrushali", "Ping",
          "Natalie", "Dana", "Addison", "Jasmine"]
 
#Open OutputFile.txt in write mode
outputFile = open("OutputFile.txt", "w")    
 
#Joins myList using \n, then writes it to a file
outputFile.write("\n".join(myList))   
 
outputFile.close()

###

myInt1 = 12
myInt2 = 23
myInt3 = 34
myList = ["David", "Lucy", "Vrushali", "Ping", 
          "Natalie", "Dana", "Addison", "Jasmine"]

#Open OutputFile.txt in write mode
outputFile = open("OutputFile.txt", "w")    

#Write myInt1 to outputFile
outputFile.write(str(myInt1) + "\n")    
#Write myInt2 to outputFile
outputFile.write(str(myInt2) + "\n")    
#Write myInt3 to outputFile
outputFile.write(str(myInt3) + "\n")    
#Joins myList using \n, then writes it to a file
outputFile.write("\n".join(myList))   

outputFile.close()

###

#Write a function called "find_coffee" that expects a 
#filename as a parameter. The function should open the 
#given file and return True if the file contains the word 
#"coffee". Otherwise, the function should return False.
#
#Hint: look up the read() method if you want to do this
#more simply than you might do with readline().


#Write your function here!
def find_coffee(filename):
    input_file = open(filename, "r")
    file_contents = input_file.read()
    input_file.close()
    if "coffee" in file_contents:
        return True
    else:
        return False

#You can test your function with the provided files named 
#"coffeeful.txt" and "coffeeless.txt". With their original
#text, the lines below should print True, then False. You
#may also edit the files by selecting them in the drop
#down in the top left to try your code with different
#input.
print(find_coffee("coffeeful.txt"))
print(find_coffee("coffeeless.txt"))

###

#Write a function called "load_file" that accepts one 
#parameter: a filename. The function should open the
#file and return the contents.#
#
# - If the contents of the file can be interpreted as
#   an integer, return the contents as an integer.
# - Otherwise, if the contents of the file can be
#   interpreted as a float, return the contents as a
#   float.
# - Otherwise, return the contents of the file as a
#   string.
#
#You may assume that the file has only one line.
#
#Hints:
#
# - Don't forget to close the file when you're done!
# - Remember, anything you read from a file is
#   initially interpreted as a string.


#Write your function here!
def load_file(filename):
    input_file = open(filename, "r")
    contents = input_file.readline()
    try:
        return int(contents)
    except ValueError:
        try:
            return float(contents)    
        except:
            return str(contents)
    finally:
        input_file.close()


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print 123, followed by <class 'int'>.
contents = load_file("LoadFromFileInput.txt")
print(contents)
print(type(contents))

###

myList = []

#Open OutputFile.txt in read mode
inputFile = open("OutputFile.txt", "r")    

#For each line in the file
for line in inputFile:  
    #Add the line to myList, stripping out whitespace
    myList.append(line.strip()) 

print(myList)

inputFile.close()

###

myList = []

#Open OutputFile.txt in read mode
inputFile = open("OutputFile.txt", "r")    

myInt1 = int(inputFile.readline())  
myInt2 = int(inputFile.readline())  
myInt3 = int(inputFile.readline())  
#For each line in the file
for line in inputFile:  
    #Add the line to myList, stripping out whitespace
    myList.append(line.strip()) 

print(myInt1)
print(myInt2)
print(myInt3)
print(myList)

inputFile.close()

###

#Saves inList to the file
def save(filename, inList): 
    outputFile = open(filename, "w")

    for item in inList: 
        print(item, file = outputFile)   

    outputFile.close()

#Loads from filename and returns a list of the contents
def load(filename): 
    inputFile = open(filename, "r")
    inList = []

    for line in inputFile:
        inList.append(line.strip())
    inputFile.close()
    return inList

myList = ["David", "Lucy", "Vrushali", "Ping", "Natalie",
          "Dana", "Addison", "Jasmine"]
save("OutputFile.txt", myList)
newList = load("OutputFile.txt")

print(newList)

###

inputFile = open("OutputFile.txt", "r")
print(inputFile)
inputFile.close()

###

inputFile = open("OutputFile.txt", "r")

#Print the next line of inputFile
print(inputFile.readline()) 
#Print the next line of inputFile
print(inputFile.readline()) 
#Print the next line of inputFile
print(inputFile.readline()) 

inputFile.close()

###

inputFile = open("OutputFile.txt", "r")

#Print the next line of inputFile
print(inputFile.readline().strip()) 
#Print the next line of inputFile
print(inputFile.readline().strip()) 
#Print the next line of inputFile
print(inputFile.readline().strip()) 

inputFile.close()

###

inputFile = open("OutputFile.txt", "r")

#Read the next line of inputFile, cast it 
#to int, and assign it to myInt1
myInt1 = int(inputFile.readline())  
#Read the next line of inputFile, cast it 
#to int, and assign it to myInt2
myInt2 = int(inputFile.readline())  
#Read the next line of inputFile, cast it 
#to int, and assign it to myInt3
myInt3 = int(inputFile.readline())  

print("myInt1:", myInt1)
print("myInt2:", myInt2)
print("myInt3:", myInt3)

inputFile.close()


### DICTIONARIES ###

#We've defined a list of tuples below. Each tuple follows
#the format: (name, home state).
#
#Create a dictionary called ta_dict in the space below, where
#the keys are each TA's name, and the values are their home
#state.

ta_info = [("Joshua", "Georgia"),
          ("Jackie", "Vermont"),
          ("Marguerite", "Tennessee")]

#Add your code to create the dictionary as described!
#The first item in each tuple should be a key, and
#the second item in each tuple should be its value.
#Note that you may create this either by reading and
#using the ta_info list of tuples, or you can create
#the dictionary from scratch:


#Create your dictionary here!
ta_dict = {"Joshua":"Georgia", "Jackie":"Vermont", "Marguerite":"Tennessee"}


#Now, create three variables: josh_val, jack_val, and
#marg_val. Set josh_val equal to Josh's dictionary value,
#then jack_val equal to Jackie's, then marg_val equal to
#Marguerite's. Remember how to properly access the value
#corresponding to a dictionary key!
#
#Make sure you use dictionary-access syntax to do this.
#Don't create the variables based on new values.

#Create your variables here!
josh_val = ta_dict["Joshua"]
jack_val = ta_dict["Jackie"]
marg_val = ta_dict["Marguerite"]

#If your code works as intended, the following three lines
#will run and print Georgia, Vermont, and Tennessee:
print(josh_val)
print(jack_val)
print(marg_val)

###

#Creates myDictionary with sprockets=5, widgets=11, cogs=3, and gizmos=15
myDictionary = {"sprockets" : 5, "widgets" : 11, "cogs" : 3, "gizmos": 15}
print(myDictionary)
myDictionary["sprockets"] += 1
print(myDictionary)

###

#Creates myDictionary with sprockets=5, widgets=11, cogs=3, and gizmos=15
myDictionary = {"sprockets" : 5, "widgets" : 11, "cogs" : 3, "gizmos": 15}
print(myDictionary)
myDictionary["sprockets"] += 1
print(myDictionary)

###

#Create a function called tup_to_dict. tup_to_dict should take one
#parameter: a list of tuples. You can assume each tuple in
#the list has exactly two values.
#
#The function should return a dictionary where the first item
#in each tuple is the key, and the second item in each tuple
#is the corresponding value.
#
#For example:
# colors = [("turquoise", "#40E0D0"), ("red", "#990000")]
# tup_to_dict(colors) -> {"turquoise":"#40E0D0", "red":"#990000"}
#
#Hint: the previous exercise is very similar; this just turns
#it into a function! All our tuples will be color name-color
#value pairs.


#Write your function here!
def tup_to_dict(tuple_list):
    dictionary = {}
    for list in tuple_list:
        dictionary[list[0]] = list[1]
    return dictionary


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:  {'Turquoise':'#40E0D0', 'Red':'#990000'}
#
#Don't worry if it prints those in the reverse order; that's
#still correct!
print(tup_to_dict([("Turquoise", "#40E0D0"), ("Red", "#990000")]))

###

#Creates myDictionary with sprockets=5, widgets=11, cogs=3, and gizmos=15
myDictionary = {"sprockets" : 5, "widgets" : 11,
                "cogs" : 3, "gizmos": 15}
print(myDictionary)

#Creates the new key "gadgets" with value 1
myDictionary["gadgets"] = 1   
print(myDictionary)
del myDictionary["gadgets"]
print(myDictionary)

###

#Creates myDictionary with David=4045551234, Lucy=4045555678, 
#Vrushali=4045559101
myDictionary = {"David" : "4045551234", "Lucy" : "4045555678",
                "Vrushali" : "4045559101"}
print(myDictionary)

#Checks if "David" is a key in the dictionary
if "David" in myDictionary: 
    print("David is already in myDictionary!")
    myDictionary["David2"] = "4045551121"
else:  
    myDictionary["David"] = "4045551121"
print(myDictionary)

###

#Creates myDictionary with #David=4045551234, Lucy=4045555678, #Vrushali=4045559101
myDictionary = {"David" : "4045551234", "Lucy" : "4045555678",
                "Vrushali" : "4045559101"}
print(myDictionary["Dana"])

###

#Write a function called students_present. students_present
#should take as input one parameter, a dictionary. The keys
#of the dictionary will be names, and the values will be one
#of three strings: "Here", "Present", or an empty string "".
#
#Return a list of the keys for whom the corresponding value
#is either "Here" or "Present".


#Add your code here!
def students_present(dictionary):
    students_present = []
    for (student, status) in dictionary.items():
        if status == "Here" or status == "Present":
            students_present.append(student)
    return students_present


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#["David", "Marguerite", "Joshua", "Erica"]

student_list = {"David" : "Here", "Marguerite" : "Here",
                "Jackie": "", "Joshua": "Present",
                "Erica": "Here", "Daniel": ""}
print(students_present(student_list))

###

#Creates myDictionary with sprockets=5, widgets=11, cogs=3, gizmos=15, 
#gadgets=1
myDictionary = {"sprockets" : 5, "widgets" : 11, "cogs" : 3, "gizmos" : 15,
                "gadgets" : 1}
for value in myDictionary.values():
    if value < 5:
        print("A value less than 5 was found:", value)

###

#Creates myDictionary with sprockets=5, widgets=11, cogs=3, gizmos=15, 
#gadgets=1
myDictionary = {"sprockets" : 5, "widgets" : 11, "cogs" : 3, "gizmos" : 15, 
                "gadgets" : 1}
for key in myDictionary.keys():
    value = myDictionary[key]
    if value < 5:
        print(key, "is less than 5:", value)

###

#Creates myDictionary with sprockets=5,
#widgets=11, cogs=3, gizmos=15, gadgets=1
myDictionary = {"sprockets" : 5, "widgets" : 11,
                "cogs" : 3, "gizmos" : 15, "gadgets" : 1}
for (key, value) in myDictionary.items():
    if value < 5:
        print(key, "is less than 5:", value)

###

#Write a function called name_counts. name_counts will take
#as input a list of full names. Each name will be two words
#separated by a space, like "David Joyner".
#
#The function should return a dictionary. The keys to the
#dictionary will be the first names from the list, and the
#values should be the number of times that first name
#appeared.
#
#HINT: Use split() to split names into first and last.


#Add your function here!
def name_counts(name_list):
    dictionary = {}
    for name in name_list:
        first_name = name.split()[0]
        if first_name in dictionary:
            dictionary[first_name] += 1
        else:
            dictionary[first_name] = 1
    return dictionary
        
#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#{'Shelba': 5, 'Maren': 1, 'Nicol': 1, 'David': 2, 'Brenton': 2}
name_list = ["David Joyner", "David Zuber", "Brenton Joyner",
             "Brenton Zuber", "Nicol Barthel", "Shelba Barthel",
             "Shelba Crowley", "Shelba Fernald", "Shelba Odle",
             "Shelba Fry", "Maren Fry"]
print(name_counts(name_list))

###

myString = "This is the string whose words we would like to count. This string contains some repeated words, as well as some unique words. It contains punctuation, and it contains words that are capitalized in different ways. If the method we write runs correctly, it will count 4 instances of the word 'it', 3 instances of the word 'this', and 3 instances of the word 'count'."

myString = myString.replace(".","") #Remove periods
myString = myString.replace(",","") #Remove commas
myString = myString.replace("'","") #Remove apostrophes
myString = myString.lower() #Make all lower case
mySplitString = myString.split() #Split by spaces

wordDictionary = {} #Create empty dictionary
for word in mySplitString:  #For each word in the split string
    if word in wordDictionary:  #If it's already been found...
        wordDictionary[word] += 1   #Add one to its count
    else:   #Otherwise...
        wordDictionary[word] = 1 #Create it with value 1

print(wordDictionary)

###

seatingChart = {"David" : 3, "Lucy" : 3, "Dana" : 2,
                "Addison" : 2, "Vrushali" : 1, "Bilbo" : 3,
                "Sara" : 1, "Lugos" : 1, "Mireia" : 1,
                "Partha" : 2, "Venijamin" : 1, "Terra" : 2, 
                "Tryphon" : 3, "Gevorg" : 1, "Raza" : 3,
                "Rein" : 3, "Sofia" : 2, "Perle" : 2}

#For each name, table pair in the seating chart
for (name, table) in seatingChart.items():  
    #Print the table for the name
    print(name, " is seated at table #", table, sep="")  

print()
#For each table number
for i in range(1, 4):   
    print("The guests at table #", i, " are: ", sep="", end="")
    #For each name, table pair
    for (name, table) in seatingChart.items():  
        #If the table numer is this number
        if i == table:  
            #Print the name
            print(name, end=" ")    
    print()

###

#Recall in the previous problem you counted the number of
#instances of a certain first name in a list of full names.
#You returned a dictionary with the name as the key, and the
#number of times it appeared as the value.
#
#Modify that code such that instead of having a count as the
#value, you instead have a list of the full names that had
#that first name. So, each key in the dictionary would still
#be a first name, but the values would be lists of names.
#Make sure to sort the list of names, too.
#
#Name this new function name_lists.


#Add your function here!
def name_lists(names):
    name_dict = {}
    for name in names:
        split_name = name.split()
        first_name = split_name[0]
        if not first_name in name_dict:
            name_dict[first_name] = []
        name_dict[first_name].append(name)
    for first_name, full_names in name_dict.items():
        full_names.sort()
    return name_dict


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#{'Shelba': ['Shelba Barthel', 'Shelba Crowley', 'Shelba Fernald', 'Shelba Fry', 'Shelba Odle'],
#'David': ['David Joyner', 'David Zuber'], 'Brenton': ['Brenton Joyner', 'Brenton Zuber'],
#'Maren': ['Maren Fry'], 'Nicol': ['Nicol Barthel']}

name_list = ["David Joyner", "David Zuber", "Brenton Joyner",
             "Brenton Zuber", "Nicol Barthel", "Shelba Barthel",
             "Shelba Crowley", "Shelba Fernald", "Shelba Odle",
             "Shelba Fry", "Maren Fry"]
print(name_lists(name_list))

###

classes = {"Math" : ["David", "Lucy", "Dana"],
           "Physics" : ["Addison", "Vrushali", "Bilbo"],
           "Chemistry" : ["Sara", "Lugos", "Mireia", "Perle"],
           "Computing" : ["Partha", "Venijamin", "Terra", "Sofia"],
           "History" : ["Tryphon", "Gevorg", "Raza", "Rein"]}

print("Students in Computing:", classes["Computing"])
#Add Francis to History
classes["History"].append("Francis")    
print("Students in History:", classes["History"])

###

addressBook = {"David": ("555 Home St", "4045551234", "david@david.com"),
               "Lucy" : ("555 Home St", "4045555678", "lucy@lucy.com"),
               "Dana" : ("123 There Rd", "4045559101", "dana@dana.net")}

print("David's Information:", addressBook["David"])
print("Dana's Phone Number:", addressBook["Dana"][1])

###

addressBook = {"David": {"address" : "555 Home St", "phone" : "4045551234", 
                          "email" : "david@david.com"},
               "Lucy" : {"address" : "555 Home St", "phone" : "4045555678", 
                         "email" : "lucy@lucy.com"},
               "Dana" : {"address" : "123 Here Rd", "phone" : "4045559101", 
                         "email" : "dana@dana.net"}}

print("David's Information:", addressBook["David"])
print("Dana's Phone Number:", addressBook["Dana"]["phone"])

###

ANSWER_KEY = {"1" : "A", "2" : "B", "3" : "C", "4" : "D", "5" : "A"}

students={}
students["David"] = {"1" : "A", "2" : "B", "3" : "A", "4" : "B", "5" : "C"}
students["Terra"] = {"1" : "A", "2" : "B", "3" : "C", "4" : "D", "5" : "A"}
students["Lugos"] = {"1" : "A", "2" : "C", "3" : "C", "4" : "D", "5" : "A"}

#For each student and their answers
for (student, answers) in students.items(): 
    grade = 0   #Start grade at 0
    #For each question and answer
    for (question, answer) in answers.items():  
        #If the answer matches ANSWER_KEY's answer...
        if answer == ANSWER_KEY[question]:  
            grade +=1   #Increment their grade
    #Create a new key "grade" and assign it their grade
    students[student]["grade"] = grade  
#For each student and their answers
for (student, answers) in students.items(): 
    #Print the name and grade
    print(student, ": ", answers["grade"], sep = "", end = "; ")


### PRACTICE PROBLEMS ###

#Write a function called count_characters. count_characters
#should take as input a single string, and return a
#dictionary. In the dictionary, the keys should be
#characters, and the values should be the number of times
#each character appeared in the string.
#
#For example:
#
#  count_characters("aabbccc") -> {'a': 2, 'b': 2, 'c': 3}
#  count_characters("AaBbbb") -> {'A': 1, 'B': 1, 'a': 1, 'b': 3}
#
#You should not need to make any assumptions about the
#characters in the string: spaces, punctuation, line breaks,
#and any other characters should be handled automatically.
#You may count upper and lower case separately.


#Write your function here!
def count_characters(string):
    dictionary = {}
    for letter in string:
        if letter in dictionary:
            dictionary[letter] += 1
        else:
            dictionary[letter] = 1
    return dictionary


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#
#{'a': 2, 'b': 2, 'c': 3}
print(count_characters("aabbccc"))


### PROBLEM SET 1 ###

#Write a function called count_types. count_types
#should take as input a single string, and return a
#dictionary. In the dictionary, the keys should be
#types of characters, and the values should be the
#number of times each type of character appeared in
#the string.
#
#The types of characters that should be handled (and
#thus, the keys in the dictionary) are:
#
# - upper: the count of upper-case or capital letters
# - lower: the count of lower-case letters
# - punctuation: the count of punctuation characters.
#   You may assume this is limited to these punctuation
#   characters: !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
# - space: the count of spaces
# - numeral: the count of numerals, 0123456789
#
#Note, however, that any type of character that does
#NOT appear in the string should not be in the dictionary
#at all.
#
#For example:
#
#count_characters("aabbccc") -> 
# {"lower": 7}
#count_characters("ABC 123 doe ray me!") -> 
# {"upper": 3, "lower": 8, "punctuation": 1, "space": 4, "numeral": 3}
#
#Because the first string has only lower-case letters,
#"lower" is the only key in the dictionary.
#
#HINT: If you're sing the ord() function, capitals of
#ordinals between 65 and 90; lower-case letters have
#ordinals between 97 and 122; numerals are between 48
#and 57; spaces are 32; all other numbers between 33
#and 126 are punctuations, and no character will have
#an ordinal outside that range.


#Write your function here!
def count_types(string):
    dictionary = {}
    upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    lower = "abcdefghijklmnopqrstuvwxyz"
    punctuation = '''!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~'''
    space = " "
    numeral = "0123456789"
    for char in string:
        if char in upper:
            dictionary["upper"] = dictionary.get("upper", 0) + 1
        elif char in lower:
            dictionary["lower"] = dictionary.get("lower", 0) + 1
        elif char in punctuation:
            dictionary["punctuation"] = dictionary.get("punctuation", 0) + 1
        elif char in space:
            dictionary["space"] = dictionary.get("space", 0) + 1
        elif char in numeral:
            dictionary["numeral"] = dictionary.get("numeral", 0) + 1
    return dictionary    

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#
#{"lower": 7}
#{"upper": 3, "lower": 8, "punctuation": 1, "space": 4, "numeral": 3}
print(count_types("aabbccc"))
print(count_types("ABC 123 doe ray me!"))

###

#Write a function called write_movie_info. write_movie_info
#will take as input two parameters: a string and a
#dictionary.
#
#The string will represent the filename to which to write.
#
#The keys in the dictionary will be strings representing
#movie titles. The values in the dictionary will be lists
#of strings representing performers in the corresponding
#movie.
#
#write_movie_info should write the list of movies to the file
#given by the filename using the following format:
#
# Title: Actor 1, Actor 2, Actor 3, etc.
#
#The movies and the actor names should be sorted
#alphabetically.
#
#So, for this dictionary:
#
# {"Chocolat": ["Juliette Binoche", "Judi Dench", "Johnny Depp", "Alfred Molina"],
#  "Skyfall": ["Judi Dench", "Daniel Craig", "Javier Bardem", "Naomie Harris"]}
#
#The file printed would look like this:
#
# Chocolat: Alfred Molina, Johnny Depp, Judi Dench, Juliette Binoche
# Skyfall: Daniel Craig, Javier Bardem, Judi Dench, Naomie Harris
#
#HINT: the keys() method of a Dictionary will return a list
#of the dictionary's keys. So, to get a sorted list of a_dict's
#keys, you could call key_list = a_dict.keys(), then call 
#key_list.sort().


#Write your function here!
def write_movie_info(filename, dictionary):
    file = open(filename, "w")
    for movie in sorted (dictionary):
        file.write(movie + ": ")
        dictionary[movie].sort()
        for actor in range(0, len(dictionary[movie]) - 1):
            file.write(dictionary[movie][actor] + ", ")
        file.write(dictionary[movie][len(dictionary[movie]) - 1] + "\n")
    file.close()
    return        
        

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print nothing -- however, it should write the same contents
#as Sample.txt to Test.txt.
movies = {"Chocolat": ["Juliette Binoche", "Judi Dench", "Johnny Depp", "Alfred Molina"], "Skyfall": ["Judi Dench", "Daniel Craig", "Javier Bardem", "Naomie Harris"]}
write_movie_info("Test.txt", movies)

###

#Imagine you're writing the code for an onboard vehicle
#monitoring system. One thing the system does is measure
#tire pressure. It does this by taking a measurement every
#10 seconds. However, lots of environmental conditions can
#lead to intermittent bad readings: if it takes a reading
#as a car goes over a bump, for example, it will be way
#higher than it would have been otherwise. So, the system
#needs to know to ignore these ratings, as well as only
#process the more recent measurements. Let's tell the system
#that the only valid tire pressures are between 15 and 55.
#
#Write a function called tire_pressure. tire_pressure
#should have one parameter, a list of integers. The list
#represents a series of tire pressure measurements over the
#past several minutes.
#
#tire_pressure should return the average of the last 5
#measurements that are greater than or equal to 15 and less
#than or equal to 55. Round the result to 1 decimal place
#(you can use round(some_float, 1) to round to 1 decimal
#place).
#
#For example, if the list of measurements was this:
#
# [34, 34, 64, 34, 5, 5, 34, 34, 35, 35, 35, 65, 60, 35, 12, 35]
#
#tire_pressure would return 35.0: the last five measurements
#in range are all 35. You may assume there will be at least
#5 measurements in the proper range.


#Add your code here!
def tire_pressure(a_list):
    last_five = []
    count = 0
    a_list.reverse()
    for measurement in a_list:
        if measurement >= 15 and measurement <= 55:
            last_five.append(measurement)
            count += 1
            if count == 5:
                break
    return (sum(last_five) / 5)          


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 35.0
a_list = [45, 44, 8, 43, 43, 43, 41, 41]
print(tire_pressure(a_list))

###











### PROBLEM SET 2 ###

#Write a function called count_types. count_types
#should take as input a single string, and return a
#dictionary. In the dictionary, the keys should be
#types of characters, and the values should be the
#number of times each type of character appeared in
#the string.
#
#The types of characters that should be handled (and
#thus, the keys in the dictionary) are:
#
# - upper: the count of upper-case or capital letters
# - lower: the count of lower-case letters
# - punctuation: the count of punctuation characters.
#   You may assume this is limited to these punctuation
#   characters: !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
# - space: the count of spaces
# - numeral: the count of numerals, 0123456789
#
#All five keys should be in your dictionary no matter
#what; if there are no characters of the corresponding
#type, the value associated with the key would just be 0.
#
#For example:
#
#count_characters("aabbccc") -> 
# {"upper": 0, "lower": 7, "punctuation": 0, "space": 0, "numeral": 0}
#count_characters("ABC 123 doe ray me!") -> 
# {"upper": 3, "lower": 8, "punctuation": 1, "space": 4, "numeral": 3}
#
#HINT: If you're sing the ord() function, capitals of
#ordinals between 65 and 90; lower-case letters have
#ordinals between 97 and 122; numerals are between 48
#and 57; spaces are 32; all other numbers between 33
#and 126 are punctuations, and no character will have
#an ordinal outside that range.


#Write your function here!
def count_types(string):
    dictionary = {"upper": 0, "lower": 0, "punctuation": 0, "space": 0, "numeral": 0}
    upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    lower = "abcdefghijklmnopqrstuvwxyz"
    punctuation = '''!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~'''
    space = " "
    numeral = "0123456789"
    for char in string:
        if char in upper:
            dictionary["upper"] = dictionary.get("upper", 0) + 1
        elif char in lower:
            dictionary["lower"] = dictionary.get("lower", 0) + 1
        elif char in punctuation:
            dictionary["punctuation"] = dictionary.get("punctuation", 0) + 1
        elif char in space:
            dictionary["space"] = dictionary.get("space", 0) + 1
        elif char in numeral:
            dictionary["numeral"] = dictionary.get("numeral", 0) + 1
    return dictionary   


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#
#{"upper": 0, "lower": 7, "punctuation": 0, "spaces": 0, "numerals": 0}
#{"upper": 3, "lower": 8, "punctuation": 1, "spaces": 4, "numerals": 3}
print(count_types("aabbccc"))
print(count_types("ABC 123 doe ray me!"))

###

#Write a function called write_streaming_info.
#write_streaming_info will take as input two parameters: a
#string and a list.
#
#The string will represent the filename to which to write.
#
#Each item in the list will be a tuple. The first item of
#every tuple will be the name of a movie. All remaining items
#in the tuple will be streaming services on which the movie
#appears, such as Hulu, Netflix, Peacock, HBO Max, Amazon,
#Disney+, Peacock, YouTube, Crunchyroll, CBS All Access, etc.
#
#write_streaming_info should write the list of movies to the
#file given by the filename using the following format:
#
# [movie]: Available on Service_1, Service_2, and Service_3
#
#The movies and the streaming service names should appear in
#the order of the original list/tuples.
#
#So, for this list of tuples:
#
# [("Chocolat", "Hulu", "Netflix", "Amazon"),
#  ("Skyfall", "HBO Max", "Amazon"),
#  ("Soul", "Disney+")]
#
#The file printed would look like this:
#
# Chocolat: Available on Hulu, Netflix, and Amazon
# Skyfall: Available on HBO Max and Amazon
# Soul: Disney+
#
#Note that if only one service is listed, just that service
#appears after the colon. If two services are listed, they
#appear separated by 'and' with no commas. If three or more
#services are listed, then there is a comma after every
#service except the last one, and the last one is preceded
#by 'and'.

#
#HINT: Remember, you can use slicing on tuples just like strings.
#a_tuple[:2], for example, will give you the first two items in a
#tuple. a_tuple[3:] will give you all the items from the one at
#index 3 to the end.


#Write your function here!
def write_streaming_info(filename, movies):
    file = open(filename, "w")
    for movie in movies:
        movie_name = movie[0]
        services = movie[1:]
        if len(services) == 1:
            file.write(movie_name + ": " + services[0] + "\n")
        elif len(services) == 2:
            file.write(movie_name + ": " + services[0] + " and " + services[1] + "\n")
        else:
            service_list = ", ".join(services[:-1])
            file.write(movie_name + ": " + service_list + ", and " + services[-1] + "\n")
    file.close()        


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print nothing -- however, it should write the same contents
#as Sample.txt to Test.txt.
movies = [("Chocolat", "Hulu", "Netflix", "Amazon"), ("Skyfall", "HBO Max", "Amazon"), ("Soul", "Disney+")]
write_streaming_info("Test.txt", movies)

###

#Imagine you're writing the code for an intelligent 
#temperature device. The device takes a measurement every
#10 seconds. However, some readings may come up invalid.
#We can assume based on operating conditions that all
#valid temperatures will be between 20 and 80.
#
#Write a function called average_temp. average_temp
#should have one parameter, a list of integers. The list
#represents a series of temperature measurements over the
#past several minutes.
#
#average_temp should return the average of all the last
#five _valid_ (greater than or equal to 20, less than or
#equal to 80) measurements.  Round the result to 1
#decimal place (you can use round(some_float, 1) to round
#to 1 decimal place).
#
#For example, if the list of measurements was this:
#
# [5, 62, 72, 102, 68, 75, 73, 3, 7, 79]
#
#average_temp would return 73.4: the last 5 valid
#measurements are (in reverse order) 79, 73, 75, 68, and
#72. (79 + 73 + 75 + 68 + 72) / 5 = 73.4.
#
#If there are fewer than five valid readings, return the
#averages of however many valid readings there are.


#Add your code here!
def average_temp(measurements):
    last_five = []
    count = 0
    measurements.reverse()
    for measurement in measurements:
        if measurement >= 20 and measurement <= 80:
            last_five.append(measurement)
            count += 1
            if count == 5 or count == len(measurements):
                break
    average = (sum(last_five) / len(last_five))
    return round(average, 1)


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 73.4, then 67.0 (on their own lines)
a_list = [5, 62, 72, 102, 68, 75, 73, 3, 7, 79]
print(average_temp(a_list))

a_list_2 = [5, 62, 72, 102]
print(average_temp(a_list_2))

###









### PROBLEM SET 3 ###

#Write a function called word_count. word_count should take
#as input a list. You may assume every item in the list will
#be a string.
#
#word_count should return a dictionary, where the keys are the
#words and the values are the number of times each word appeared
#in the list. The keys should all be lower-case, and you should
#ignore case when counting words (for instance, "cat", "CAT",
#and "Cat" would all count towards the key "cat").
#
#For example:
#
#  word_count(["cat", "CAT", "dog", "DOG"]) -> {"cat": 2, "dog": 2}
#  word_count(["Georgian", "Tech", "Georgia", "Tech"]) ->
#             {"Georgian": 1, "Tech": 2, "Georgia": 1}


#Write your function here!
def word_count(list):
    dictionary = {}
    for word in list:
        word_lower = word.lower()
        if word_lower in dictionary:
            dictionary[word_lower] += 1
        else:
            dictionary[word_lower] = 1
    return dictionary


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary):
#
#{"cat": 2, "dog": 2}
#{"Georgian": 1, "Tech": 2, "Georgia": 1}
print(word_count(["cat", "CAT", "dog", "DOG"]))
print(word_count(["Georgian", "Tech", "Georgia", "Tech"]))

###

#Write a function called write_teams. write_teams will take
#as input two parameters: a string and a list of 4-tuples.
#
#The string will represent the filename to which to write.
#
#Each 4-tuple in the list will contain four strings. The
#strings will represent (in order) a university name, their
#team mascot, their city, and their state.
#
#write_teams should write the list of teams to the file given
#by the filename using the following format:
#
# [university] [mascot], [city], [state]
#
#Note there is no comma between university and mascot, but
#there is a comma between mascot and city, and city and state.
#
#So, for this list:
#
# [("Georgia Tech", "Yellow Jackets", "Atlanta", "Georgia"),
#  ("Georgia State", "Panthers", "Atlanta", "Georgia")]
#
#The file printed would look like this:
#
#Georgia Tech Yellow Jackets, Atlanta, Georgia
#Georgia State Panthers, Atlanta, Georgia
#
#We've included Sample.txt to show you what one of these
#files should look like.


#Write your function here!
def write_teams(filename, universities):
    file = open(filename, "w")
    for university in universities:
        university_name = university[0]
        mascot = university[1]
        city = university[2]
        state = university[3]
        file.write(university_name + " " + mascot + ", " + city + ", " + state + "\n")
    file.close()


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print nothing -- however, it should write the same contents
#as Sample.txt to Test.txt.
teams = [("Georgia Tech", "Yellow Jackets", "Atlanta", "Georgia"), ("Georgia State", "Panthers", "Atlanta", "Georgia"),
        ("Kennesaw State", "Owls", "Kennesaw", "Georgia"), ("Georgia Southern", "Eagles", "Statesboro", "Georgia")]
write_teams("Test.txt", teams)

###

#Write a function called average_evens_and_odds. The function
#should take as input one parameter, a list of integers. The
#function should return a 2-tuple. The first item in the
#2-tuple should be the average of all even numbers in the list;
#the second item in the 2-tuple should be the average of all
#odd numbers in the list. Round your averages to one decimal
#place.
#
#The list may have some strings interspersed in it. These should
#not affect your calculation.
#
#For example, if this was the input list:
#
# [1, 2, 3, 4, "cat", "tech", 5, 6]
#
#Your function would return the tuple: (4.0, 3.0) because 4.0
#is the average of the three even numbers (2, 4, 6) and 3.0 is
#the average of the three odd numbers (1, 3, 5).
#
#HINT: round(the_num, 1) will return the result of rounding
#the_num to one decimal place.


#Add your code here!
def average_evens_and_odds(a_list):
    odd_integers = []
    even_integers = [] 
    for item in a_list:
        if type(item) == int and item % 2 == 1:
            odd_integers.append(item)
        elif type(item) == int and item % 2 == 0:
            even_integers.append(item)
    odd_average = round((sum(odd_integers) / len(odd_integers)), 1)
    even_average = round((sum(even_integers) / len(even_integers)), 1)
    my_tuple = (even_average, odd_average)
    return my_tuple
    

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: (4.0, 3.0)
a_list = [1, 2, 3, 4, "cat", "tech", 5, 6]
print(average_evens_and_odds(a_list))

###





























