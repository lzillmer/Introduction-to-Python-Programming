### OBJECTS ###

#Define the class Person
class Person:
    #Create a new instance of Person
    def __init__(self):
        #Person's default values
        self.firstname = "[no first name]"
        self.lastname = "[no last name]"
        self.eyecolor = "[no eye color]"
        self.age = -1

###

#Define the class Name
class Name:
    def __init__(self):
        self.firstname = "[no first name]"
        self.lastname = "[no last name]"

#Define the class Person
class Person:
    #Create a new instance of Person
    def __init__(self):
        #Person's default values
        self.name = Name()
        self.eyecolor = "[no eye color]"
        self.age = -1

###

#Write a class named "Phone". The Phone class should 
#have an attribute called "storage" which defaults to
#128, and an attribute called "color" which defaults
#to "red".
#
#Hint: 'attribute' is another common word for
#'instance variable'.


#Write your class here!
class Phone:
    def __init__(self):
        self.storage = 128
        self.color = "red"


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print 128 and red, each on a separate line.
new_phone = Phone()
print(new_phone.storage)
print(new_phone.color)

###

#Define the class Person
class Person:
    #Create a new instance of Person
    def __init__(self):
        #Person's default values
        self.firstname = "[no first name]"
        self.lastname = "[no last name]"
        self.eyecolor = "[no eye color]"
        self.age = -1

#Create a new Person and assign it to myPerson
myPerson = Person()
#Print myPerson's values
print(myPerson.firstname)
print(myPerson.lastname)
print(myPerson.eyecolor)
print(myPerson.age)

###

#Define the class Person
class Person:
    #Create a new instance of Person
    def __init__(self):
        #Person's default values
        self.firstname = "[no first name]"
        self.lastname = "[no last name]"
        self.eyecolor = "[no eye color]"
        self.age = -1

#Create a new Person and assign it to myPerson
myPerson = Person()
#Print myPerson's values
print(myPerson.firstname)
print(myPerson.lastname)
print(myPerson.eyecolor)
print(myPerson.age)

###

#Define the class Name
class Name:
    def __init__(self):
        self.firstname = "[no first name]"
        self.lastname = "[no last name]"

#Define the class Person
class Person:
    def __init__(self):
        self.name = Name()
        self.eyecolor = "[no eye color]"
        self.age = -1

#Create a new Person and assign it to myPerson
myPerson = Person()
#Print myPerson's name's firstname
print(myPerson.name.firstname)
#Change myPerson's name's firstname to David
myPerson.name.firstname = "David"
#Print myPerson's name's firstname
print(myPerson.name.firstname)

###

#Define the class Person
class Person:
    #Create a new instance of Person
    def __init__(self):
        #Person's default values
        self.firstname = "[no first name]"
        self.lastname = "[no last name]"
        self.eyecolor = "[no eye color]"
        self.age = -1

#Create two new Persons and assign them to
#myPerson1 and myPerson2
myPerson1 = Person()
myPerson2 = Person()
myPerson1.firstname = "David"
myPerson2.firstname = "Vrushali"

print("myPerson1: " + myPerson1.firstname)
print("myPerson2: " + myPerson2.firstname)

###

#Write a class named "Number" with one attribute called 
#"value" which defaults to 0 and another attribute called 
#"even" which defaults to True.
#
#Next, create an instance of this class and assign it to
#a variable called "number_instance".
#
#Then, set the value attribute to 101 and the even
#attribute to False.


#Write your code here!
class Number:
    def __init__(self):
        self.value = 0
        self.even = True

number_instance = Number()
number_instance.value = 101
number_instance.even = False

#Note that this exercise does not print anything by
#default. You're welcome to add print statements to debug
#your code when running it. Note that the autograder
#will check both your value for number_instance and your
#definition of the class Number.

###

#Define the class Name
class Name:
    def __init__(self):
        self.firstname = "[no first name]"
        self.lastname = "[no last name]"

#Define dictionaries with keys firstname and lastname
myNameDict = {"firstname" : "David", "lastname" : "Joyner"}

#Define instances of Name
myNameInst = Name()
myNameInst.firstname = "David"
myNameInst.lastname = "Joyner"

print("Dictionary: " + myNameDict["firstname"])
print("Instance: " + myNameInst.firstname)

###

#Define the class Person
class Person:
    #Create a new instance of Person
    def __init__(self, firstname, lastname):
        self.firstname = firstname
        self.lastname = lastname
        self.eyecolor = "[no eye color]"
        self.age = -1

#Creates a person with names David and Joyner
myPerson = Person("David", "Joyner")
print(myPerson.firstname)
print(myPerson.lastname)

###

#Define the class Person
class Person:
    #Create a new instance of Person
    def __init__(self, firstname, lastname):
        self.firstname = firstname
        self.lastname = lastname
        self.eyecolor = "[no eye color]"
        self.age = -1

#Creates a new person
myPerson = Person()
print(myPerson.firstname)
print(myPerson.lastname)

###

#Define the class Person
class Person:
    #Create a new instance of Person
    def __init__(self, firstname="[no first name]",
                 lastname="[no last name"):
        self.firstname = firstname
        self.lastname = lastname
        self.eyecolor = "[no eye color]"
        self.age = -1

myPerson1 = Person()
print(myPerson1.firstname)
myPerson2 = Person(firstname = "David")
print(myPerson2.firstname)
myPerson3 = Person("Vrushali")
print(myPerson3.firstname)

###

#Define the class Person
class Person:
    #Create a new instance of Person
    def __init__(self):
        #Person's default values
        self.firstname = "[no first name]"
        self.lastname = "[no last name]"
        self.eyecolor = "[no eye color]"
        self.age = -1

###

#Rewrite the "Number" class from 5.1.2 Coding Exercise 2.
#This time, however, require arguments for value and
#even in the constructor. Then, inside the constructor,
#create new instance variables called value and even that
#copy the values of the arguments passed into the
#constructor.
#
#In other words, rewrite the Number class such that value
#and even behave the way studentName and enrolled behaved
#in the exercise above, and the way firstname and lastname
#behaved in video 5.1.4.1.
#
#Then, as before, create an instance of this class and
#assign it to a variable called "number_instance". value
#should again be set to 101 and even should be set to
#False.
#
#Hint: Remember, the way you initialize the instance will
#have to change, too, based on the changes to the
#constructor that we're requiring.


#Write your code here!
class Number:
    def __init__(self, a_value, is_even):
        self.value = a_value
        self.even = is_even

number_instance = Number(101, False)


#Note that this exercise does not print anything by
#default. You're welcome to add print statements to debug
#your code when running it. Note that the autograder
#will check both your value for number_instance and your
#definition of the class Number.

###

#Define class BankAccount
class BankAccount:
    #Initialize balance to 0
    def __init__(self, name, balance = 0.0):
        self.log("Account created!")
        self.name = name
        self.balance = balance

    def getBalance(self): #Getter for balance
        self.log("Balance checked at " + str(self.balance))
        return self.balance

    def setBalance(self, newBalance): #Setter for balance
        self.log("Balance changed to " + str(newBalance))
        self.balance = newBalance

    def log(self, message): #Logging method
        myLog = open("Log.txt", "a")
        print(message, file = myLog)
        myLog.close()

myBankAccount = BankAccount("David Joyner")
myBankAccount.setBalance(20.0)
print(myBankAccount.getBalance())

###

#Imagine you're writing an exercise-tracking app like Fitbit
#or MyFitnessPal. Part of your app is that a user can log an
#exercise session by naming the exercise, the intensity, and
#the duration.
#
#Write a class called ExerciseSession. ExerciseSession
#should have a constructor that requires two strings and an
#integer: the strings represent the exercise name and the
#exercise intensity, which will be "Low", "Moderate", or
#"High". The integer will represent the length of the
#exercise session in minutes. These should be saved in the
#instance of the class.
#
#Then, add three getters to the class. The getters should
#be named get_exercise, get_intensity, and get_duration,
#and should return the exercise string, the exercise
#intensity, and the duration, respectively.
#
#The setters should be named set_exercise, set_intensity,
#and set_duration. Each should have one parameter (besides
#self), which should be stored as the new value of
#exercise, intensity, or duration. You may assume only
#valid values will be passed in.
#
#HINT: You don't have to do any logging like you saw in
#the video! That was just an example of one benefit of
#using getters and setters, but this problem does not ask
#you to do that.


#Add your code here!
class ExerciseSession:
    def __init__(self, name, intensity, length):
        self.name = name
        self.intensity = intensity
        self.duration = length
        
    def get_exercise(self):
        return self.name
    
    def set_exercise(self, new_value):
        self.name = new_value
    
    def get_intensity(self):
        return self.intensity

    def set_intensity(self, new_value):
        self.intensity = new_value
    
    def get_duration(self):
        return self.duration

    def set_duration(self, new_value):
        self.duration = new_value

#If your code is implemented correctly, the lines below
#will run error-free. They will result in the following
#output to the console:
#Running
#Low
#60
#Swimming
#High
#30
new_exercise = ExerciseSession("Running", "Low", 60)
print(new_exercise.get_exercise())
print(new_exercise.get_intensity())
print(new_exercise.get_duration())
new_exercise.set_exercise("Swimming")
new_exercise.set_intensity("High")
new_exercise.set_duration(30)
print(new_exercise.get_exercise())
print(new_exercise.get_intensity())
print(new_exercise.get_duration())

###

class BankAccount:
    def __init__(self, name, balance = 0.0):
        self.log("Account created!")
        self.name = name
        self.balance = balance

    def getBalance(self):
        self.log("Balance checked at " + str(self.balance))
        return self.balance

    def deposit(self, amount):
        self.balance += amount
        self.log("+" + str(amount) + ": " + str(self.balance))

    def withdraw(self, amount):
        self.balance -= amount
        self.log("-" + str(amount) + ": " + str(self.balance))

    def log(self, message): ...

myBankAccount = BankAccount("David Joyner")
myBankAccount.deposit(20.0)
print(myBankAccount.getBalance())
myBankAccount.withdraw(10.0)
print(myBankAccount.getBalance())

###

#Previously, you wrote a class called ExerciseSession that
#had three attributes: an exercise name, an intensity, and a
#duration.
#
#Add a new method to that class called calories_burned.
#calories_burned should have no parameters (besides self, as
#every method in a class has). It should return an integer
#representing the number of calories burned according to the
#following formula:
#
# - If the intensity is "Low", 4 calories are burned per
#   minute.
# - If the intensity is "Medium", 8 calories are burned
#   per minute.
# - If the intensity is "High", 12 calories are burned per
#   minute.
#
#You may copy your class from the previous exercise and just
#add to it.


#Add your code here!
class ExerciseSession:
    def __init__(self, name, intensity, length):
        self.name = name
        self.intensity = intensity
        self.duration = length
        
    def get_exercise(self):
        return self.name
    
    def set_exercise(self, new_value):
        self.name = new_value
    
    def get_intensity(self):
        return self.intensity

    def set_intensity(self, new_value):
        self.intensity = new_value
    
    def get_duration(self):
        return self.duration

    def set_duration(self, new_value):
        self.duration = new_value
    
    def calories_burned(self):
        calories_burned = 0
        if self.intensity == "Low":
            calories_burned += (4 * self.duration)
        if self.intensity == "Medium":
            calories_burned += (8 * self.duration)
        if self.intensity == "High":
            calories_burned += (12 * self.duration)
        return calories_burned
    
#If your code is implemented correctly, the lines below
#will run error-free. They will result in the following
#output to the console:
#240
#360
new_exercise = ExerciseSession("Running", "Low", 60)
print(new_exercise.calories_burned())
new_exercise.set_exercise("Swimming")
new_exercise.set_intensity("High")
new_exercise.set_duration(30)
print(new_exercise.calories_burned())

###

#Defines the class Person
class Person:
    def __init__(self, name, eyecolor, age):
        self.name = name
        self.eyecolor = eyecolor
        self.age = age

#Defines the class Name
class Name:
    def __init__(self, firstname, lastname):
        self.firstname = firstname
        self.lastname = lastname

#Creates a person with eyecolor "brown", age 30, and
#a name with firstname "David", lastname "Joyner",
myPerson = Person(Name("David", "Joyner"), "brown", 30)
print(myPerson.name.firstname)
print(myPerson.name.lastname)
print(myPerson.eyecolor)
print(myPerson.age)

###

#Classes can also have references to other instances of
#themselves. Consider this Person class, for example, 
#that allows for an instance of a father and mother
#to be given in the constructor.
#
#Create 3 instances of this class. The first should have 
#the name "Mr. Burdell" with an age of 53. The second
#instance should have a name of "Mrs. Burdell" with an age
#of 53 as well. Finally, make an instance with the name of
#"George P. Burdell" with an age of 25. This final instance
#should also have the father attribute set to the instance 
#of Mr. Burdell, and the mother attribute set to the 
#instance of Mrs. Burdell. Finally, store the instance of 
#George P. Burdell in a variable called george_p. (It does
#not matter what variable names you use for Mr. and Mrs.
#Burdell.)

class Person:
    def __init__(self, name, age, father=None, mother=None):
        self.name = name
        self.age = age
        self.father = father
        self.mother = mother

#Write your code here!

person1 = Person("Mr. Burdell", 53)
person2 = Person("Mrs. Burdell", 53)
george_p = Person("George P. Burdell", 25, father = person1, mother = person2)


#The code below will let you test your code. It isn't used
#for grading, so feel free to modify it. As written, it
#should print George P. Burdell, Mrs. Burdell, and Mr.
#Burdell each on a separate line.
print(george_p.name)
print(george_p.mother.name)
print(george_p.father.name)

###

class Person:
    def __init__(self, name, eyecolor, age):
        self.name = name
        self.eyecolor = eyecolor
        self.age = age

class Name:
    def __init__(self, firstname, lastname):
        self.firstname = firstname
        self.lastname = lastname

myPerson1 = Person(Name("David", "Joyner"), "brown", 30)
myPerson2 = myPerson1
myPerson2.eyecolor = "blue"
print("myPerson1's eyecolor: " + myPerson1.eyecolor)
print("myPerson2's eyecolor: " + myPerson2.eyecolor)

###

#We've given you a class called "Song" that represents
#some basic information about a song. We also wrote a 
#class called "Artist" which contains some basic 
#information about an artist.
#
#Your job is to create three instances of the song class,
#called song_1, song_2, and song_3.
#
#song_1 should have the following attributes:
#   name = "You Belong With Me"
#   album = "Fearless"
#   year = 2008
#   artist.name = "Taylor Swift"
#   artist.label = "Big Machine Records, LLC"
#
#song_2 should have the following attributes:
#   name = "All Too Well"
#   album = "Red"
#   year = 2012
#   artist.name = "Taylor Swift"
#   artist.label = "Big Machine Records, LLC"
#
#song_3 should have the following attributes:
#   name = "Up We Go"
#   album = "Midnight Machines"
#   year = 2016
#   artist.name = "LiGHTS"
#   artist.label = "Warner Bros. Records Inc."
#
#Notice, though, that song_1 and song_2 have the same
#artist and label. That means they should each have the
#SAME instance of artist: do not create separate instances
#of artist for each song.
#
#When your code is done running, there should exist three
#variables: song_1, song_2, and song_3, according to the
#requirements above.

class Artist:
    def __init__(self, name, label):
        self.name = name
        self.label = label

class Song:
    def __init__(self, name, album, year, artist):
        self.name = name
        self.album = album
        self.year = year
        self.artist = artist
        

#Write your code here!
artist_1 = Artist("Taylor Swift", "Big Machine Records, LLC")
artist_2 = Artist("LiGHTS", "Warner Bros. Records Inc.")

song_1 = Song("You Belong With Me", "Fearless", 2008, artist_1)
song_2 = Song("All Too Well", "Red", 2012, artist_1)
song_3 = Song("Up We Go", "Midnight Machines", 2016, artist_2)

###

class Person:
    def __init__(self, name, eyecolor, age):
        self.name = name
        self.eyecolor = eyecolor
        self.age = age

class Name:
    def __init__(self, firstname, lastname):
        self.firstname = firstname
        self.lastname = lastname

def capitalizeName(name):
    name.firstname = name.firstname.upper()
    name.lastname = name.lastname.upper()

myPerson = Person(Name("David", "Joyner"), "brown", 30)
capitalizeName(myPerson.name)
print(myPerson.name.firstname)
print(myPerson.name.lastname)

###

class Person:
    def __init__(self, name, eyecolor, age):
        self.name = name
        self.eyecolor = eyecolor
        self.age = age

class Name:
    def __init__(self, firstname, lastname):
        self.firstname = firstname
        self.lastname = lastname

def capitalizeString(instring):
    instring = instring.upper()

myPerson = Person(Name("David", "Joyner"), "brown", 30)
capitalizeString(myPerson.name.firstname)
capitalizeString(myPerson.name.lastname)
print(myPerson.name.firstname)
print(myPerson.name.lastname)

###

#Below are the two class definitions we supplied previously:
#Artist and Song.
#
#Write a function called "get_song_string". It should accept
#one argument which will be a Song object. It should return
#a string in the following format:
#
# "<song name>" - <artist name> (<song year>)
# e.g: 
# "You Belong With Me" - Taylor Swift (2008)
#
#The quotation marks around the song title should be *part*
#of the string.
#
#Hint: You're writing a function, not a method. That means
#the function get_song_string should not be inside either
#of these classes.

class Artist:
    def __init__(self, name, label):
        self.name = name
        self.label = label

class Song:
    def __init__(self, name, album, year, artist):
        self.name = name
        self.album = album
        self.year = year
        self.artist = artist

def get_song_string(my_song):
    return '"' + my_song.name + '"' + " - " + my_song.artist.name + " (" + str(my_song.year) + ")" 
        
#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: "You Belong With Me" -Taylor Swift (2008)
new_artist = Artist("Taylor Swift", "Big Machine Records, LLC")
new_song = Song("You Belong With Me", "Fearless", 2008, new_artist)
print(get_song_string(new_song))

###

class Person:
    def __init__(self, name, eyecolor, age):
        self.name = name
        self.eyecolor = eyecolor
        self.age = age

class Name:
    def __init__(self, firstname, lastname):
        self.firstname = firstname
        self.lastname = lastname

myPerson1 = Person(Name("David", "Joyner"), "brown", 30)
myPerson2 = Person(myPerson1.name, myPerson1.eyecolor, myPerson1.age)
myPerson2.eyecolor = "blue"
print(myPerson1.eyecolor)
print(myPerson2.eyecolor)
myPerson2.name.firstname = "Vrushali"
print(myPerson1.name.firstname)
print(myPerson2.name.firstname)

###

class Person:
    def __init__(self, name, eyecolor, age):
        self.name = name
        self.eyecolor = eyecolor
        self.age = age

class Name:
    def __init__(self, firstname, lastname):
        self.firstname = firstname
        self.lastname = lastname

myPerson1 = Person(Name("David", "Joyner"), "brown", 30)
myPerson2 = Person(Name(myPerson1.name.firstname, myPerson1.name.lastname),
                   myPerson1.eyecolor, myPerson1.age)
myPerson2.eyecolor = "blue"
print(myPerson1.eyecolor)
print(myPerson2.eyecolor)
myPerson2.name.firstname = "Vrushali"
print(myPerson1.name.firstname)
print(myPerson2.name.firstname)


### PROBLEM SET

#Below is a class representing a person. You'll see the
#Person class has three instance variables: name, age,
#and GTID. The constructor currently sets these values
#via a calls to the setters.
#
#Create a new function called same_person. same_person
#should take two instances of Person as arguments, and
#returns True if they are the same Person, False otherwise.
#Two instances of Person are considered to be the same if
#and only if they have the same GTID. It does not matter
#if their names or ages differ as long as they have the
#same GTID.
#
#You should not need to modify the Person class.

class Person:
    def __init__(self, name, age, GTID):
        self.set_name(name)
        self.set_age(age)
        self.set_GTID(GTID)

    def set_name(self, name):
        self.name = name

    def set_age(self, age):
        self.age = age

    def set_GTID(self, GTID):
        self.GTID = GTID

    def get_name(self):
        return self.name

    def get_age(self):
       return self.age

    def get_GTID(self):
        return self.GTID

#Add your code below!
def same_person(person_1, person_2):
    if person_1.GTID == person_2.GTID:
        return True
    return False


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: True, then False.
person1 = Person("David Joyner", 30, 901234567)
person2 = Person("D. Joyner", 29, 901234567)
person3 = Person("David Joyner", 30, 903987654)
print(same_person(person1, person2))
print(same_person(person1, person3))

###

#Below we have given you the code for three classes: Owner,
#Pet, and Name.
#
#An Owner is defined by two attributes: a Name and a list of
#Pets. The list of pets is initially empty; it can be added
#to later.
#
#A Pet is defined by two attributes: a Name and an Owner.
#
#A Name is defined by two attributes, both strings,
#representing first and last name.
#
#Write a function called get_owner_string that will take as
#input a single instance of Pet. The function should then print
#out the Pet's Owner's name using the following format:
#
#Boggle Joyner's owner is David Joyner.
#
#You will need to access the Pet's first name, pet's last name,
#pet's owner's first name, and pet's owner's last name to
#accomplish this. You may NOT modify the Name, Pet, or Owner
#classes (we will test your code with our own copies of these
#classes, so any changes you make will not be part of our
#grading code).
#
#HINT: To access a pet's name, you would use the_pet.name. So,
#to access only the pet's first name, you would use
#the_pet.name.first. To access a pet's owner's, you would use
#the_pet.owner. So, how would you access the pet's owner's
#first and last name?

class Name:
    def __init__(self, first, last):
        self.first = first
        self.last = last

class Pet:
    def __init__(self, name, owner):
        self.name = name
        self.owner = owner
        
class Owner:
    def __init__(self, name):
        self.name = name
        self.pets = []

#Add your get_owner_string function here!
def get_owner_string(pet):
    pet_first_name = pet.name.first
    pet_last_name = pet.name.last
    owner_first_name = pet.owner.name.first
    owner_last_name = pet.owner.name.last    
    
    return(pet_first_name + " " + pet_last_name + "'s owner is " + owner_first_name + " " + owner_last_name + ".")


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#Boggle Joyner's owner is David Joyner.
#Artemis Joyner's owner is David Joyner.
#Pippin Hepburn's owner is Audrey Hepburn.
owner_1 = Owner(Name("David", "Joyner"))
owner_2 = Owner(Name("Audrey", "Hepburn"))

pet_1 = Pet(Name("Boggle", "Joyner"), owner_1)
pet_2 = Pet(Name("Artemis", "Joyner"), owner_1)
pet_3 = Pet(Name("Pippin", "Hepburn"), owner_2)

owner_1.pets.append(pet_1)
owner_1.pets.append(pet_2)
owner_2.pets.append(pet_3)

print(get_owner_string(pet_1))
print(get_owner_string(pet_2))
print(get_owner_string(pet_3))

###

#This problem uses the same Pet, Owner, and Name classes from
#the previous problem.
#
#In this one, instead of printing a string that lists a single
#pet's owner, you will print a string that lists all of a
#single owner's pets.
#
#Write a function called get_pets_string. get_pets_string should
#have one parameter, an instance of Owner. get_pets_string
#should return a list of that owner's pets according to the
#following format:
#
#David Joyner's pets are: Boggle Joyner, Artemis Joyner

class Name:
    def __init__(self, first, last):
        self.first = first
        self.last = last

class Pet:
    def __init__(self, name, owner):
        self.name = name
        self.owner = owner
        
class Owner:
    def __init__(self, name):
        self.name = name
        self.pets = []

        
#Add your get_pets_string function here!
def get_pets_string(owner):
    owner_first_name = owner.name.first
    owner_last_name = owner.name.last
    pets_list = owner.pets
    
    pets_string = ""
    for pet in pets_list:
        pets_string += pet.name.first + " " + pet.name.last
        if pet != pets_list[-1]:
            pets_string += ", "
    
    return owner_first_name + " " + owner_last_name + "'s pets are: " + pets_string


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#David Joyner's pets are: Boggle Joyner, Artemis Joyner
#Audrey Hepburn's pets are: Pippin Hepburn
owner_1 = Owner(Name("David", "Joyner"))
owner_2 = Owner(Name("Audrey", "Hepburn"))

pet_1 = Pet(Name("Boggle", "Joyner"), owner_1)
pet_2 = Pet(Name("Artemis", "Joyner"), owner_1)
pet_3 = Pet(Name("Pippin", "Hepburn"), owner_2)

owner_1.pets.append(pet_1)
owner_1.pets.append(pet_2)
owner_2.pets.append(pet_3)

print(get_pets_string(owner_1))
print(get_pets_string(owner_2))

###

#This problem uses the same Pet, Owner, and Name classes from
#the previous two problems. In this case, however, we want you
#to modify one of the classes.
#
#Notice that in the previous two problems, we always had to
#create owners and pets in the same order: first create the owner,
#then create the pets, then add the pets to the owner's list
#of pets. If we forgot that last step, then the pet would have
#its owner, but the owner would not have its list of pets.
#We cannot create a pet without an owner (because owner is a
#positional parameter in the constructor __init__), but there
#is nothing forcing us to add the pet to the owner's list of
#pets once created.
#
#Modify the classes below so that when a new instance of Pet
#is created, it is automatically added to its Owner's list of
#pets.
#
#HINT: Remember that the self attribute refers to the instance
#itself. For example, if you wanted your object to say, "add me
#to this_list", you would write the_list.append(self).
#
#HINT 2: If you're stuck, look back at how we added pets to
#owners in test code on the previous problems. 


#Modify one or more of the classes below:
class Name:
    def __init__(self, first, last):
        self.first = first
        self.last = last

class Pet:
    def __init__(self, name, owner):
        self.name = name
        self.owner = owner
        owner.pets.append(self) # Adds pet to owner's list
        
class Owner:
    def __init__(self, name):
        self.name = name
        self.pets = []
        
#Below are some lines of code that will test your edits.
#Specifically, they will print the number of pets in
#each owner's list of pets. Note that you should note
#add to the code below; the correct output should come
#solely from your changes to the code above.
#
#If your code works correctly, this will originally print:
#2
#1
owner_1 = Owner(Name("David", "Joyner"))
owner_2 = Owner(Name("Audrey", "Hepburn"))

pet_1 = Pet(Name("Boggle", "Joyner"), owner_1)
pet_2 = Pet(Name("Artemis", "Joyner"), owner_1)
pet_3 = Pet(Name("Pippin", "Hepburn"), owner_2)

print(len(owner_1.pets))
print(len(owner_2.pets))

###

#Write a class called Thing. The constructor for Thing should
#have two required parameters: its mass and its volume, in
#that order. These should be saved as the object's mass and
#volume attributes, respectively.
#
#Additionally, the object should have two other attributes,
#weight and density. weight should be calculated by multiplying
#the mass by the gravity on earth, 9.8, and rounding to the
#nearest tenth. density should be calculated by dividing mass
#by volume and rounding to the nearest tenth.
#
#When the constructor has finished initalizing the object, it
#should thus have four attributes: mass, volume, weight, and
#density. mass and volume will have the same values given to
#the constructor, and weight and density will be calculated
#based on those values.


#Add your class here!
class Thing:
    def __init__(self, mass, volume):
        self.mass = mass
        self.volume = volume
        self.weight = round((self.mass * 9.8), 1)
        self.density = round((self.mass / self.volume), 1)

    
#The following lines of code will test your object. If it
#is written correctly, they will print:
#10
#5
#98.0
#2.0
#14.0
#75.0
#137.2
#0.2
thing_1 = Thing(10.0, 5.0)
thing_2 = Thing(14.0, 75.0)

print(thing_1.mass)
print(thing_1.volume)
print(thing_1.weight)
print(thing_1.density)
print(thing_2.mass)
print(thing_2.volume)
print(thing_2.weight)
print(thing_2.density)

###

#In many areas, different goods are taxed at different rates.
#Areas may charge higher tax rates for items like alcohol,
#gasoline, and soda, and lower tax rates for items like
#grocery items, medicines, and clothes.
#
#Write a class called PurchasedGood. The constructor for
#PurchasedGood should have one positional parameter called
#price, which is the price of the good as a float. It should
#then have two keyword parameters in this order:
# - category, which is the category the good falls into.
#   category should have a default value of "General".
# - tax, which is the sales tax rate. tax should have a
#   default value of 0.07.
#
#These three values should be stored in attributes called
#'price', 'category', and 'tax'.
#
#Then, add a method called calculate_total. calculate_total
#should calculate the price plus the price times the tax
#rate, then round the result to 2 decimal places and return
#the result. Remember, you can round to two decimal places
#using round(total, 2).


#Add your class here!
class PurchasedGood:
    def __init__(self, price, category = "General", tax = 0.07):
        self.price = price
        self.category = category
        self.tax = tax
        
    def calculate_total(self):
        total = round((self.price + self.price * self.tax), 2)
        return total

#Below are some lines of code that will test your object.
#You can change these lines to test your code in different
#ways.
#
#If your code works correctly, this will originally run
#error-free and print ignoring rounding errors):
#5.0
#General
#0.07
#5.35
#5.0
#Grocery
#0.03
#5.15
good_1 = PurchasedGood(5.00)
print(good_1.price)
print(good_1.category)
print(good_1.tax)
print(good_1.calculate_total())

good_2 = PurchasedGood(5.00, category = "Grocery", tax = 0.03)
print(good_2.price)
print(good_2.category)
print(good_2.tax)
print(good_2.calculate_total())

###

#In Pokemon Go, a Pokemon is defined by several different
#parameters. For simplicity in this problem, we'll say that
#every Pokemon is defined by two parameters: its name, a
#string, and its power level, an integer.
#
#Create a class called Pokemon. The Pokemon class's
#constructor should have two parameters (in addition to self):
#the Pokemon's name and the Pokemon's power. These should be
#assigned to attributes called 'name' and 'power'.
#
#The Pokemon class should also have a method called
#would_defeat. would_defeat will have one parameter: an
#instance of a _different_ Pokemon. would_defeat should
#return True if this Pokemon's power is greater than the
#other Pokemon's power, or False if not.


#Add your code here!
class Pokemon():
    def __init__(self, name, power):
        self.name = name
        self.power = power
    
    def would_defeat(self, other_pokemon):
        return self.power > other_pokemon.power
    


#Below are some lines of code that will test your object.
#You can change these lines to test your code in different
#ways.
#
#If your code works correctly, this will originally run
#error-free and print:
#Pikachu
#500
#False
#True
new_pokemon_1 = Pokemon("Pikachu", 500)
print(new_pokemon_1.name)
print(new_pokemon_1.power)

new_pokemon_2 = Pokemon("Charizard", 2412)
new_pokemon_3 = Pokemon("Squirtle", 312)
print(new_pokemon_1.would_defeat(new_pokemon_2))
print(new_pokemon_1.would_defeat(new_pokemon_3))

###

#Recall in Coding Problem 4.4.4 (and before that, in Coding
#Problem 4.3.9) you built a program for finding the net
#force (magnitude and angle) on an object from several
#individual forces.
#
#In the next two exercises, we're going to convert that
#system into one that uses objects.
#
#To start, create a class called Force. The constructor for
#Force should have two required arguments: magnitude and
#angle. These should be saved to two attributes called
#'magnitude' and 'angle'. You should assume angle is
#initially in degrees, from -180 to 180.
#
#Then, add three methods to Force:
#
# - get_horizontal should return the horizontal component
#   of the force, according to the formula:
#   horizontal = magnitude * cos(angle).
# - get_vertical should return the vertical component of
#   the force, according to the formula:
#   vertical = magnitude * sin(angle).
# - get_angle should return the angle of the force, but
#   should have a keyword parameter called use_degrees.
#   use_degrees should default to True. If use_degrees
#   is true, it should return the angle in degrees; if it
#   is false, it should return the angle in radians.
#
#HINT: Don't overcomplicate this. All we want here is
#a class called Force with four methods: __init__,
#get_horizontal, get_vertical, and get_angle. Note that
#these are not true "getters" even though they have "get"
#in their names: all three will have some reasoning
#beyond just returning a single value.
#
#HINT 2: angle will initially be passed into the
#constructor in degrees. You may store it in either
#degrees or radians. Each approach has different benefits,
#but make sure to keep track of when it's in angles and
#when it's in degrees.

from math import sin, cos, atan2, radians, degrees, sqrt


#Add your code here!
class Force():
    def __init__(self, magnitude, angle):
        self.magnitude = magnitude
        self.angle = angle
    
    def get_horizontal(self):
        self.horizontal = self.magnitude * cos(radians(self.angle))
        return self.horizontal
        
    def get_vertical(self):
        self.vertical = self.magnitude * sin(radians(self.angle))
        return self.vertical
    
    def get_angle(self, use_degrees = True):
        if use_degrees == True:
            return self.angle
        if use_degrees == False:
            return radians(self.angle)
        


#Below are some lines of code that will test your object.
#You can change these lines to test your code in different
#ways.
#
#If your code works correctly, this will originally run
#error-free and print (with room for rounding errors):
#Magnitude: 500
#Horizontal: 250.0
#Vertical: 433.0127018922193
#Angle in Degrees: 60.0
#Angle in Radians: 1.0471975511965976
a_force = Force(500, 60)
print("Magnitude:", a_force.magnitude)
print("Horizontal:", a_force.get_horizontal())
print("Vertical:", a_force.get_vertical())
print("Angle in Degrees:", a_force.get_angle())
print("Angle in Radians:", a_force.get_angle(use_degrees = False))

###

from math import atan2, degrees, radians, sin, cos

#Last problem, you created a new class called Force. Copy that
#class below:
class Force():
    def __init__(self, magnitude, angle):
        self.magnitude = magnitude
        self.angle = angle
    
    def get_horizontal(self):
        self.horizontal = self.magnitude * cos(radians(self.angle))
        return self.horizontal
        
    def get_vertical(self):
        self.vertical = self.magnitude * sin(radians(self.angle))
        return self.vertical
    
    def get_angle(self, use_degrees = True):
        if use_degrees == True:
            return self.angle
        if use_degrees == False:
            return radians(self.angle)

#In this problem, you're going to use that class to calculate
#the net force from a list of forces.
#
#Write a function called find_net_force. find_net_force should
#have one parameter: a list of instances of Force. The
#function should return new instance of Force with the total
#net magnitude and net angle as the values for its magnitude
#and angle attributes.
#
#As a reminder:
#
# - To find the magnitude of the net force, sum all the
#   horizontal components and sum all the vertical components.
#   The net force is the square root of the sum of the squares
#   of the horizontal forces and the vertical foces (i.e.
#   (total_horizontal ** 2 + total_vertical ** 2) ** 0.5)
# - To find the angle of the net force, call atan2 with two
#   arguments: the total vertical and total horizontal
#   forces (in that order).
# - Remember to round both the magnitude and direction to one
#   decimal place. This can be done using round(magnitude, 1)
#   and round(angle, 1).
# - The Force class has three methods: get_horizontal returns
#   a single force's horizontal component. get_vertical
#   returns a single force's vertical component. get_angle
#   returns a single force's angle in degrees (or in radians
#   if you call get_angle(use_degrees = False).
#
#HINT: Don't overcomplicate this. The Force class does a lot
#of your work for you. Use it! You should not need any trig
#functions except atan2, degrees, and radians.


#Add your function here!
def find_net_force(list_of_instances):
    sum_vertical = 0
    sum_horizontal = 0
    
    for instance in list_of_instances:
        sum_vertical += instance.get_vertical()
        sum_horizontal += instance.get_horizontal()
        
        
    total_net_magnitude = (sum_horizontal ** 2 + sum_vertical ** 2) ** 0.5
    total_net_magnitude = round(total_net_magnitude, 1)
    total_net_angle = degrees(atan2(sum_vertical, sum_horizontal))
    total_net_angle = round(total_net_angle, 1)
    
    return Force(total_net_magnitude, total_net_angle)


#Below are some lines of code that will test your object.
#You can change these lines to test your code in different
#ways.
#
#If your code works correctly, this will originally run
#error-free and print:
#103.1
#-14.0

force_1 = Force(50, 90)
force_2 = Force(75, -90)
force_3 = Force(100, 0)
forces = [force_1, force_2, force_3]
net_force = find_net_force(forces)
print(net_force.magnitude)
print(net_force.get_angle())

###

#Here's a long one -- you can do it!
#
#Rewrite the following class so that it uses getters and
#setters for all three variables (title, description,
#completed). The getters should be called: getTitle,
#getDescription,  getCompleted. The setters should be
#called: setTitle, setDescription, setCompleted.
#
#In addition, the setter should check to make sure that
#the new value is the correct type: title and description
#should always be of type str, and completed should always
#be of type bool. If the value is not the right type, set
#the value of the corresponding attribute to None (the
#keyword, not the string "None").
#
#To summarize (and give a to-do list):
# - Create getters and setters for each variable.
# - Check the type of the new value inside the setters,
#   and print an error if it's the wrong type.
#
#Hint: You can check to see if a variable is a string by
#checking the logical expression type(var) == str, where
#var is the variable you're checking. For integers, use
#int instead of str. For floats, use float. For booleans,
#use bool.
#
#Hint 2: Remember to put self before any instance variables
#or methods you're trying to access. For example, to access
#the variable title from within a method, you would need to
#write self.title.


class TodoItem:
    def __init__(self, title, description, completed=False):
        self.title = title
        self.description = description
        self.completed = completed
        
    def getTitle(self):
        return self.title
        
    def setTitle(self, new_value):
        if type(new_value) != str:
            self.title = None
        else:
            self.title = new_value
        
    def getDescription(self):
        return self.description
    
    def setDescription(self, new_value):
        if type(new_value) != str:
            self.description = None
        else:
            self.description = new_value
    
    def getCompleted(self):
        return self.completed
    
    def setCompleted(self, new_value):
        if type(new_value) != bool:
            self.completed = None
        else:
            self.completed = new_value
            
            
        
#Below are some lines of code that will test your class.
#You can change this code to test how your class behaves
#with different variables and method calls.
#
#If your class works correctly, this will originally print:
#Mow
#Mow the lawn
#False
#True
#None
item = TodoItem("Mow", "Mow the lawn")
print(item.getTitle())
print(item.getDescription())
print(item.getCompleted())
item.setCompleted(True)
print(item.getCompleted())
item.setTitle(False)
print(item.getTitle())

###

#The Fibonacci sequence is a number sequence where each
#number is the sum of the previous two numbers. The first
#two numbers are defined as 0 and 1, so the third number is
#1 (0 + 1 = 1), the fourth number is 2 (1 + 1 = 2), the
#fifth number is 3 (1 + 2 = 3), the sixth number is 5
#(2 + 3 = 5), and so on.
#
#Below we've started a class called FibSeq. At any time,
#FibSeq holds two values from the Fibonacci sequence:
#back1 and back2.
#
#Create a new method inside FibSeq called next_number. The
#next_number method should:
#
# - Calculate and return the next number in the sequence,
#   based on the previous 2.
# - Update back2 with the former value of back1, and update
#   back1 with the new next item in the sequence.
#
#This means that consecutive calls to next_number should
#yield each consecutive number from the Fibonacci sequence.
#Calling next_number 5 times would print 1, 2, 3, 5, and 8.


class FibSeq:
    def __init__(self):
        self.back1 = 1
        self.back2 = 0
        
    def next_number(self):
        self.next = self.back1 + self.back2
        self.back2 = self.back1
        self.back1 = self.next
        return self.next
        

#The code below will test your method. It's not used for
#grading, so feel free to change it. As written, it should
#print 1, 2, 3, 5, and 8.
newFib = FibSeq()
print(newFib.next_number())
print(newFib.next_number())
print(newFib.next_number())
print(newFib.next_number())
print(newFib.next_number())

















### ALGORITHMS ###

#Let's implement the factorial function we saw in the
#previous video in Python!
#
#Our factorial function should take as input a number, and
#it should return the product of that number times every
#number between itself and 1.

#Let's start with the function definition. This function
#definition creates the function factorial with one
#parameter, n.

def factorial(n):
    #What do we want to do inside the function? Well, there
    #are two cases. First, if n is 1, we just want to return
    #1. After all, 1! is 1.
    
    if n == 1:
        return 1
    
    #What if n doesn't equal 1, though? Then we want to
    #return n times the factorial of (n - 1). After all,
    #5! = 5 * 4!, 4! = 4 * 3!, etc.
    
    else:
        return n * factorial(n - 1)
    
    #If n is greater than 1, then it multiplies 1 by the
    #factorial of n - 1, as calculated with the same
    #function. Every time factorial() runs, n decreases
    #by 1, which guarantees that eventually, n will equal
    #1.

#Now let's test it out! Run this file to see the results.
print("5! is", factorial(5))
print("10! is", factorial(10))

#Want to see more about how this works? Select the other
#file, FactorialwithPrints.py, from the drop-down in the
#top left to see a version of this that traces the output.

###

#We've written a function below called count_down(). This
#function takes an int parameter, start, and prints every
#number from that start to 0. The way we've written it uses
#recursion. Below that funtion, write a function that does
#the exact same thing, but do not use recursion.
#
#The purpose of this exercise is for you to recognize some
#example instances in which you can use recursion, and what
#differences can be seen in the actual code.
#
#Make sure to actually print 0 as the last number!

def count_down(start):
    #If we've reached 0 already, print 0 but do not call
    #another copy
    if start <= 0:
        print(start)
    
    #If we haven't reached 0 yet, print the current number,
    #then call count_down with the current number minus 1.
    else:
        print(start)
        count_down(start - 1)
        
#Do not modify the code above.
#Fill in the function below to do the same as the function
#above, but without recursion. You could use for loops,
#while loops, or some other approach.

def count_down2(start):
    while start >= 0:
        print(start)
        start -= 1

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 5, 4, 3, 2, 1, 0, each on their own line.
count_down2(5)

###

#Let's implement the Fibonacci function we saw in the
#previous video in Python!
#
#Like our Factorial function, our Fibonacci function
#should take as input one parameter, n, an integer. It
#should calculate the nth Fibonacci number. For example,
#fib(7) should give 13 since the 7th number in
#Fibonacci's sequence is 13.

#So, our function definition will basically be the same:

def fib(n):
    #What do we want to do inside the function? Once again,
    #there are really only two cases: either we're looking
    #for the first two Fibonacci numbers, or we're not.
    #What happens if we're looking for the first two? Well,
    #we already know that the 1st and 2nd Fibonacci numbers
    #are both 1, so if n == 1 or n == 2, we can go ahead
    #and return 1.
    
    if n == 1 or n == 2:
        return 1
    
    #What if n doesn't equal 1? For any value for n greater
    #than 2, the result should be the sum of the previous
    #two numbers. The previous Fibonacci number could then
    #be calculated with the same kind of function call,
    #decrementing n by 1 or 2.
    
    else:
        return fib(n - 1) + fib(n - 2)
    
    #If n is greater than 2, then it returns the sum of the
    #previous two fibonacci numbers, as calculated by the
    #same function.

#Now let's test it out! Run this file to see the results.
print("fib(5) is", fib(5))
print("fib(10) is", fib(10))

#Want to see more about how this works? Select the other
#file, FibonacciwithPrints.py, from the drop-down in the
#top left to see a version of this that traces the output.

###

#We've started a recursive function below called
#exponent_calc(). It takes in two integer parameters, base
#and expo. It should return the mathematical answer to
#base^expo. For example, exponent_calc(5, 3) should return
#125: 5^3 = 125.
#
#The code is almost done - we have our base case written.
#We know to stop recursing when we've reached the simplest
#form. When the exponent is 0, we return 1, because anything
#to the 0 power is 1. But we are missing our recursive call!
#
#Fill in the marked line with the recursive call necessary
#to complete the function. Do not use the double-asterisk
#operator for exponentiation. Do not use any loops.
#
#Hint: Notice the similarity between exponentiation and
#factorial:
#  4! = 4! = 4 * 3!, 3! = 3 * 2!, 2! = 2 * 1
#  2^4 = 2 * 2^3, 2^3 = 2 * 2^2, 2^2 = 2 * 2^1, 2^1 = 2 * 2^0

def exponent_calc(base, expo):
    if expo == 0:
        return 1
    else:
        return base * exponent_calc(base, expo - 1)

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 125
print(exponent_calc(5, 3))

###

#We've written the function, sort_with_bubbles, below. It takes
#in one list parameter, lst. However, there are two problems in
#our current code:
# - There's a missing line
# - There's a semantic error (the code does not raise an
#   error message, but it does not perform correctly)
#
#Find and fix these problems! Note that you should only need
#to change or add code where explicitly indicated.
#
#Hint: If you're stuck, use an example input list and trace
#the code and how it modifies your list on paper. For
#example, try writing out what happens to the following list:
#
#  [34, 16, 2, 78, 4, 6, 1]

def sort_with_bubbles(lst):
    #Set swap_occurred to True to guarantee the loop runs once
    swap_occurred = True
    
    #Run the loop as long as a swap occurred the previous time
    while swap_occurred:
        
        #Start off assuming a swap did not occur
        swap_occurred = False
        
        #For every item in the list except the last one...
        for i in range(len(lst) - 1):

            #If the item should swap with the next item...
            if lst[i] > lst[i + 1]:

                #Then, swap them! But these lines aren't
                #quite right: fix this code!
                temp = lst[i] #temp is 34, lst[i] is 34
                lst[i] = lst[i + 1] #lst[i] is 16
                lst[i + 1] = temp #lst[i+1] is 34
                
                #One more line is needed here; add it!
                swap_occurred = True

    return lst

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: [1, 2, 3, 4, 5]
print(sort_with_bubbles([5, 3, 1, 2, 4]))

###
#We've written the function, sort_with_select, below. It takes
#in one list parameter, a_list. Our version of selection sort
#involves finding the minimum value and moving it to an
#earlier spot in the list.
#
#However, some lines of code are blank. Complete these lines
#to complete the selection_sort function. You should only need
#to modify the section marked 'Write your code here!'

def sort_with_select(a_list):
    
    #For each index in the list...
    for i in range(len(a_list)):
        
        #Assume first that current item is already correct...
        minIndex = i

        #For each index from i to the end...
        for j in range(i + 1, len(a_list)):
            
            #Complete the reasoning of this conditional to
            #complete the algorithm! Remember, the goal is
            #to find the lowest item in the list between
            #index i and the end of the list, and store its
            #index in the variable minIndex.
            #
            #Write your code here!
            if a_list[j] < a_list[minIndex]:
                minIndex = j

        #Save the current minimum value since we're about
        #to delete it
        minValue = a_list[minIndex]
        
        #Delete the minimum value from its current index
        del a_list[minIndex]
        
        #Insert the minimum value at its new index
        a_list.insert(i, minValue)
    
    #Return the resultant list
    return a_list
	

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: [1, 2, 3, 4, 5]
print(sort_with_select([5, 3, 1, 2, 4]))

###

#Let's implement Mergesort! This is a complex problem
#because it applies recursion to sorting algorithms, but
#it's also by far the most efficient sorting algorithm we'll
#cover.

#First, we need a function definition: MergeSort should take
#as input one list.

def mergesort(lst):
    
    #Then, what does it do? mergesort should recursively
    #run mergesort on the left and right sides of lst until
    #it's given a list only one item. So, if lst has only
    #one item, we should just return that one-item list.
    
    if len(lst) <= 1:
        return lst
    
    #Otherwise, we should call mergesort separately on the
    #left and right sides. Since each successive call to
    #mergesort sends half as many items, we're guaranteed
    #to eventually send it a list with only one item, at
    #which point we'll stop calling mergesort again.
    else:

        #Floor division on the length of the list will
        #find us the index of the middle value.
        midpoint = len(lst) // 2

        #lst[:midpoint] will get the left side of the
        #list based on list slicing syntax. So, we want
        #to sort the left side of the list alone and
        #assign the result to the new smaller list left.
        left = mergesort(lst[:midpoint])

        #And same for the right side.
        right = mergesort(lst[midpoint:])

        #So, left and right now hold sorted lists of
        #each half of the original list. They might
        #each have only one item, or they could each
        #have several items.

        #Now we want to compare the first items in each
        #list one-by-one, adding the smaller to our new
        #result list until one list is completely empty.

        newlist = []
        while len(left) and len(right) > 0:

            #If the first number in left is lower, add
            #it to the new list and remove it from left
            if left[0] < right[0]:
                newlist.append(left[0])
                del left[0]

            #Otherwise, add the first number from right
            #to the new list and remove it from right
            else:
                newlist.append(right[0])
                del right[0]

        #When the while loop above is done, it means
        #one of the two lists is empty. Because both
        #lists were sorted, we can now add the remainder
        #of each list to the new list. The empty list
        #will have no items to add, and the non-empty
        #list will add its items in order.

        newlist.extend(left)
        newlist.extend(right)

        #newlist is now the sorted version of lst! So,
        #we can return it. If this was a recursive call
        #to mergesort, then this sends a sorted half-
        #list up the ladder. If this was the original
        #call, then this is the final sorted list.

        return newlist

#Let's try it out!
print(mergesort([2, 5, 3, 8, 6, 9, 1, 4, 7]))

#It works! To see more about how it works, check out
#MergesortwithPrints.py. To get a succinct version of
#this algorithm, checkout MergesortShort.py.

###


#Write a function called linear() that takes two parameters
#- a list of strings and a string. Write this function so
#that it returns the first index at which the string is
#found within the list if the string is found, or False if
#it is not found. You do not need to worry about searching
#for the search string inside the individual strings within
#the list: for example, linear(["bobby", "fred"], "bob")
#should return False, but linear(["bob", "fred"], "bob")
#should return 0.
#
#Use a linear search algorithm (not as scary as it sounds).
#Do not use the list method index -- in this exercise,
#you're actually implementing the way the index method
#works!


#Write your code here!
def linear(a_list, a_string):
    for item in range(len(a_list)):
        if a_list[item] == a_string:
            return item
    return False

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 3
a_list = [5, 1, 3, 6, 7, 3, 1, 6, 7, 8, 3, 6]
print(linear(a_list, 6))

###

#Let's implement a binary search using a loop! For now,
#our search will just return True if the item is found,
#False if it's not.

#Like our linear search, our binary search needs to
#parameters: a list to search, and an item to search for.

def binary_search(searchList, searchTerm):

    #First, the list must be sorted.
    searchList.sort()

    #Now, each iteration of the loop, we want to narrow
    #down the part of the list to look at. So, we need to
    #keep track of the range we've narrowed down to so
    #far. Initially, that will be the entire list, from
    #the first index to the last.
    
    min = 0
    max = len(searchList) - 1
    
    #Now, we want to loop as long as our range has any
    #numbers left to investigate. As long as there is
    #more than one number between minimum and maximum,
    #we're not done searching.
    
    while min <= max:

        #We want to check the middle item of the
        #current range, which is the average of the
        #current minimum and maximum index. For
        #example, if min was 5 and max was 15, our
        #middle number would be at index 5. We'll
        #use floor division because indices must be
        #integers.
        currentMiddle = (min + max) // 2

        #If the term in the middle is the term we're
        #looking for, we're done!
        if searchList[currentMiddle] == searchTerm:
            return True

        #If not, we want to check if the term we're
        #looking for should come earlier or later.

        #If the term we're looking for is less than
        #the current middle, then search the first
        #half of the list:
        elif searchTerm < searchList[currentMiddle]:
            max = currentMiddle - 1

        #If the term we're looking for is greater
        #than the current middle, search the second
        #half of the list:
        else:
            min = currentMiddle + 1

        #Each iteration of the loop, one of three
        #things happens: the term is found, max
        #shrinks, or min grows. Eventually, either
        #the term will be found, or min will be
        #equal to max.

    #If the search term was found, this line will
    #never be reached because the return statement
    #will end the function. So, if we get this
    #far, then the search term was not found, and
    #we can return False.
    return False

#Let's try it out!
intlist = [12, 64, 23, 3, 57, 19, 1, 17, 51, 62]
print("23 is in intlist:", binary_search(intlist, 23))
print("50 is in intlist:", binary_search(intlist, 50))

#Want to see something else interesting? Because of
#the way Python handles types, this exact same
#function works for any sortable data type. Check
#it out with strings:
strlist = ["David", "Joshua", "Marguerite", "Jackie"]
print("David is in strlist:", binary_search(strlist, "David"))
print("Lucy is in strlist:", binary_search(strlist, "Lucy"))

#Or with dates!
from datetime import date
datelist = [date(1885, 10, 13), date(2014, 11, 29), date(2016, 11, 26)]
print("10/13/1885 is in datelist:", binary_search(datelist, date(1885, 10, 13)))
print("11/28/2015 is in datelist:", binary_search(datelist, date(2015, 11, 28)))


#Now, go see how it works with recursion instead of loops
#in RecursiveBinarySearch.py! Or, print how this works with
#LoopingBinarySearchwithPrints.py.

###

#We've started a recursive function below called
#measure_string that should take in one string parameter,
#myStr, and returns its length. However, you may not use
#Python's built-in len function.
#
#Finish our code. We are missing the base case and the
#recursive call.
#
#HINT: Often when we have recursion involving strings, we
#want to break down the string to be in its simplest form.
#Think about how you could splice a string little by little.
#Then think about what your base case might be - what is
#the most basic, minimal string you can have in python?
#
#Hint 2: How can you establish the base case has been
#reached without the len() function?

#You may not use the built-in 'len()' function.

def measure_string(myStr):
    if myStr == "":
    	return 0
    else:
        return 1 + measure_string(myStr[1:])
    
    
#The line below will test your function. As written, this
#should print 13. You may modify this to test your code.
print(measure_string("13 characters"))

###

#Remember that Fibonacci's sequence is a sequence of numbers
#where every number is the sum of the previous two numbers.
#
#For this problem, implement Fibonacci recursively, with a
#twist! Imagine that we want to create a new number sequence
#called Fibonacci-3. In Fibonacci-3, each number in the
#sequence is the sum of the previous three numbers. The
#sequence will start with three 1s, so the fourth Fibonacci-3
#number would be 3 (1+1+1), the fifth would be 5 (1+1+3),
#the sixth would be 9 (1+3+5), the seventh would be 17
#(3+5+9), etc.
#
#Name your function fib3, and make sure to use recursion.


#Write your code here!
def fib3(n):
    if n == 1 or n == 2 or n == 3:
        return 1
    else:
        return fib3(n-1) + fib3(n-2) + fib3(n-3)

#The lines below will test your code. If your funciton is
#correct, they will print 1, 3, 17, and 57.
print(fib3(3))
print(fib3(4))
print(fib3(7))
print(fib3(9))

###

#Recall in the lesson on sorts that we had you complete the
#Bubble and Selection sort, and we showed you Merge sort.
#We didn't show any of insertion sort, and I bet you can
#guess why.
#
#Implement insertion sort below.
#
#Name your function 'insertion'. insertion should take as
#input a list, and return as output a sorted list. Note that
#even though technically a sorting method does not have to
#return the sorted list, yours should.
#
#If you're stuck on where to start, or having trouble
#visualizing or understanding how exactly insertion sort
#works, check out this website - https://visualgo.net/sorting
#It provides a visual representation of all of the sorting
#algorithms as well as pseudocode you can base your own code
#off of.


#Write your code here!
def insertion(my_list):
    for i in range(len(my_list)):
        current_element = my_list[i]
        
        # move elements to the right until position is found
        position = i
        while position > 0 and my_list[position - 1] > current_element:
            my_list[position] = my_list[position - 1]
            position -= 1
        
        my_list[position] = current_element

    return my_list

#The code below will test your function. If your function
#works, it will print: [1, 2, 3, 4, 5].
print(insertion([5, 1, 3, 2, 4]))

###

#Recall in 5.2.4 Worked Example 1, we gave you the code for
#merge_sort. You may copy that code into this problem and
#modify it. Change it such that instead of sorting from
#lowest to highest, it sorts from highest to lowest.
#
#Name your function sort_with_merge(). For example, if you call
#merge_sort([5, 3, 1, 2, 4]), you would get [5, 4, 3, 2, 1].
#
#Do not use Python's sort or reverse methods to complete
#this.


#Write your code below!
def sort_with_merge(my_list):
    if len(my_list) <= 1:
        return my_list
    else:
        midpoint = len(my_list) // 2
        left = sort_with_merge(my_list[:midpoint])
        right = sort_with_merge(my_list[midpoint:])
    
    newlist = []
    while left and right:
        if left[0] >= right[0]:
            newlist.append(left[0])
            left = left[1:]
            
        else:
            newlist.append(right[0])
            right = right[1:]
     
    newlist.extend(left)
    newlist.extend(right)
    
    return newlist
        

#The code below will test your function. If it works, this
#will print [5, 3, 1, -1, -3, -5].
print(sort_with_merge([1, 3, -1, -3, -5, 5]))

###

#Write a function called search_for_string() that takes two
#parameters, a list of strings, and a string. This function
#should return a list of all the indices at which the
#string is found within the list.
#
#You may assume that you do not need to search inside the
#items in the list; for examples:
#
#  search_for_string(["bob", "burgers", "tina", "bob"], "bob")
#      -> [0,3]
#  search_for_string(["bob", "burgers", "tina", "bob"], "bae")
#      -> []
#  search_for_string(["bob", "bobby", "bob"])
#      -> [0, 2]
#
#Use a linear search algorithm to achieve this. Do not
#use the list method index.
#
#Recall also that one benefit of Python's general leniency
#with types is that algorithms written for integers easily
#work for strings. In writing search_for_string(), make sure
#it will work on integers as well -- we'll test it on
#both.


#Write your code here!
def search_for_string(lst, search_word):
    matches = []
    index = 0
    for word in lst:
        if word == search_word:
            matches.append(index)
        index += 1
    return matches
        


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: [1, 4, 5]
sample_list = ["artichoke", "turnip", "tomato", "potato", "turnip", "turnip", "artichoke"]
print(search_for_string(sample_list, "turnip"))

###







### FINAL PROBLEM SET ###

#To help streamline certain development activities, ISO
#(the International Organization for Standardization) provides
#a table of codes, short abbreviations, and long abbreviations
#for every nation in the world. We have created a class called
#Nation to structure this information. The Nation class
#contains 6 attributes:
#
# - short_name: The short, common form of a country's name,
#   such as "Albania".
# - long_name: The long, official form of a country's name,
#   such as "Republic of Albania".
# - iso_code: The numeric code corresponding to the nation,
#   such as 8.
# - iso_short: The short abbreviation corresponding to the
#   nation, such as AL.
# - iso_long: The long abbreviation corresponding to the
#   nation, such as ALB.
# - capital: The capital city, such as Tirana.
#
#To let you debug, we've provided you the class here. Your
#code will have access to this.
class Nation:
    def __init__(self, short_name, long_name, iso_code, iso_short, iso_long, capital):
        self.short_name = short_name
        self.long_name = long_name
        self.iso_code = iso_code
        self.iso_short = iso_short
        self.iso_long = iso_long
        self.capital = capital

#Write a function called to_dictionaries that will take as
#input a list of instances of this class. It should return a
#dictionary of dictionaries. The keys for the dictionaries
#should be the short names of the nations. The values should
#be additional dictionaries, each with five keys: long_name,
#iso_code, iso_short, iso_long, and capital.
#
#For example, if we created two instances of Nation like this:
#new_nation_1 = Nation("Albania", "Republic of Albania", 8, "AL", "ALB", "Tirana")
#new_nation_2 = Nation("Angola", "Republic of Angola", 24, "AO", "AGO", "Luanda")
#
#...then made them into a list like this:
#nation_list = [new_nation_1, new_nation_2]
#
#...then called the function:
#new_dict = to_dictionaries(nation_list)
#
#...then we would get this dictionary in return:
#{"Albania": {"long_name": "Republic of Albania", "iso_code": 8, "iso_short": "AL", "iso_long": "ALB", "capital": "Tirana"},
# "Angola": {"long_name": "Republic of Angola", "iso_code": 24, "iso_short": "AO", "iso_long": "AGO", "capital": "Luanda"}}
#
#HINT: This problem looks long, but don't overcomplicate
#it. Each part is something you've done lots of times:
#iterate through a list of instances, get the key, create
#a new dictionary, add the other key-values one-by-one,
#and return the overall dictionary.


#Add your code here!
def to_dictionaries(list_of_instances):
    dictionary = {}
    for instance in list_of_instances:
        mini_dictionary = {}
        mini_dictionary["long_name"] = instance.long_name
        mini_dictionary["iso_code"] = instance.iso_code
        mini_dictionary["iso_short"] = instance.iso_short
        mini_dictionary["iso_long"] = instance.iso_long
        mini_dictionary["capital"] = instance.capital
        dictionary[instance.short_name] = mini_dictionary
            
    return dictionary


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print (although the order of the keys may vary) the
#sample dictionaries shown in the directions.
new_nation_1 = Nation("Albania", "Republic of Albania", 8, "AL", "ALB", "Tirana")
new_nation_2 = Nation("Angola", "Republic of Angola", 24, "AO", "AGO", "Luanda")
nation_list = [new_nation_1, new_nation_2]
print(to_dictionaries(nation_list))

###

#In this problem, we're going to explore a little of how
#game AI works. We'll do this with a simple problem: building
#an agent to play the popular card game Blackjack.
#
#Blackjack is a card game played with a standard 52-card
#deck. Suits do not matter in Blackjack, and so we'll just
#use letters to indicate the different cards: A, 2, 3, 4, 5,
#6, 7, 8, 9, 0 (for 10), J, Q, K. Note that the number 10 is
#represented by the single character 0.
#
#The goal of Blackjack is to get as close to 21 points as
#possible without going higher. Each of the thirteen cards
#above has a point total attached: the numerals are worth
#their given value (2 points for 2, 7 points for 7, etc.).
#J, Q, and K are worth 10 points. A is worth either 1 or 11
#points, whichever is better for the player.
#
#At any time, the player has some number of cards in their
#hand. They must then make a decision of whether to Hit or
#Stay. Hit means they request an additional card, Stay means
#they stop with their current total. Players generally try
#to Hit until it is likely that another card will push them
#over 21. For example, if a player has a 5 and a 7, there is
#a relatively low chance that another card would push them
#over 21 (only J, Q, and K would do so, since 12 + 10 = 22).
#On the other hand, if they have a 5, a 6, and a 7, they will
#likely stay because any card above 3 will push them over 21
#points.
#
#The specific goal in Blackjack is to get closer to 21 than
#the dealer. Dealers must follow a set of prescribed rules
#for when to Hit and Stay. These are the rules we'll use for
#our Blackjack-playing AI.
#
#The rules are:
#
# - The dealer must Hit if their total is below 17.
# - The dealer must Stay as soon as their total is 17 or
#   higher.
# - An Ace (A) should be counted as 11 if it puts the
#   dealer between 17 and 21 points. If it puts them over
#   21, though, it should be counted as 1.
#
#For example, imagine the dealer's first cards are A and 3.
#Their point total is either 4 or 14, both below 17, so they
#Hit. The next card is a 9. If we count the A as 11, then
#their total is now 23 (11 + 3 + 9), and so we count the
#A as 1. Their total is 13, and so they Hit again. The next
#card is a 7, so their total is 20, so they Stay.
#
#Write a function called next_move. next_move should have
#one parameter, a string. Each character of the string will
#be a card in the dealer's current hand, such as "AK" or
#"175". The function should return one of three strings:
#
# - "Hit" if the dealer should take another card.
# - "Stay" if the dealer should not take another card.
# - "Bust" if the sum is already over 21.
#
#Remember, your function is only responsible for playing
#one move at a time. Take in a string representing the
#current hand, return "Hit", "Stay", or "Bust".


#Add your code here!
def next_move(string):
    sum = 0
    for char in string:
        if char in "123456789":
            sum += int(char)
        if char in "0JQK":
            sum += 10
        if char == "A":
            if 6 <= sum <= 10:
                sum += 10
            else:
                sum += 1
    if "A" in string:
        if sum == 11:
            sum = 21
    if sum < 17:
        return "Hit"
    if 21 >= sum >= 17:
        return "Stay"
    if sum > 17:
        return "Bust"


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: Hit, Hit, Stay, and Bust.
print(next_move("A55"))

###

#Earlier in the course, you implemented a function that could
#find if someone had won a particular game of either tic-tac-
#toe or mancala based on a 2D list or tuple representing the
#current game board.
#
#In this problem, you'll do the same thing, but for the game
#Connect 4. Write a function called check_winner which takes
#as input a 2D list. It should return "X" if there are four
#adjacent "X" values anywhere in the list (row, column,
#diagonal); "O" if there are four adjacent "O" values
#anywhere in the list; and None if there are neither.
#
#Here are the ways Connect-4 is different from tic-tac-toe:
#
# - Connect-4 is played with 6 rows and 7 columns, not 3
#   rows and 3 columns.
# - You must have 4 in a row (or column or diagonal) to win
#   instead of 3.
# - You may only place pieces in the bottom-most empty
#   space in a column (e.g. you "drop" the pieces in the
#   column and they fall to the first empty spot). Note,
#   though, that this shouldn't affect your reasoning.
#
#To keep things simple, we'll still use "X" and "O" to
#represent the players, and None to represent empty spots.
#You may assume there will be only one winner per board,
#no characters besides "X", "O", and None, and you don't
#have to worry about whether the board is actually a
#valid game of Connect 4.
#
#Hints:
# - Don't forget both kinds of diagonals, top-left to
#   bottom-right and bottom-left to top-right.
# - This board is too large to check every possible place
#   for a winner: there are 69 places a player could win.
# - Remember, if you put a negative index in a list,
#   Python "wraps around" and checks the last value. You
#   may have to control for this.


#Write your function here!
def check_winner(board):
    rows = 6
    cols = 7

    for row in range(rows):
        for col in range(cols - 3):
            if board[row][col] == board[row][col + 1] == board[row][col + 2] == board[row][col + 3] and board[row][col] is not None:
                return board[row][col]

    for col in range(cols):
        for row in range(rows - 3):
            if board[row][col] == board[row + 1][col] == board[row + 2][col] == board[row + 3][col] and board[row][col] is not None:
                return board[row][col]

    for row in range(3, rows):
        for col in range(cols - 3):
            if board[row][col] == board[row - 1][col + 1] == board[row - 2][col + 2] == board[row - 3][col + 3] and board[row][col] is not None:
                return board[row][col]

    for row in range(rows - 3):
        for col in range(cols - 3):
            if board[row][col] == board[row + 1][col + 1] == board[row + 2][col + 2] == board[row + 3][col + 3] and board[row][col] is not None:
                return board[row][col]

    return None
    


#The code below tests your function on three Connect-4
#boards. Remember, the line breaks are not needed to create
#a 2D tuple; they're used here just for readability.
xwins = ((None, None, None, None, None, None, None),
         (None, None, None, None, None, None, None),
         (None, None, None, None, "X" , None, None),
         (None, None, None, "X" , "O" , "O", None),
         (None, "O" , "X" , "X" , "O" , "X", None),
         ("O" , "X" , "O" , "O" , "O" , "X" , "X"))
owins = ((None, None, None, None, None, None, None),
         (None, None, None, None, None, None, None),
         ("O" , "O" , "O" , "O" , None, None, None),
         ("O" , "X" , "X" , "X" , None, None, None),
         ("X" , "X" , "X" , "O" , "X" , None, None),
         ("X" , "O" , "O" , "X" , "O" , None, None))
nowins =(("X" , "X" , None, None, None, None, None),
         ("O" , "O" , None, None, None, None, None),
         ("O" , "X" , "O" , "O" , None, "O" , "O" ),
         ("O" , "X" , "X" , "X" , None, "X" , "X" ),
         ("X" , "X" , "X" , "O" , "X" , "X" , "O" ),
         ("X" , "O" , "O" , "X" , "O" , "X" , "O" ))
         
print(check_winner(xwins))
print(check_winner(owins))
print(check_winner(nowins))


###

#A common problem in academic settings is plagiarism
#detection. Fortunately, software can make this pretty easy!
#
#In this problem, you'll be given two files with text in
#them. Write a function called check_plagiarism with two
#parameters, each representing a filename. The function
#should find if there are any instances of 5 or more
#consecutive words appearing in both files. If there are,
#return the longest such string of words (in terms of number
#of words, not length of the string). If there are not,
#return the boolean False.
#
#For simplicity, the files will be lower-case text and spaces
#only: there will be no punctuation, upper-case text, or
#line breaks.
#
#We've given you three files to experiment with. file_1.txt
#and file_2.txt share a series of 5 words: we would expect
#check_plagiarism("file_1.txt", "file_2.txt") to return the
#string "if i go crazy then". file_1.txt and file_3.txt
#share two series of 5 words, and one series of 11 words:
#we would expect check_plagiarism("file_1.txt", "file_3.txt")
#to return the string "i left my body lying somewhere in the
#sands of time". file_2.txt and file_3.txt do not share any
#text, so we would expect check_plagiarism("file_2.txt",
#"file_3.txt") to return the boolean False.
#
#Be careful: there are a lot of ways to do this problem, but
#some would be massively time- or memory-intensive. If you
#get a MemoryError, it means that your solution requires
#storing too much in memory for the code to ever run to
#completion. If you get a message that says "KILLED", it
#means your solution takes too long to run.


#Add your code here!
def check_plagiarism(file1, file2):
    file1 = open(file1, "r")
    file2 = open(file2, "r")
    text1 = file1.read()
    text2 = file2.read()
    words1 = text1.split()
    words2 = text2.split()

    length = 0
    max_length = 0
    max_string = ""
    
    for char1 in range(len(words1) - 4):
        for char2 in range(len(words2) - 4):
            if words1[char1:char1 + 5] == words2[char2:char2 + 5]:
                length = 5
                while char1 + length < len(words1) and char2 + length < len(words2) and words1[char1 + length] == words2[char2 + length]:
                    length += 1
             
            if length > max_length:
                max_length = length
                max_string = " ".join(words1[char1:char1 + length])
        
    if max_string == "":
        return False
    
    else:
        return max_string

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print:
#if i go crazy then
#i left my body lying somewhere in the sands of time
#False
print(check_plagiarism("file_1.txt", "file_2.txt"))
print(check_plagiarism("file_1.txt", "file_3.txt"))
print(check_plagiarism("file_2.txt", "file_3.txt"))

###

#Let's try out a sort of data analysis-style problem. In
#this problem, you're going to have access to a data set
#covering Georgia Tech's all-time football history. The data
#will be a CSV file, meaning that each line will be a comma-
#separated list of values. Each line will describe one game.
#The columns, from left-to-right, are:
#
# - Date: the date of the game, in Year-Month-Day format.
# - Opponent: the name of the opposing team
# - Location: Home, Away, or Neutral
# - Points For: Points scored by Georgia Tech
# - Points Against: Points scored by the opponent
#
#If Points For is greater than Points Against, then Georgia
#Tech won the game. If Points For is less than Points Against,
#then Georgia Tech lost the game. If the two are equal, then
#the game was a tie.
#
#You can see a subsection of this dataset in season2016.csv
#in the top left, but the actual dataset you'll be accessing
#here will have 1237 games.
#
#Write a function called all_time_record. all_time_record
#should take as input a string representing an opposing team
#name. It should return a string representing the all-time
#record between Georgia Tech and that opponent, in the form
#Wins-Losses-Ties. For example, Georgia Tech has beaten
#Clemson 51 times, lost 28 times, and tied 2 times. So,
#all_time_record("Clemson") would return the string "51-28-2".
#
#We have gone ahead and started the function and opened the
#file for you. The first line of the file are headers:
#Date,Opponent,Location,Points For,Points Against. After that,
#every line is a game.


def all_time_record(opponent):
    record_file = open('../resource/lib/public/georgia_tech_football.csv', 'r')
    
    
    #Add some code here! Don't forget to close the file when 
    #you're done reading from it, before returning.
    lines = record_file.readlines()
    record_file.close()
    
    wins = 0
    losses = 0
    ties = 0
    
    for line in lines[1:]:
        game_data = line.strip()
        game_data = line.split(",")
        game_opponent = game_data[1]
        points_for = int(game_data[3])
        points_against = int(game_data[4])
        
        if game_opponent == opponent:
            if points_for > points_against:
                wins += 1
            elif points_for < points_against:
                losses += 1
            else:
                ties += 1
        
    return str(wins) + "-" + str(losses) + "-" + str(ties)
    

#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print: 51-28-2, 51-33-1, and 29-21-3, each on a separate
#line.
print(all_time_record("Clemson"))
print(all_time_record("Duke"))
print(all_time_record("North Carolina"))






















